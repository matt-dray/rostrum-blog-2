{
  "hash": "f22fc2c7f58e8a3f8456cadf9ecea334",
  "result": {
    "markdown": "---\ntitle: Object of type closure can shut up\ndate: 2023-08-19\nslug: find-bad-names\ncategories:\n  - r\n---\n\n\n![](resources/paste.png){fig-alt=\"A string of R code written in Comic Sans that says 'paste <- paste(paste)'.\" width=\"100%\"}\n\n## tl;dr\n\nI wrote an R function to help identify variable names that already exist as function names, like in `c <- 1` or `head <- \"x\"`.\n\n## Naming and shaming\n\nNaming things is hard, yes, but `data` is a short and sensible choice for a dataframe, right?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata[data$column == 1, ]\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in data$column: object of type 'closure' is not subsettable\n```\n:::\n:::\n\n\nOh, silly me, I tried to subset a dataframe called `data` without actually, y'know, creating it first.\n\nThis is [a classic stumbling block](https://stackoverflow.com/search?q=%22object+of+type+%27closure%27+is+not+subsettable%22+%5Br%5D) in R. In short, there's already a function in base R called `data` and so ended up trying subset it. But you can't subset a function, hence the error.\n\nHere's what happens if you subset a non-existent object that has a name that's different to any existing functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x$column == 1, ]\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'x' not found\n```\n:::\n:::\n\n\n'Object not found' is a much more helpful error message.\n\n## What's in a name?\n\nSo it's not a big deal, but using existing function names as variable names is a [code smell](https://en.wikipedia.org/wiki/Code_smell). Especially if they're frequently used functions from base R like `head`, `str`, `paste`,  etc[^subtweet].\n\nBut R doesn't stop you from using these names. In general, R is pretty loose with variable naming, though you can't use a small set of [reserved words](https://search.r-project.org/R/refmans/base/html/Reserved.html) like `TRUE`, `if` or `NA`.\n\nFor example, here we can call the `c()` function to see its (very short) definition. But using it as a variable name obscures the function definition.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc  # this refers to the function\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (...)  .Primitive(\"c\")\n```\n:::\n\n```{.r .cell-code}\nc <- 1\nc  # this now refers to the variable!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nrm(c)  # tidy up by removing variable\n```\n:::\n\n\nCan we write a generic function to identify if some code contains 'bad' variable names in this way?\n\n## Symbolic gesture\n\nOf course. I've made a function called `find_var_names()`. I'm certain the functionality already exists; consider this a thought experiment.\n\nYou provide (a) a string of code to evaluate[^conn] and (b) a vector of names to avoid. The code is parsed with `getparsedata(parse())` to identify variable names[^parse]. It checks for a `SYMBOL` token followed by the assignment operators `<-` or `=`[^assign], or preceded by an assignment operator in the case of `->`[^dassign] (i.e. `*_ASSIGN` tokens). These variable names are then compared to the set of names provided.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfind_var_names <- function(code_string, names_to_find) {\n  \n  # Parse the string of code to identify R 'tokens'\n  parsed <- getParseData(parse(text = code_string, keep.source = TRUE))\n  parsed <- parsed[parsed$text != \"\", ]\n  \n  # Identify subsequent tokens (to help find 'x' in x <- 1 and x = 1)\n  parsed$next_token <- \n    c(parsed$token[2:nrow(parsed)], NA_character_)\n  \n  # Identify prior token (to help find 'x' in 1 -> x)\n  parsed$last_token <- \n    c(NA_character_, parsed$token[1:nrow(parsed) - 1])\n  \n  # Identify variable names with left-assignment\n  lassign <- \n    parsed[parsed$token == \"SYMBOL\" & grepl(\"ASSIGN\", parsed$next_token), ]\n  \n  # Identify row index for variable names following right-assignment\n  rassign_i <- \n    which(parsed$token == \"RIGHT_ASSIGN\" & parsed$next_token == \"SYMBOL\") + 1\n  \n  # Filter for right-assigned variable names\n  rassign <- parsed[rassign_i, ]\n  \n  # Combine the results and sort by location\n  var_names <- rbind(lassign, rassign)\n  var_names <- var_names[sort(row.names(var_names)), ]\n  \n  # Filter for variable names that are in the provided names list\n  var_names[var_names$text %in% names_to_find, !grepl(\"_token\", names(var_names))]\n  \n}\n```\n:::\n\n\nSo, let's say we have this snippet of R code[^rstring] below. It uses some variable names that are already function names, as well as each flavour of assignment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo_code <- r\"{data <- \"x\"\nhead = head(chickwts)\n\"y\" -> df\na <- beaver1[1:3]\nb <- 2 -> c}\"\n```\n:::\n\n\nAnd here's a function that grabs the base packages and the function names within. This is what we'll use as our 'no-go' variable names. You could expand this to include other names, like function names from the tidyverse, for example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_base_functions <- function() {\n  base_names <- sessionInfo()$basePkgs\n  base_pkgs <- paste0(\"package:\", base_names)\n  lapply(base_pkgs, ls) |> unlist() |> unique() |> sort()\n}\n\ntail(get_base_functions())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"xyTable\"    \"xyz.coords\" \"xzfile\"     \"yinch\"      \"zapsmall\"  \n[6] \"zip\"       \n```\n:::\n:::\n\n\nAside: this function uses a little hack. It specificaloy grabs the attached base packages from the `sessionInfo()` listing. There are other base and 'recommended' packages that are actually not attached from the start of your session; see the `Priority` value from the output of `installed.packages()`.\n\nNow we can run the function to check the code for the list of function names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnaughty_words <- find_var_names(\n  code_string = demo_code,\n  names_to_find = get_base_functions()\n)\n\nnaughty_words\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   line1 col1 line2 col2 id parent  token terminal text\n1      1    1     1    4  1      3 SYMBOL     TRUE data\n10     2    1     2    4 10     12 SYMBOL     TRUE head\n31     3    8     3    9 31     33 SYMBOL     TRUE   df\n64     5   11     5   11 64     66 SYMBOL     TRUE    c\n```\n:::\n:::\n\n\nThe output is what you normally get from `getparsedata(parse())`, filtered for the illegal names. Helpfully it shows you the exact row and column indices for where the string exists in the code you provided.\n\nAnd of course you can just isolate the offenders.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnaughty_words$text |> unique() |> sort()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"c\"    \"data\" \"df\"   \"head\"\n```\n:::\n:::\n\n\n## Seeking closure\n\nI probably won't use this function in real life, but maybe the concepts are interesting to you or you can tell me about a linter that does this already.\n\nAt least for now, object of type 'Matthew' is not upsettable.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-08-19 22:17:52 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2 compiler_4.3.1    fastmap_1.1.1     cli_3.6.1        \n [5] tools_4.3.1       htmltools_0.5.5   rstudioapi_0.15.0 yaml_2.3.7       \n [9] rmarkdown_2.23    knitr_1.43.1      jsonlite_1.8.7    xfun_0.39        \n[13] digest_0.6.33     rlang_1.1.1       evaluate_0.21    \n```\n:::\n:::\n\n</details>\n\n[^rstring]: This is an 'R string', introduced in R version 4.0.0. It deals with escaping certain characters and quotes within quotes so that you don't have to. So `\"x <- \"y\"\"` will error but `r\"(x <- \"y\")\"` will return `\"x <- \\\"y\\\"\"`.  You can use symbols other than parentheses, such as curly braces, if your expression already contains parentheses itself.\n[^assign]: If you haven't already [expunged](https://www.rostrum.blog/2021/03/13/assign/) any files containing equals assignment.\n[^dassign]: I'll have to update this in future to work with [down-assignment arrows](https://www.rostrum.blog/2022/06/07/assign-down/).\n[^parse]: If you can be parsed, I've [written about this](https://www.rostrum.blog/2023/03/03/getparsedata/) before.\n[^conn]: Exercise for the reader: have the function accept script files from a connection, not just as a string. I didn't bother for this silly demo.\n[^subtweet]: Please note that this post is not a subtweet! I've read a bunch of code recently---including my own!---that uses variable names in this way.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
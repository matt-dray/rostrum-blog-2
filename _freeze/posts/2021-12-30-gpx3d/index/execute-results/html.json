{
  "hash": "e2e5feadbed6abca3f339a42c026970a",
  "result": {
    "markdown": "---\ntitle: Your workout route (in three dimensions!)\ndate: 2021-12-30\nslug: gpx3d\ncategories:\n  - dataviz\n  - ggrgl\n  - gpx3d\n  - health\n  - r\n---\n\n\n![](resources/gpx3d-demo.gif){fig-alt=\"A 3D plot of a run route in 3D being clicked and dragged to emphasise the lowest and highest points of the route.\" width=\"100%\"}\n\n## tl;dr\n\nYou can use R to extract coordinate and elevation data from a GPX file and then plot it as an interactive 3D object. I put some functions in [the tiny R package {gpx3d}](https://github.com/matt-dray/gpx3d) to help do this.\n\n## Elevate to accumulate\n\nI've seen recently on Twitter some people using [Marcus Volz's {strava} R package](https://github.com/marcusvolz/strava/) to create pleasing visualisations of their running routes as small-multiples.\n\nI don't use Strava, but I downloaded my Apple Health data this week and it contained a folder of GPX files; one for each 'workout' activity recorded via my Apple Watch.[^activity] [GPX files are basically just a type of XML](https://wiki.openstreetmap.org/wiki/GPX) used for storing GPS-related activity.\n\nBut rather than try to emulate {strava}, I thought it might be 'fun' to incorporate the elevation data from a GPX as a third dimension. I've also had [mikefc's {ggrgl} package](https://github.com/coolbutuseless/ggrgl)---'a 3D extension to ggplot'---on my to-do list for a while now.\n\n## An alternate dimension\n\nCut to the chase: I made a tiny package called {gpx3d}. For now it does what I want it to do and it works on my machine.\n\nYou can download it from GitHub with help from the {remotes} package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"remotes\")  # if not yet installed\nremotes::install_github(\"matt-dray/gpx3d\")\n```\n:::\n\n\nThere are a number of dependencies, including many that are not available on CRAN; see [the README for {ggrgl}](https://coolbutuseless.github.io/package/ggrgl/index.html#installation)\nfor details. You must also [install XQuartz](https://www.xquartz.org/), if you havenâ€™t already.\n\nThe package does two things and has two exported functions:\n\n* `extract_gpx3d()` gets the data out of a GPX file (i.e. it reads a GPX file; parses the XML; extracts datetime, latitude, longitude and elevation; converts to sf-class; and calculates the distance covered)\n* `plot_gpx3d()` plots the data as an interactive 3D object (i.e. it takes the output from `extract_gpx3d()`, generates a '3D ggplot' using {ggrgl} and renders it as an interactive object to an external device)\n\nThere are also two demo datasets:\n\n* `segment.gpx`, a GPX file containing a shorter, edited version of the route used in this blogpost, which you can access with `system.file(\"extdata\", \"segment.gpx\", package = \"gpx3d\")` after installing the package\n* `gpx_segment`, an sf-class data.frame that's the result of using the `extract_gpx3d()` on the built-in `segment.gpx` file\n\nRead on for an explanation and examples.\n\n### Extract\n\nThere are already functions that can help read GPX files into R, like `gpx::read_gpx()` and `plotKML::readGPX()`, but I decided to do it by hand with {xml2} to get a custom output format (and to practice handling XML).\n\nIn short, the `extract_gpx3d()` function uses `read_xml()` to read the GPX file, then `as_list()` to convert it to a deeply nested list. A little wrangling is then required to create a data.frame: datetime and elevation can be hoisted out of the list okay, but the longitude and latitude are actually extracted from the attributes.\n\nAfter this, the data.frame is converted to the 'geography-aware' sf-class.[^df] I've done this for two reasons: (1) the output object can be taken away and will play nicely with various {sf} functions, letting you create various maps and perform further processing, and (2) it allowed me to calculate the distance between each recorded point, which could be summed for total distance.\n\nTo use `extract_gpx3d()`, simply pass a path to a GPX file. I've chosen a 10 km run I took on Christmas morning,[^location] which I downloaded from Apple Health and stored locally.[^demo]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile <- \"~/Documents/data/apple_health_export/workout-routes/route_2021-12-25_10.31am.gpx\"\nroute <- gpx3d::extract_gpx3d(file)\nroute[2000:2004, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 5 features and 5 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 0.559015 ymin: 50.85109 xmax: 0.559273 ymax: 50.85109\nGeodetic CRS:  WGS 84\n                    time      ele      lon      lat                  geometry\n2000 2021-12-25 09:13:29 8.406136 0.559273 50.85109 POINT (0.559273 50.85109)\n2001 2021-12-25 09:13:30 8.498508 0.559209 50.85109 POINT (0.559209 50.85109)\n2002 2021-12-25 09:13:31 8.599027 0.559144 50.85109 POINT (0.559144 50.85109)\n2003 2021-12-25 09:13:32 8.721706 0.559079 50.85109 POINT (0.559079 50.85109)\n2004 2021-12-25 09:13:34 8.858613 0.559015 50.85109 POINT (0.559015 50.85109)\n         distance\n2000 4.564465 [m]\n2001 4.494285 [m]\n2002 4.564465 [m]\n2003 4.564465 [m]\n2004 4.492909 [m]\n```\n:::\n:::\n\n\nYou can see the rows are basically a measurement per second (`time`) of the coordinates (`lon` and `lat`) and elevation (`ele`), and that the sf-class metadata and `geometry` column are present, along with the `distance` in metres from the previous to current point.\n\nYou can take this dataset away and do other stuff with it, like create a lat-long plot of the route (below left), or the elevation over time (below right).\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1, 2), mar = rep(0, 4))\nwith(route, plot(lon, lat, type = \"l\", axes = FALSE))\nwith(route, plot(time, ele, type = \"l\", axes = FALSE))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-2d-1.png){fig-alt='Two plots: to the left a line showing the route of the run; to the right a line showing the elevation over time. The route is a single loop, roughly rectanglular but with several kinks. The elevation rises before dropping steeply to a plateau, then sharply rising again.' width=672}\n:::\n:::\n\n\nIf you're wondering about the little 'tail' in the bottom right of the route, I accidentally joined the back of a Parkrun, so quickly did a hairpin turn to escape. Except the Parkrun route is a 'there-and-back' course, so the confused stewards thought I was now in the lead with a pace of about two minutes per kilometre. Whoops!\n\nThe elevation plot is pretty dramatic: roughly, it goes downhill to a small plateau, down again to a flatter plateau, then the inevitable (steep!) climb. The lowest plateau is along the seafront, so basically sea level.\n\nBut boo! Only two dimensions? You can instead use the plotting function built in to {gpx3d} for something a bit more exciting.\n\n### Plot\n\nAll the hard work of plotting is done primarily by {ggplot2} and {ggrgl}. The former is probably well-known to readers; the latter is an extension [written by mikefc](https://twitter.com/coolbutuseless) to introduce a third dimension to ggplot objects. In other words, you can extrude your plot along some third variable to generate a z-axis.\n\nThere's [a whole bunch of specialised 3D geoms](https://coolbutuseless.github.io/package/ggrgl/index.html#3-dimensional-geometry-types-z-and-3d) in {ggrgl}. For my purposes, I wanted to extend a `geom_path()` line plot into the third dimension. This is achieved by adding a `z` argument to the `aes()` call of the `geom_path_3d()` function, where `z` is our elevation data. \n\nAnd so the `plot_gpx3d()` function in {gpx3d} renders the plot as an interactive 3D object with {rgl} to an external `devoutrgl::rgldev()` graphics device.[^route-only] You can then click and drag it with your mouse and use the scrollwheel to zoom. I've embedded a gif of the output at the top of this thread.[^embed]\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngpx3d::plot_gpx3d(route)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\nYou can see why I chose this particular route for the demo; it really shows off the power of the elevation data. I ran anti-clockwise downhill to the seafront, where it was almost entirely flat, before running back up a relatively sharp ascent.\n\nMight have made a nice print if I'd been gifted a 3D printer for Christmas!\n\n## A romance of many dimensions\n\nI've made {gpx3d} entirely for my own amusement, so your kilometreage may vary. At this point I can't make any guarantees about whether it will even work on your machine, but hopefully I'll find time in future to make sure it does. It might also be nice to include more user options for adjusting the output so you aren't stuck with 'ggplot grey' and the same defaults mikefc used in a vignette showing a {ggrgl} [version of Minard's famous visulisation of Napoleon's march](https://coolbutuseless.github.io/package/ggrgl/articles/geom-path-3d.html).[^rayshader]\n\nI'll also be thinking about developing {gpx4d} and functions like `geom_tesseract()`, but I might need physics to catch up first.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-07-04 19:50:41 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.3        cli_3.6.1          knitr_1.43.1       rlang_1.1.1       \n [5] xfun_0.39          DBI_1.1.3          KernSmooth_2.23-21 generics_0.1.3    \n [9] sf_1.0-13          jsonlite_1.8.7     glue_1.6.2         htmltools_0.5.5   \n[13] e1071_1.7-13       fansi_1.0.4        rmarkdown_2.23     grid_4.3.1        \n[17] tibble_3.2.1       evaluate_0.21      classInt_0.4-9     fastmap_1.1.1     \n[21] lifecycle_1.0.3    yaml_2.3.7         compiler_4.3.1     dplyr_1.1.2       \n[25] pkgconfig_2.0.3    htmlwidgets_1.6.2  Rcpp_1.0.10        rstudioapi_0.14   \n[29] digest_0.6.31      wk_0.7.3           R6_2.5.1           tidyselect_1.2.0  \n[33] utf8_1.2.3         class_7.3-22       pillar_1.9.0       magrittr_2.0.3    \n[37] tools_4.3.1        proxy_0.4-27       s2_1.1.4           gpx3d_0.0.0.9002  \n[41] units_0.8-2        xml2_1.3.4        \n```\n:::\n:::\n\n</details>\n\n[^activity]: [I wrote earlier in the year about wrangling my Nike Run Club data via Apple Health](https://www.rostrum.blog/2021/03/23/xml-health/). It seems as though NRC doesn't pass geographic information to Health, but now I also record my runs via the Workout app on the watch, which does regurgitate the geo-related data.\n[^rayshader]: I also realised later that [Tyler Morgan-Wall already did something like this with {rayshader}](https://twitter.com/tylermorganwall/status/1024996007094968320?s=20). I should have guessed.\n[^df]: Or you can return a simpler data.frame without the sf-class by passing `sf_out = FALSE` to `extract_gpx3d()`.\n[^demo]: You could try using the demo GPX file that's included in the package, using `file <- system.file(\"extdata\", \"segment.gpx\", package = \"gpx3d\")`\n[^lick]: I originally wrote 'mouselick' instead of 'mouseclick', which is a very different thing.\n[^location]: In a place I do not live, so minimal opsec-leaking here.\n[^embed]: I originally managed to embed the interactive object in the blog itself after [peeking at mikefc's vignettes for {ggrgl}](https://github.com/coolbutuseless/ggrgl/blob/main/vignettes/geom-path-3d.Rmd), but this seemed to fail when I later tried to re-render the post. I've left the code I used to do this in the source of this post (in the hidden chunks labelled 'plot-unused' and 'rglwidget-unused') if you want to check it out yourself.\n[^route-only]: Note that you can also set the argument `route_only` to `TRUE` to get rid of all the chart elements and leave behind the path only.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "9696936eb6997fd0e71ffcd66e60a42a",
  "result": {
    "markdown": "---\ntitle: \"Reveal a hidden gorilla with {magick}\"\ndate: 2021-10-05\nslug: gorilla\ncategories:\n  - magick\n  - r\n  - raster\n---\n\n\n![](resources/gorilla.png){fig-alt=\"A picture of a cartoon gorilla whose outline is composed of red and blue dots.\" width=\"50%\"}\n\n## tl;dr\n\nYou can convert a line drawing to datapoints with [a sprinkle of {magick}](https://docs.ropensci.org/magick/).\n\n## Ape escape\n\nHave you seen [that video](http://www.theinvisiblegorilla.com/gorilla_experiment.html) where you're so focused on counting basketball passes that you fail to see the gorilla moving across the screen?\n\nThis kind of selective attention was studied by two researchers, Yanai and Lercher, who provided subjects with a dataset that looked like a gorilla when plotted. [The gorilla was found less often if the subjects were also given a hypothesis to investigate](https://www.biorxiv.org/content/10.1101/2020.07.30.228916v1).\n\nThe study got some attention on Twitter last week. As a result, [Isabella Vel√°squez wrote a great blogpost](https://ivelasq.rbind.io/blog/reticulate-data-recreation/) where she recreated the dataset using R and Python in tandem via [the {reticulate} package](https://rstudio.github.io/reticulate/).\n\nI had a go at creating the dataset with base R and [the excellent {magick} package for image manipulation](https://docs.ropensci.org/magick/).\n\n## Point it out\n\nThe jpeg image file used in the original paper can be downloaded from classroomclipart.com to a temporary location on your machine.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndownload.file(\n  paste0(\n    \"https://classroomclipart.com/images/gallery/\",\n    \"Clipart/Black_and_White_Clipart/Animals/\",\n    \"gorilla-waving-cartoon-black-white-outline-clipart-914.jpg\" \n  ),\n  tempfile(fileext = \".jpg\")\n)\n```\n:::\n\n\nWe can read the file into R with {magick}.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimg <- \n  list.files(tempdir(), pattern = \".jpg$\", full.names = TRUE) |>\n  magick::image_read()\n\nimg\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/orig-img-1.png){fig-alt='A line drawing of a cartoon gorilla waving.' width=206}\n:::\n:::\n\n\nWith other {magick} functions we can:\n\n* reduce to two distinct colours only (i.e. for the lines and background), which makes it easier to filter the data later\n* convert from an image to point data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngo <- img |>\n  magick::image_quantize(2) |>  # colour reduction\n  magick::image_raster() |>     # as x-y data\n  as.data.frame()\n\nhead(go)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y       col\n1 1 1 #fefefeff\n2 2 1 #fefefeff\n3 3 1 #fefefeff\n4 4 1 #fefefeff\n5 5 1 #fefefeff\n6 6 1 #fefefeff\n```\n:::\n:::\n\n\nAnd to prove we only have two colours (off-white for the background, grey for the lines):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(go$col)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"#fefefeff\" \"#555555ff\"\n```\n:::\n:::\n\n\nNow we can:\n\n* reverse the order of the `y` values so the gorilla is right-side up\n* filter to retain only the datapoints that represent lines\n* rescale the `x` and `y` to create 'Body Mass Index' (BMI)[^bmi] and 'steps' variables\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngo$y     <- rev(go$y)\ngo       <- go[go$col != \"#fefefeff\", ]\ngo$bmi   <- go$y / max(go$y) * 17 + 15\ngo$steps <- 15000 - go$x * 15000 / max(go$x)\n\nhead(go)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      x   y       col bmi    steps\n174 174 550 #555555ff  32 8665.049\n175 175 550 #555555ff  32 8628.641\n176 176 550 #555555ff  32 8592.233\n196 196 550 #555555ff  32 7864.078\n198 198 550 #555555ff  32 7791.262\n199 199 550 #555555ff  32 7754.854\n```\n:::\n:::\n\n\nYou may have noticed that the image has a watermark. We could have removed it earlier with {magick}, but can do it now by filtering out the datapoints in that corner.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngo$logo <- ifelse(go$bmi < 16 & go$steps < 5500, TRUE, FALSE)\ngo      <- go[!go$logo, ]\n```\n:::\n\n\nThis leaves us with 16865 datapoints. We can follow the original study by taking a sample and splitting the results into 'female' and 'male' groups, weighted so that the female group has higher step counts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngo_smp       <- go[sample(nrow(go), 1768), ]\ngo_smp$rnorm <- rnorm(nrow(go_smp), mean = 0, sd = 10)\ngo_smp$index <- go_smp$steps * (1 + go_smp$rnorm)\ngo_smp$group <- \n  ifelse(go_smp$index < median(go_smp$steps), \"F\", \"M\") |>\n  as.factor()\n\nhead(go_smp[, c(\"bmi\", \"steps\", \"group\")])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            bmi       steps group\n135597 21.83091 13216.01942     F\n85694  25.60182    72.81553     F\n199825 17.00909 14817.96117     F\n43530  28.75455  5169.90291     M\n200308 16.97818 12233.00971     F\n55403  27.85818  7900.48544     F\n```\n:::\n:::\n\n\nNow finally to plot the datasets side-by-side.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1, 2))\n\nwith(\n  go_smp[go_smp$group == \"F\", ],\n  plot(\n    steps, bmi,\n    xlim = c(0, 15000),\n    pch = 16, cex = 0.5, col = \"blue\",\n    xlab = \"Steps\", ylab = \"BMI\", \n  )\n)\n\nwith(\n  go_smp[go_smp$group == \"M\", ],\n  plot(\n    steps, bmi, \n    xlim = c(0, 15000),\n    pch = 16, cex = 0.5, col = \"red\",\n    xlab = \"Steps\", ylab = \"BMI\"\n  )\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/two-plots-1.png){fig-alt='Two side-by-side plots of steps (x) against BMI (y) where both sets of datapoints look like a cartoon gorilla waving.' width=672}\n:::\n:::\n\n\nI see them!\n\nThis has been a bit overengineered and could be generalised, but it gives a gist of how you might go about converting an image to a dataframe of x and y positions.\n\nAt worst, this is a reminder not to trust researchers and to always check for unexpected gorillas.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-07-07 21:11:24 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.31     fastmap_1.1.1     xfun_0.39         magrittr_2.0.3   \n [5] knitr_1.43.1      htmltools_0.5.5   png_0.1-8         rmarkdown_2.23   \n [9] cli_3.6.1         compiler_4.3.1    rstudioapi_0.14   tools_4.3.1      \n[13] evaluate_0.21     Rcpp_1.0.10       yaml_2.3.7        magick_2.7.4     \n[17] rlang_1.1.1       jsonlite_1.8.7    htmlwidgets_1.6.2\n```\n:::\n:::\n\n</details>\n\n[^bmi]: Check out [a recent episode of the _Maintenance Phase_ podcast](http://maintenancephase.com/) (dated 2021-08-03) about the troublesome history and development of BMI as a metric.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
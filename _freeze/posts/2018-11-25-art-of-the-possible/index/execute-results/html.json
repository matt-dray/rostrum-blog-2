{
  "hash": "d2382af23bf67e8ada02ea7a946550e1",
  "result": {
    "markdown": "---\ntitle: Quantify colour by {magick}\nauthor: Matt Dray\ndate: 2018-11-25\nslug: art-of-the-possible\ncategories:\n  - colour\n  - r\n  - magick\n---\n\n\n## tl;dr\n\nI used [the {magick} package](https://docs.ropensci.org/magick/articles/intro.html) in R to map an image's colours to their nearest match from a simplified palette, then quantified how much of the image was covered by each colour in that palette.\n\n<div class=\"tip\"> \n`<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c13.3 0 24 10.7 24 24V264c0 13.3-10.7 24-24 24s-24-10.7-24-24V152c0-13.3 10.7-24 24-24zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z\"/></svg>`{=html} <b>Note</b>\n\nI later learnt about [{colorfindr}](https://github.com/zumbov2/colorfindr) by [David Zumbach](https://twitter.com/DavidZumbach), which can extract colours from images, provide composition details and generate palettes. Check it out.\n</div><p>\n\n## Colour search\n\nAs a side project at work, we wanted users to be able to search images of artwork by their prevalence of colours from a small simple palette (red, blue, yellow, etc). Lots of online services let you sort images by colour, like [Google Arts & Culture](https://artsexperiments.withgoogle.com/artpalette/colors/a46053-433932-c2ad8f-b5996a-746251), [Designspiration](https://www.designspiration.net/search/saves/?q=%2389ebd7%20%23afff11%20%23e5ff91%20%23ff9775%20%23f38d00) and [TinEye Multicolr](https://labs.tineye.com/multicolr/).\n\n## Art of the possible\n\nWhat might be a relatively simple and straightforward way to do this in R? By 'simple' I mean we don't want to do any hard work. We don't want to consider any colour theory[^theory] and we want to stick to simple, easily-named colours like 'green'.[^drab]\n\nSo, we can do the following:\n\n1. Read in an image\n2. Prepare a set of 'simple colours'\n3. Map the simple colours to the image\n4. Quantify the colours\n\n## It's a kind of ImageMagick\n\nThe [{magick}](https://docs.ropensci.org/magick/articles/intro.html) R package is an implementation of [ImageMagick](https://www.imagemagick.org/script/index.php), an open-source software suite whose emphasis is image manipulation from the command line. The flexibility of {magick} can be seen in its [vignette](https://cran.r-project.org/web/packages/magick/vignettes/intro.html).\n\nThe package was created and is maintained by [Jeroen Ooms](https://twitter.com/opencpu?lang=en), a software engineer and postdoc at [rOpenSci](https://ropensci.org/), a collective that seeks [to develop tools for open and reproducible research](https://ropensci.org/packages/).\n\n[rOpenSci hosted a workshop](https://ropensci.org/blog/2018/10/24/commcall-nov2018/) from Ooms about working with images in R and the [presentation slides](https://jeroen.github.io/munster2018/) caught my attention. I've used some of Jeroen's code below.\n\n## Code\n\nFirst we need to load our packages; all are available from CRAN.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages({\n  library(dplyr)\n  library(tibble)\n  library(magick)\n})\n```\n:::\n\n\n### Read a test image\n\nI've chosen a colourful image to use for our test case: it's a picture of a bunch of [Lego Duplo bricks](https://www.lego.com/en-gb/themes/duplo).[^duplo]\n\nWe'll use `image_read()` to read the JPEG as an object of class 'magick' and then `image_scale()` to reduce the image size and save some space.\n\nPrinting the image also gives us some details of format, dimensions, etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Path to the image\nduplo_path <- \"https://upload.wikimedia.org/wikipedia/commons/thumb/a/ac/Lego_dublo_arto_alanenpaa_2.JPG/2560px-Lego_dublo_arto_alanenpaa_2.JPG\"\n\n# Read as magick object and resize\nduplo <- image_read(duplo_path) %>%\n  image_scale(geometry = c(\"x600\"))\n\nprint(duplo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 7\n  format width height colorspace matte filesize density\n  <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>  \n1 JPEG     900    600 sRGB       FALSE        0 72x72  \n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/duplo-1.png){width=450}\n:::\n:::\n\n\n### Prepare simple colours\n\nWe'll map a set of simple colours to the test image. This means that the colours from the test image will be replaced by the 'closest' colour from our simple set.\n\nOne way to do this is to define our simple colour set and create an image from them. In this case I'm taking just six colours.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate named vector of 'simple' colours\ncols_vec <- setNames(\n  c(\"#000000\", \"#0000ff\", \"#008000\", \"#ff0000\", \"#ffffff\", \"#ffff00\"),\n  c(\"black\", \"blue\", \"green\", \"red\", \"white\", \"yellow\")\n)\n```\n:::\n\n\nThen we can plot squares of these colours, using `image_graph()` to read them as magick-class objects.[^magickclass] My method here is not the most efficient, but you can see the output is an image that contains our six colours.\n\n<details><summary>Click for code</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\n# For each vector element (colour) create a square of that colour\nfor (i in seq_along(cols_vec)) {\n  fig_name <- paste0(names(cols_vec)[i], \"_square\")  # create object name\n  assign(\n    fig_name,  # set name\n    image_graph(width = 100, height = 100, res = 300)  # create magick object\n  )\n  par(mar = rep(0, 4))  # set plot margins\n  plot.new()  # new graphics frame\n  rect(0, 0, 1, 1, col = cols_vec[i], border = cols_vec[i])  # build rectangle\n  assign(fig_name, magick::image_crop(get(fig_name), \"50x50+10+10\")) # crop\n  dev.off()  # shut down plotting device\n  rm(i, fig_name)  # clear up\n}\n\n# Generate names of the coloured square objects\ncol_square <- paste0(names(cols_vec), \"_square\")\n\n# Combine magick objects (coloured squares)\nsimple_cols <- image_append(c(\n  get(col_square[1]), get(col_square[2]), get(col_square[3]),\n  get(col_square[4]), get(col_square[5]), get(col_square[6])\n))\n```\n:::\n\n</details>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(simple_cols)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 7\n  format width height colorspace matte filesize density\n  <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>  \n1 PNG      300     50 sRGB       TRUE         0 300x300\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/print-col-squares-1.png){width=150}\n:::\n:::\n\n\n#### Map to the image\n\nNow we can apply the simple colour set to the test image using `image_map()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nduplo_mapped <- image_map(image = duplo, map = simple_cols)\n```\n:::\n\n\nAnd we can use `image_animate()` to see the difference between the two.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimage_animate(c(duplo, duplo_mapped), fps = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/animation-1.gif)\n:::\n:::\n\n\nGreat. You can see where the original colours have been replaced by the 'closest' simple colours. \n\nNote in particular where the more reflective surfaces are mapped to white than the actual brick colour. \n\nThis is okay: the brick may be blue, but we've only defined _one_ shade of blue. If a particular shade is closer to white, then so be it.\n\n### Quantify the colours\n\nNow we can take this mapped image and quantify how much of the image belongs to each colour. Imagine we've broken the image into pixels and then we're counting how many belng to each of our six colours.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to count the colours (adapted from Jeroen Ooms)\ncount_colors <- function(image) {\n  data <- image_data(image) %>%\n    apply(2:3, paste, collapse = \"\") %>% \n    as.vector %>% table() %>%  as.data.frame() %>% \n    setNames(c(\"hex\", \"freq\"))\n  data$hex <- paste(\"#\", data$hex, sep=\"\")\n  return(data)\n}\n\n# Dataframe of dominant colours \nduplo_col_freq <- duplo_mapped %>%\n  count_colors() %>%\n  left_join(\n    enframe(cols_vec) %>% rename(hex = value),\n    by = \"hex\"\n  ) %>% \n  arrange(desc(freq)) %>% \n  mutate(percent = 100*round((freq/sum(freq)), 3)) %>% \n  select(\n    `Colour name` = name, Hexadecimal = hex,\n    `Frequency of colour` = freq, `Percent of image` = percent\n  )\n\nduplo_mapped  # see mapped image again\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/count-colours-1.png){width=450}\n:::\n\n```{.r .cell-code}\nknitr::kable(duplo_col_freq)  # quantify colour\n```\n\n::: {.cell-output-display}\n|Colour name |Hexadecimal | Frequency of colour| Percent of image|\n|:-----------|:-----------|-------------------:|----------------:|\n|red         |#ff0000     |              132135|             24.5|\n|white       |#ffffff     |              107841|             20.0|\n|black       |#000000     |              103645|             19.2|\n|yellow      |#ffff00     |               79750|             14.8|\n|green       |#008000     |               64868|             12.0|\n|blue        |#0000ff     |               51761|              9.6|\n:::\n:::\n\n\nSo red makes up almost a quarter of the image, with white and black just behind. This makes sense: many of the bricks are red and much of the shadow areas of yellow bricks were rendered as red, while black and white make up many of the other shadows and reflective surfaces.\n\n## And so we must p-art\n\nSo, you can map a simple colour set to an image with {magick} and then quantify how much of the image is covered by that simple set.\n\nOf course, there are many possibilities beyond what's been achieved here. For example, you could create a tool where the user chooses a colour and images are returned in order of dominance for that colour. You could also write this all into a function that takes a folder of images and returns the percentage of each colour in each image.\n\nBelow are some additional examples of the approach taken in this post.\n\n### Reef fish\n\n<details><summary>Click for details</summary>\n\nImage by [Richard L Pyle from Wikimedia Commons, CC0 1.0.](https://commons.wikimedia.org/wiki/File:100%25_reef-fish_Endemism_at_90_m_off_Kure_Atoll.jpg)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreef_path <- \"https://upload.wikimedia.org/wikipedia/commons/0/05/100%25_reef-fish_Endemism_at_90_m_off_Kure_Atoll.jpg\"\n\nreef <- image_read(reef_path) %>%\n  image_scale(geometry = c(\"x600\"))\n\nreef_mapped <- image_map(image = reef, map = simple_cols)\n\nreef_col_freq <- reef_mapped %>%\n  count_colors() %>%\n  left_join(\n    enframe(cols_vec) %>% rename(hex = value),\n    by = \"hex\"\n  ) %>% \n  arrange(desc(freq)) %>% \n  mutate(percent = 100*round((freq/sum(freq)), 3)) %>% \n  select(\n    `Colour name` = name, Hexadecimal = hex,\n    `Frequency of colour` = freq, `Percent of image` = percent\n  )\n\nreef_animate <- image_animate(c(reef, reef_mapped), fps = 1)\n```\n:::\n\n</details>\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/reef-print-1.gif){fig-alt='A photo of fish on a reef, animated to show it in full colour and then simplified colour.'}\n:::\n\n::: {.cell-output-display}\n|Colour name |Hexadecimal | Frequency of colour| Percent of image|\n|:-----------|:-----------|-------------------:|----------------:|\n|blue        |#0000ff     |              317143|             49.5|\n|black       |#000000     |              214642|             33.5|\n|green       |#008000     |               76234|             11.9|\n|yellow      |#ffff00     |               13296|              2.1|\n|red         |#ff0000     |               10086|              1.6|\n|white       |#ffffff     |                8799|              1.4|\n:::\n:::\n\n\n### Hong Kong lights\n\n<details><summary>Click for details</summary>\n\nImage by [Daniel Case from Wikimedia Commons, CC BY-SA 3.0](https://commons.wikimedia.org/wiki/File:Neon_lights,_Nathan_Road,_Hong_Kong.jpg)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneon_path <- \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/b0/Neon_lights%2C_Nathan_Road%2C_Hong_Kong.jpg/900px-Neon_lights%2C_Nathan_Road%2C_Hong_Kong.jpg\"\n\nneon <- image_read(neon_path) %>%\n  image_scale(geometry = c(\"x600\"))\n\nneon_mapped <- image_map(image = neon, map = simple_cols)\n\nneon_col_freq <- neon_mapped %>%\n  count_colors() %>%\n  left_join(\n    enframe(cols_vec) %>% rename(hex = value),\n    by = \"hex\"\n  ) %>% \n  arrange(desc(freq)) %>% \n  mutate(percent = 100*round((freq/sum(freq)), 3)) %>% \n  select(\n    `Colour name` = name, Hexadecimal = hex,\n    `Frequency of colour` = freq, `Percent of image` = percent\n  )\n\nneon_animate <- image_animate(c(neon, neon_mapped), fps = 1)\n```\n:::\n\n</details>\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/neon-print-1.gif){fig-alt='A photo of Hong Kong neon lights, animated to show it in full colour and then simplified colour.'}\n:::\n\n::: {.cell-output-display}\n|Colour name |Hexadecimal | Frequency of colour| Percent of image|\n|:-----------|:-----------|-------------------:|----------------:|\n|black       |#000000     |              191573|             71.0|\n|green       |#008000     |               23126|              8.6|\n|blue        |#0000ff     |               18454|              6.8|\n|red         |#ff0000     |               17553|              6.5|\n|yellow      |#ffff00     |               10872|              4.0|\n|white       |#ffffff     |                8422|              3.1|\n:::\n:::\n\n\n### Ladybird\n\n<details><summary>Click for details</summary>\n\nImage by [Elena Andreeva from Wikimedia Commons, CC0 1.0.](https://commons.wikimedia.org/wiki/File:Erysimum_Cheiranthoides_(215134987).jpeg)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlbird_path <- \"https://upload.wikimedia.org/wikipedia/commons/d/d5/Erysimum_Cheiranthoides_%28215134987%29.jpeg\"\n\nlbird <- image_read(lbird_path) %>%\n  image_scale(geometry = c(\"x600\"))\n\nlbird_mapped <- image_map(image = lbird, map = simple_cols)\n\nlbird_col_freq <- lbird_mapped %>%\n  count_colors() %>%\n  left_join(\n    enframe(cols_vec) %>% rename(hex = value),\n    by = \"hex\"\n  ) %>% \n  arrange(desc(freq)) %>% \n  mutate(percent = 100*round((freq/sum(freq)), 3)) %>% \n  select(\n    `Colour name` = name, Hexadecimal = hex,\n    `Frequency of colour` = freq, `Percent of image` = percent\n  )\n\nlbird_animate <- image_animate(c(lbird, lbird_mapped), fps = 1)\n```\n:::\n\n</details>\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/lbird-print-1.gif){fig-alt='A photo of a ladybird on a leaf, animated to show it in full colour and then simplified colour.'}\n:::\n\n::: {.cell-output-display}\n|Colour name |Hexadecimal | Frequency of colour| Percent of image|\n|:-----------|:-----------|-------------------:|----------------:|\n|white       |#ffffff     |              302626|             54.6|\n|blue        |#0000ff     |              118010|             21.3|\n|yellow      |#ffff00     |              101797|             18.4|\n|green       |#008000     |               27892|              5.0|\n|red         |#ff0000     |                2322|              0.4|\n|black       |#000000     |                1153|              0.2|\n:::\n:::\n\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-08-05 17:29:58 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] magick_2.7.4 tibble_3.2.1 dplyr_1.1.2 \n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.3       cli_3.6.1         knitr_1.43.1      rlang_1.1.1      \n [5] xfun_0.39         png_0.1-8         generics_0.1.3    jsonlite_1.8.7   \n [9] glue_1.6.2        htmltools_0.5.5   fansi_1.0.4       rmarkdown_2.23   \n[13] evaluate_0.21     fontawesome_0.5.1 fastmap_1.1.1     yaml_2.3.7       \n[17] lifecycle_1.0.3   compiler_4.3.1    htmlwidgets_1.6.2 Rcpp_1.0.11      \n[21] pkgconfig_2.0.3   rstudioapi_0.15.0 digest_0.6.33     R6_2.5.1         \n[25] tidyselect_1.2.0  utf8_1.2.3        curl_5.0.1        pillar_1.9.0     \n[29] magrittr_2.0.3    withr_2.5.0       tools_4.3.1      \n```\n:::\n:::\n\n</details>\n\n[^theory]: Just as well, because I'm colourblind.\n[^drab]: There are [five named versions of olive drab](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf) in R's named palette.\n[^duplo]: [Photo by Arto Alanenpää](https://commons.wikimedia.org/wiki/Lego#/media/File:Lego_dublo_arto_alanenpaa_2.JPG), CC0-BY-4.0 from Wikimedia Creative Commons.\n[^magickclass]: Artefacts introduced during compression of PNGs and JPGs might mean that your set of six colours ends up being _more_ than six. It's preferable to generate our colour set within R, inside `image_graph()`, so that we have only our six defined colours.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
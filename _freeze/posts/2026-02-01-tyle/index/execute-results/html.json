{
  "hash": "34ed386965e05604c5b81567e90d6d7a",
  "result": {
    "markdown": "---\ntitle: \"A roguelike-like with tyle\"\ndate: 2026-02-01\nslug: \"tyle\"\nimage: resources/tyle.png\ncategories:\n  - cli\n  - python\n  - tyle\n  - uv\n---\n\n\n![](resources/tyle.png){fig-align=\"left\" fig-alt=\"A 10 by 10 grid of characters printed to a macOS terminal. Tiles are mostly period characters, with some hashmark characters, and an at symbol near the middle. A prompt underneath reads 'Move (WASD)+Enter:', ready for user input.\" width=\"100%\"}\n\n## tl;dr\n\nI'm writing [tyle](https://github.com/matt-dray/tyle) to help me Python.\nAnd help me fun?\n\n## Very early access\n\nI've started [tyle](https://github.com/matt-dray/tyle), a concept Python CLI that contains the foundations for a little in-terminal tile- and turn-based game.\n\nThe rudimentary tool is available to install (v0.1.0 at time of writing).\nI like [uv](https://docs.astral.sh/uv/) for this job[^tool]:\n\n```bash\nuv tool install git+https://github.com/matt-dray/tyle.git\n```\n\nYou can start a 'game' (heavy emphasis on those quote marks) by typing:\n\n```bash\ntyle\n```\n```\n.......#..\n..........\n.##..#....\n....#....#\n......#...\n.....@....\n..#.......\n........#.\n..........\n....#.....\nMove (WASD+Enter): \n```\n\nThe gameboard is just a tile grid printed to the terminal.\nYou (the `@` symbol) can travel around the floor tiles (`.`), but not through obstacles (`#`, which are randomised) or off the map. \n\nAt the prompt you can type <kbd>W</kbd> and <kbd>Enter</kbd> to move up, for example.\n<kbd>Q</kbd> and <kbd>Enter</kbd> will quit.\n\nAaand that's it for now[^awards].\n\n<div class=\"tip\"> \n`<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c13.3 0 24 10.7 24 24V264c0 13.3-10.7 24-24 24s-24-10.7-24-24V152c0-13.3 10.7-24 24-24zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z\"/></svg>`{=html} <b>Note</b>\n\nA quick update on changes in v0.1.0.9001, made immediately after this post ().\nI've added CLI options so you can do something like `tyle -r 10 -c 20 -w 25` to set the starting count of `--rows`, `--columns` and `--walls` (see `tyle -h` for help).\nI also adjusted the column- and wall-count defaults and added a space between adjacent tiles; and introduced colours (but only if your terminal suports [ANSI codes](https://en.wikipedia.org/wiki/ANSI_escape_code), like zsh in the image below).\n\n![](resources/tyle-dev.png){fig-align=\"left\" width=\"50%\" fig-alt=\"A 10 by 20 grid of characters printed to a zsh terminal. The majority are floor tiles, which are are grey period symbols. Randomly-placed walls are red hash symbols. The player is a yellow at symbol in the middle. A prompt underneath reads 'Move (WASD)+Enter:', ready for user input.\"}\n\n</div>\n\n## Like Rogue?\n\nThis game style and ASCII 'graphics' may be familiar as the blueprint for [the classic videgame _Rogue_](https://en.wikipedia.org/wiki/Rogue_(video_game)) (1980).\nKey features are things like text-based graphics, turn-based player interaction, and permadeath. \nLater games aped this style and adapted with it, giving rise to the 'roguelike' and 'roguelite' genres.\n\nThe scope here is far tighter: I promise nothing.\nSo let's call this a roguelike-like for now.\n\n## A sidequest\n\nTo explain the meta, I've been making some twee little projects to help me learn Python.\nFirst [jot](https://github.com/matt-dray/jot), then [pet](https://github.com/matt-dray/pet).\ntyle is also a Python-backed CLI but is helping me learn more about classes.\n\nAs someone with a background in R, I tend to think every nail can be hammered with a function.\nR supports classes, of course, most recently with [the {S7} package](https://rconsortium.github.io/S7/index.html)[^frivolity].\nBut the approach feels far more at home in Python with its greater focus on 'programming' than 'doing statistics'[^take].\n\nIn tyle, there are currently three main classes:\n\n* `Tile` that represent the tiles of the world map\n* `TileGrid` to generate the world map from tile objects\n* `Entity` to create the player character\n\nEach of these have properties and methods that allow them to store data and be queried in certain ways.\n\nTile objects contain information like whether they're traversable; tile-grid objects store the tile grid as a list of lists of tile objects and are responsible for printing the map; and entities serve as the blueprint for creating the player object, hosting parameters for tile coordinates and hit points, for example.\n\nSo, at its core, the map can be indexed by 'rows' and 'columns' that are really just sublist and list-element positions.\nWhen printing the map, the player is drawn over the user-specified position if the move clears legality checks (i.e. you can't move onto an obstacle nor exit the map boundary).\n\nWe have separate 'terrain' and an 'entity' layers, basically.\n\n### Grouting\n\nAs it stands, you can see the Python code in [the `tiles.py` file](https://github.com/matt-dray/tyle/tree/main/src/tyle).\nThe simplest possible example of a class there is `Tile`:\n\n```python\nclass Tile:\n    def __init__(self, symbol: str, traversable: bool) -> None:\n        self.symbol = symbol\n        self.traversable = traversable\n```\n\nI've shown the type hints[^ty] but hidden the docstrings for brevity.\n\nSo you:\n\n1. Declare with `class`.\n2. Use an UpperCamelCase name by convention.\n3. `def`ine a function to `__init__`ialise the class, with reference to:\n    a. `self`, i.e. the class itself.\n    b. 'normal' function arguments (`symbol` is the text character representing the tile and `traversable` is whether the tile can be moved across).\n4. Set properties that may just be the arguments, or passed through other functions.\n5. `def`ine functions (methods) within the body of the class (not shown here becuase the `Tile` class doesn't currently have any).\n\nAnd then you can call it like:\n\n```python\ntile = Tile(\".\", True)\n```\n\nSo we've created a tile object with the `Tile` class and parameters for its symbol when printed (a period) and whether it can be moved across (it can).\nAnd we can access these properties (and methods) with dot notation, like:\n\n```python\ntile.symbol\n```\n```\n'.'\n```\n\nThat's a _very_ simple example.\nYou can imagine how the `Entity` class has parameters like `hp` (hit points) and `TileGrid` has a `draw` method to print the map to the screen.\n\nLater we could create subclasses from the `Entity` class, so `Player` and `Enemy` could inherit the properties and methods from `Entity`, but maybe `Player` has a `name` or something.\n\n## Hack\n\n> But I've read about [the {r.oguelike} R package](https://github.com/matt-dray/r.oguelike) on [this blog](https://www.rostrum.blog/index.html#category=r.oguelike) before.\n> Have you run out of ideas?\n\nUh-oh, I've been rumbled.\n\nListen, agitator: an approach composed entirely of R functions was never the 'right' choice for this type of thing.\nNot least because that particular 'game' had to be played in the R console, rather than the terminal directly.\n\nPython is far more suited to this type of activity.\nIn fact, Python can be used as a full-blown game engine, aided by tools like [PyGame](https://www.pygame.org/docs/).\nIn fact, there are several roguelike-specific packages to help you build roguelikes specifically, like [libtcod](https://github.com/libtcod/libtcod).\n\nI'm ignoring these because I want to use this little project to help me learn Python skills, not roguelike-making skills, specifically.\nClasses, yes, but also stuff like type hints, docstrings, writing modules, creating CLIs, etc.\n\n## Game over?\n\nAs ever, I may stop there[^shot].\nBut there are some obvious improvements that would also strengthen my skills.\n\nA bunch of stuff from {r.oguelike} could be interesting to translate here, like procedural dungeons, enemy pathfinding and a styled interface.\n\nOf course, we probably want to 'listen' to keyboard input, which is a more natural approach to interactivity versus hitting <kbd>Enter</kbd> all the time\n\nIt would also be nice to improve the CLI itself to accept various options, rather than generating the same-size grid and player starting-position every time.\n\nOh yeah and, y'know, make it into like an actual game with winning and losing conditions?\nEh, maybe.\n\n### Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[project]\nname = \"2026-02-01-tyle\"\nversion = \"0.1.0\"\nrequires-python = \">=3.12\"\ndependencies = []\n```\n:::\n:::\n\n</details>\n\n[^take]: Wow, a take that's hotter than the sun.\n[^shot]: Take a shot every time you read that phrase on this blog.\n[^frivolity]: I wouldn't dream of taking the cutting edge and [being frivolous with it](https://www.rostrum.blog/posts/2023-02-26-nook-s7/).\n[^tool]: And `uv tool update tyle` and `uv tool uninstall tyle` do what you think they do.\n[^awards]: Pfft, game awards? More like _shame awards_ in comparison to this, amirite?\n[^ty]: [Astral](https://astral.sh/) have brought ty out of version beta_BETA_draft_v0.0.0.0.0.900000, huzzah. You can check type hints cheaply [with uv](https://docs.astral.sh/uv/guides/tools/) and without installing anything else, like `uvx ty check`. Or `uvx ruff format` and `uv ruff check` for linting and formatting. Real noice.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "4c81f7ef217db0815315185e97dbe66e",
  "result": {
    "markdown": "---\ntitle: Graphing the Relayverse of podcasts\ndate: 2019-02-14\nslug: relayverse\ncategories:\n  - dataviz\n  - ggraph\n  - r\n  - rvest\n  - tidygraph\n  - visNetwork\nresources:\n  - resources/relayverse.html\n---\n\n::: {.cell}\n\n:::\n\n\n![The Relay FM podcast network, visualised. [View it here](https://www.rostrum.blog/output/relayverse.html).](resources/relayverse.gif){fig-alt=\"A gif of the graph network for Relay FM, showing the ability to zoom and select nodes with the visNetwork package\" width=\"100%\"}\n\n## tl;dr \n\nI made an interactive [graph network](https://en.wikipedia.org/wiki/Network_theory) of the podcast host relationships on [Relay FM](https://www.relay.fm) using R. [You can interact with it in a separate window](https://www.rostrum.blog/output/relayverse.html) and find out below how it was made.\n\n## Podcast networks\n\nPodcasting is becoming big business. Music-streaming giant Spotify just acquired the podcast network [Gimlet](https://www.gimletmedia.com/) for [a reported $200 million](https://www.recode.net/2019/2/1/18207198/spotify-gimlet-podcast-acquisition).\n\nOther networks include [The Incomparable](https://www.theincomparable.com/), [5by5](http://5by5.tv/) and [Radiotopia](https://www.radiotopia.fm/). Such networks can boost revenue and listener numbers and provide access to expertise, management and resources. \n\n[Relay FM](https://www.relay.fm) is a network that focuses largely on tech content[^relay]. It was started by Myke Hurley and Stephen Hackett in 2014 and you can find a list of [shows](https://www.relay.fm/shows) and [personnel](https://www.relay.fm/people) on their site. Many of Relay FM's hosts have hosted more than one podcast within the network. What do the relationships between them look like?\n\nThis post is about preparing and visualising this 'Relayverse' using the R packages [{tidygraph}for network data handling](https://www.data-imaginist.com/2017/introducing-tidygraph/) and [{ggraph} for network visualisation](https://www.ggplot2-exts.org/ggraph.html) (both by [Thomas Lin Pedersen](https://twitter.com/thomasp85)), along with [the {visNetwork} package](https://cran.r-project.org/web/packages/visNetwork/vignettes/Introduction-to-visNetwork.html).\n\nScroll to the bottom to find the interactive tool if you aren't interested in the code.\n\n## Packages\n\nI'm using two suites of 'tidy' packages in this post: one set for data collection and manipulation, and one set for graph network building, analysis and visualisation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages({\n  \n  # Data collection and manipulation\n  library(dplyr)  # data manipulation\n  library(rvest)  # for scraping webpages\n  library(stringr)  # string manipulation\n  library(tidyr)  # tidying dataframes\n  library(purrr)  # applying functions over data\n  \n  # Graph networks\n  library(tidygraph)  # set up graph network\n  library(ggraph)  # visualise static graphs\n  library(cowplot)  # for plot arrangement\n  library(visNetwork)  # wrapper for javascript interactive viz\n  \n})\n```\n:::\n\n\n## Harvest data\n\nWe can use [the {rvest} package](https://blog.rstudio.com/2014/11/24/rvest-easy-web-scraping-with-r/) to scrape podcast details from [the Wikipedia page for Relay FM](https://en.wikipedia.org/wiki/Relay_FM). There are two separate tables: one for current and one for retired (discontinued) shows. \n\n![One of the target Wikipedia tables of current Relay FM shows](resources/relay-wikipedia.png){fig-alt=\"A screenshot of a table on Wikipedia containing data about podcast shows from Relay FM\" width=\"100%\"}\n\n`read_html()` gets the HTML for the selected page; `html_node()` identifies which element needs to be scraped[^xpath]; and `html_table()` interprets the HTML information as a data frame. I've removed the show 'B-Sides' because it's clips from other shows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the HTML for the selected page\nrelay_wiki <- read_html(\"https://en.wikipedia.org/wiki/Relay_FM\")\n\n# Get the table with current shows\ncurrent <- relay_wiki %>%\n  html_node(xpath = '//*[@id=\"mw-content-text\"]/div/table[2]') %>%\n  html_table() %>%\n  filter(\n    !Podcast %in% c(\"Members Only\", 'Paid \"Members Only\" Shows', \"B-Sides\")\n  ) %>%\n  mutate(Status = \"Current\")  # label rows as current shows\n\n# Get the table with retired shows\nretired <- relay_wiki %>%\n  html_node(xpath = '//*[@id=\"mw-content-text\"]/div/table[3]') %>%\n  html_table() %>%\n  select(-`Number of episodes`) %>%\n  mutate(Status = \"Retired\")  # label rows as retired shows\n\n# Combine the tables into one dataframe\nshows <- bind_rows(current, retired)\n\n# Look at a few random hosts/podcasts from the table\nselect(shows, Podcast, Hosts) %>%\n  sample_n(5) %>% knitr::kable()\n```\n:::\n\n\n|Podcast | Hosts|\n| :------ | :------ |\n|Virtual | Federico ViticciMyke Hurley|\n|Free Agents | Jason SnellDavid Sparks|\n|Bionic | Myke HurleyMatt Alexander|\n|Less Than or Equal | Aleen Simms|\n|Canvas | Federico ViticciFraser Spiers|\n\nUnfortunately the host names are in the form 'First LastFirst Last' so we need a regular expression to split the string where a lowercase letter meets an uppercase letter[^regex]. This leaves us with a list column that we can `unnest()` to get one row per podcast-host combination.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Clean the host names\nshows_clean <- shows %>%\n  mutate(\n    Hosts = str_remove_all(Hosts, \"formerly hosted by.*$\"),  # remove text and former hosts\n    Hosts = str_remove_all(Hosts, \" \\\\(originally\\\\)\"),  # remove '(originally)' text\n    Hosts = str_remove_all(Hosts, \"\\\\[[:digit:]\\\\]\"),  # remove Wikipedia references\n    Hosts = str_split(Hosts, \"(?<=[a-z])(?=[A-Z])\") # split where lowercase meets uppercase\n  ) %>%\n  filter(Hosts != \"Maddy Myers\") %>%  # hack to remove a former host\n  unnest() %>% \n  select(Podcast, Hosts, Status)\n\n# Print a random sample of 10\nsample_n(shows_clean, 10) %>% knitr::kable()\n```\n:::\n\n\n| Podcast | Hosts | Status |\n| :------ | :------ | :------ |\n| Connected | Myke Hurley | Current |\n| Mixed Feelings | Gillian Parker | Current |\n| BONANZA | Matt Alexander | Current |\n| Remaster | Myke Hurley | Current |\n| Isometric | Steve Lubitz | Retired |\n| The Prompt | Stephen M. Hackett | Retired |\n| Presentable | Jeff Veen | Current |\n| Remaster | Shahid Kamal Ahmad | Current |\n| Remaster | Federico Viticci | Current |\n| Liftoff | Stephen M. Hackett | Current |\n\n\nNotice there were a couple of cleaning steps there to remove the text 'formerly hosted by' and the names of the former hosts. There's one instance where this protocol isn't followed in the table and the host's name is followed by '(originally)'. I removed the text with regex, but then just removed the host's name manually with a `filter()` to avoid some complex regex.\n\nOur data frame is now tidy and ready for Tidygraph, but before moving on, we can do things like look at the host with the most active shows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshows_clean %>% \n  filter(Status == \"Current\") %>% \n  count(Hosts) %>%\n  filter(n > 2) %>% \n  arrange(desc(n)) %>% \n  knitr::kable()\n```\n:::\n\n\n| Hosts | n |\n| :------ | -----: |\n| Myke Hurley | 10 |\n| Stephen M. Hackett | 6 |\n| David Sparks | 3 |\n| Jason Snell | 3 |\n| Mikah Sargent | 3 |\n| Tiffany Arment | 3 |\n\nOr out of interest, the shows that have had the most hosts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshows_clean %>% \n  count(Podcast) %>%\n  arrange(desc(n)) %>% \n  slice(1:6) %>% \n  knitr::kable()\n```\n:::\n\n\n| Podcast | n |\n| :------ | ------: |\n| Isometric | 5 |\n| Disruption | 4 |\n| Connected | 3 |\n| Remaster | 3 |\n| Rocket | 3 |\n| The Prompt | 3 |\n\n## Tidygraph\n\nThe [tidygraph package](https://www.data-imaginist.com/2017/introducing-tidygraph/) was created by [Thomas Lin Pedersen](https://twitter.com/thomasp85). It is:\n\n>an entry into [the tidyverse](https://www.tidyverse.org/) that provides a tidy framework for all things relational (networks/graphs, trees, etc)\n\nTo use the package, we need every host combination[^combo] for each podcast, which can be achieved with the `combn()` function. This gives us a pair of points ('nodes' in graph-speak) that can be connected by a line (an 'edge') to indicate their relationship.\n\nBut a show with one host doesn't have a pair of points, so I'm going to duplicate these rows first. If we don't do this, we can't plot these shows because they won't have a connection between two nodes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Isolate the shows with one host \nsolo_vec <- shows_clean %>%\n  count(Podcast) %>%\n  filter(n == 1) %>%\n  pull(Podcast)\n\n# Filter the show-host dataframe by solo-hosted podcasts\nsolo_df <- filter(shows_clean, Podcast %in% solo_vec)\n```\n:::\n\n\nNow we can bind these rows to the data and then get our host combinations. Big shout out to [William Chase](https://www.williamrchase.com/post/finding-combinations-in-the-tidyverse/) for a solution to getting all combinations of elements within some parent element (e.g. hosts within podcasts).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prepare host combinations per show\nrelay_combos <- shows_clean %>%\n  bind_rows(solo_df) %>%  # to duplicate the shows with solo hosts\n  group_by(Podcast) %>%  # operate within each podcast\n  split(.$Podcast) %>%  # split on podcast\n  map(., 2) %>%  # gets vector of hosts per podcast list element\n  map(~combn(.x, m = 2)) %>%   # all pair combiantions\n  map(~t(.x)) %>%  # transpose the matrix\n  map(as_tibble) %>%  # convert to a tibble dataframe\n  bind_rows(.id = \"Podcast\") %>%  # list-element name to column\n  select(V1, V2, Podcast)\n\nsample_n(relay_combos, 10) %>% knitr::kable()  # random sample of 10\n```\n:::\n\n\n| V1 | V2 | Podcast |\n| :------ | :------ |\n| Myke Hurley | Tom Gerhardt | Thoroughly Considered |\n| David Sparks | Rose Orchard | Automators |\n| Federico Viticci | Fraser Spiers | Canvas |\n| Christina Warren | Simone de Rochefort | Rocket |\n| Alex Cox | Savannah Million | Roboism |\n| Andy Ihnatko | Florence Ion | Material |\n| Stephen M. Hackett | Myke Hurley | Ungeniused |\n| Jason Snell | Stephen M. Hackett | Liftoff |\n| K Tempest Bradford | Aleen Simms | Originality |\n| Myke Hurley | Stephen M. Hackett | The Prompt |\n\nWe can turn this data frame of host-pair combinations into a tidygraph object with the `as_tbl_graph()` function. This class of object contains two data frames (the nodes and the edges) and some metadata.\n\nWe can also use functions from the {tidygraph}package to help calculate various network statistics. For example, the `centrality_degree()` function tells us the nodes with the most connections. We can add this as a column in our node data and use this later to do things like resize nodes depending on their centrality.\n\nYou can manipulate the nodes and edges data frames in this tidygraph object by using the `activate()` function to switch between them. Currently the node data are active (it says 'active' above the nodes data frame), so our application of `centrality_degree()` to the network object will affect the node data specifically.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrelay_graph <- as_tbl_graph(relay_combos, directed = FALSE)%>% \n  mutate(connections = centrality_degree()) %>%  # number of connections\n  arrange(desc(connections))  # order by number of shows\n\nprint(relay_graph)  \n```\n:::\n\n```\n# A tbl_graph: 38 nodes and 64 edges\n#\n# An undirected multigraph with 8 components\n#\n# Node Data: 38 x 2 (active)\n  name               connections\n  <chr>                    <dbl>\n1 Myke Hurley                 21\n2 Stephen M. Hackett          11\n3 Brianna Wu                   9\n4 Mikah Sargent                9\n5 Federico Viticci             8\n6 Georgia Dow                  7\n# … with 32 more rows\n#\n# Edge Data: 64 x 3\n   from    to Podcast   \n  <int> <int> <chr>     \n1    10    10 Almanac   \n2     1    30 Analog(ue)\n3    11    31 Automators\n# … with 61 more rows\n```\n\nThe edges and nodes are now in the same object. You can see we have about 38 nodes and 64 edges and that the network is undirected (nodes don't 'point' to each other). We also have eight 'components', which are the isolated groups of nodes that connect to each other, but not to other groups.\n\n## Visualisation\n\n### Static with {ggraph}\n\n[The {ggraph} package](https://www.ggplot2-exts.org/ggraph.html) was designed to work seamlessly with {tidygraph}objects and the {ggplot2} plotting package. You simply pass your {tidygraph}object to {ggraph}'s 'graph' argument. Below are a couple of examples for demonstration purposes that show you just a handful of options. You can learn more about {ggraph}'s [layouts](https://www.data-imaginist.com/2017/ggraph-introduction-layouts/), [nodes](https://www.data-imaginist.com/2017/ggraph-introduction-nodes/) and [edges](https://www.data-imaginist.com/2017/ggraph-introduction-edges/) in a series of blog posts from Thomas Lin Pedersen. \nThis example arranges the nodes (hosts) circularly (plot A) and a straight line (B) and sizes them by the number of connections to other hosts. Each line (edge) represents a co-hosting relationship.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng1 <- ggraph(\n  graph = relay_graph,\n  layout = \"linear\",\n  circular = TRUE\n) +\n  geom_node_point(aes(size = connections)) +\n  geom_edge_arc() +\n  theme_void() +\n  theme(legend.position = \"none\")\n\ng2 <- ggraph(\n  graph = relay_graph,\n  layout = \"linear\"\n) +\n  geom_node_point(aes(size = connections)) +\n  geom_edge_arc() +\n  theme_void() +\n  theme(legend.position = \"none\")\n\nplot_grid(g1, g2, labels = c(\"A\", \"B\"))\n```\n:::\n\n\n![](resources/ggraph-arc-1.png){fig-alt=\"Two network graphs of the same data. One is labelled 'A' and is arranged with nodes around the edge of a circle. The other, labelled 'B' has nodes arranged along a line with arcs joining them. Most nodes have only one connection, up to about 20\" width=\"100%\"}\n\nThis example arranges the nodes (hosts) according to an algorithm specified by the `layout` argument to `ggraph()` and sizes them by the number of connections to other hosts. Each line (edge) represents a co-hosting relationship and multiple connections are shown separately by 'fanning' them out (hence the `geom_edge_fan()`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(graph = relay_graph, layout = \"nicely\") + \n  geom_node_point(aes(size = connections)) +\n  geom_edge_fan() +\n  theme_void() +\n  theme(legend.position = \"none\")\n```\n:::\n\n\n![](resources/ggraph-fan-1.png){fig-alt=\"A network graph. There's one interconnected group with over 20 nodes, 5 isolated pairs and two isolated singletons.\" width=\"100%\"}\n\nI haven't added labels on the nodes nor the points because of the visual clutter it creates for this particular example. You could use `geom_node_text()` to add node labels and something like `aes(label = <column_name>)` in your edge geom to label the connections.\n\nThis is where interactive network graphs come in handy, as you can zoom, pan and hover to get more info.\n\n### Interactive with {visNetwork}\n\n[The {visNetwork} package](https://datastorm-open.github.io/visNetwork/) wraps [the `vis.js` library](http://visjs.org) to make interactive network graphs. Its `visNetwork()` function takes separate data frames of edges and nodes that are in [a pre-specified format](https://datastorm-open.github.io/visNetwork/nodes.html), so we won't be able to use our tidygraph object for this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Dataframe of unique nodes with an ID value\nnodes <- shows_clean %>%  # take our podcast-host dataset\n  distinct(Hosts) %>%  # get column of unique hosts\n  arrange(Hosts) %>%  # alphabetical order\n  mutate(id = as.character(row_number()), label = Hosts) %>% \n  select(-Hosts) #%>%  # provides pop up value on viz\n\n# Dataframe of 'origin' and 'destination' nodes for edge drawing\nedges <- relay_combos %>% \n  left_join(nodes, by = c(\"V1\" = \"label\")) %>% \n  left_join(nodes, by = c(\"V2\" = \"label\")) %>%\n  rename(from = id.x, to = id.y, title = Podcast)\n```\n:::\n\n\nNow we plug the data into the `visNetwork()` function and pipe this into some other other functions to set some options. It's quite a lot of code, but the piping into other `vis*()` functions breaks it up into more manageable chunks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvisNetwork(  # add main features\n  nodes, edges,  # add node and edge data\n  main = list(  # set main title and style it\n    text = \"The Relayverse\",\n    style = \"font-family:Lekton, monospace;font-weight:bold;font-size:30px;text-align:center;\"\n  ),\n  submain = list(  # set subtitle and style it\n    text = \"Click hosts (nodes) to see co-host relationships (edges)\",\n    style = \"font-family:Lekton, monospace;font-weight:regular;font-size:20px;text-align:center;\"\n  ),\n  footer = list(  # add a footer and style it\n    text = paste0(\"Source: Wikipedia (\", format(Sys.Date(), \"%Y/%m/%d\"), \")\"),\n    style = \"font-family:Lekton, monospace;font-weight:regular;font-size:15px;text-align:right;\"\n  )\n) %>% \n  visNodes(  # node styling\n    shape = \"icon\",  # node is an icon specified below \n    icon = list(code = \"f130\", size = 75, color = \"#000000\"),  # microphone icon\n    font = list(face = \"Lekton\", size = 20)\n  ) %>% \n  visEdges(  # edge styling\n    color = list(color = \"#447d9b\", highlight = \"#c83c3c\", opacity = 0.5),\n    width = 3, selectionWidth = 5  # selected edge is thicker\n  ) %>% \n  visOptions(  # general graph options\n    highlightNearest = TRUE,  # on-hover highlight nearest nodes\n    nodesIdSelection = TRUE  # select node from dropdown\n  ) %>%\n  visPhysics(  # set physics 'engine' and options\n    solver = \"forceAtlas2Based\", \n    forceAtlas2Based = list(gravitationalConstant = -50)\n  ) %>%\n  visLayout(randomSeed = 1337) %>%  # reproduce the same network each time\n  visInteraction(navigationButtons = TRUE) %>%  # add naviagation buttons\n  addFontAwesome()  # makes sure that FontAwesome dependency is in place\n```\n:::\n\n\nAnd that outputs the graph below. You can:\n\n* use the navigation buttons or your trackpad/mouse to navigate the network\n* click a node to highlight a host and their co-hosts (single hosts loop back to themselves)\n* hover over an edge to show a label with the show name\n* select a host from the dropdown menu to highlight them and their co-hosts\n* click and drag a node to move it\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div class=\"shareagain\" style=\"min-width:300px;margin:1em auto;\" data-exeternal=\"1\">\n<iframe src=\"resources/relayverse.html\" width=\"345\" height=\"300\" style=\"border:2px solid currentColor;\" loading=\"lazy\" allowfullscreen></iframe>\n<script>fitvids('.shareagain', {players: 'iframe'});</script>\n</div>\n```\n:::\n:::\n\n\nYou can also [view the network in its own window](resources/relayverse.html).\n\nThis is a very simple example, but [lots of other {visNetwork} options are available](https://datastorm-open.github.io/visNetwork/). \n\n## What now?\n\nThis was really just an introduction to {tidygraph}, {ggraph} and {visNetwork}. These packages make network analysis a little more consistent and can provide some interesting stats and visuals very quickly. A next step might be to produce a 'network of podcast networks', since Relay FM hosts appear in shows on other networks as well.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-08-14 08:53:33 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2   compiler_4.3.1      fastmap_1.1.1      \n [4] cli_3.6.1           tools_4.3.1         htmltools_0.5.5    \n [7] xaringanExtra_0.7.0 rstudioapi_0.15.0   yaml_2.3.7         \n[10] rmarkdown_2.23      knitr_1.43.1        jsonlite_1.8.7     \n[13] xfun_0.39           digest_0.6.33       rlang_1.1.1        \n[16] evaluate_0.21      \n```\n:::\n:::\n\n</details>\n\n[^relay]: Some personal favourites: [Analogue](https://www.relay.fm/analogue), [Cortex](https://www.relay.fm/cortex), [Playing For Fun](https://www.relay.fm/playingforfun), [Reconcilable Differences](https://www.relay.fm/rd), [Top Four](https://www.relay.fm/topfour) and [Connected](https://www.relay.fm/connected).\n[^xpath]: [Try SelectorGadget](https://cran.r-project.org/web/packages/rvest/vignettes/selectorgadget.html) or your [your browser's 'Inspect' tool](http://blog.corynissen.com/2015/01/using-rvest-to-scrape-html-table.html) to help isolate the xpath of the element of interest.\n[^regex]: The regex `(?<=[a-z])(?=[A-Z])` can be interpreted as 'split after but not including (`?<=`) a lowercase letter (`[a-z]`), and before but not including (`?=`) a capital letter (`[A-Z]`)'.\n[^combo]: We want _combinations_, not _permutations_. 'Federico Viticci to Stephen M. Hackett' is the same as 'Stephen M. Hackett to Federico Viticci', for example.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/fitvids-2.1.1/fitvids.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
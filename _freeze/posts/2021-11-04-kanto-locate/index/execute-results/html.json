{
  "hash": "a04cbaa4a7c130113f0a477e8ee8d591",
  "result": {
    "markdown": "---\ntitle: Get coordinates from fictitious maps\ndate: 2021-11-04\nslug: kanto-locator\ncategories:\n  - locator\n  - map\n  - r\n  - videogames\n---\n\n\n\n\n![](resources/kanto-closeup.png){fig-alt=\"Three red points on a map labelled with names from the original Pokemon game for GameBoy: Celadon City, Saffron City and Lavender Town. Light grey lines connect the points and to other points offscreen. \" width=\"100%\"}\n\n## tl;dr\n\nUse the `locator()` function in R to interactively extract arbitrary coordinates from images of imaginary maps. I extracted points of interest from Kanto in the original _Pokémon_ games.\n\n## On the road to Viridian City\n\nThere are lots of interesting fictitious maps. For example, Middle Earth from _Lord of the Rings_, Hyrule from _The Legend of Zelda_ and Sodor from _Thomas the Tank Engine_.\n\nThis is excellent fodder for fan-made recreations. I've thought before about how I would do this programmatically, but there's one particularly awkward thing: how can you grab location coordinates from an image of your chosen map?\n\nThis post outlines a pretty low-effort method for doing this in R. Basically there's two steps: (1) read and plot an image of a map and (2) click locations interactively to record their coordinates. I'm going to do this with a Pokémon example for simplicity, but also because have you ever visited this blog before?\n\n## Get map\n\nFor my own convenience, I've written a function that downloads a PNG of a map from the web and plots it. This requires {png} and {grid} packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_map <- function(png_path) {\n  \n  # Return to user's par settings once done\n  original_par <- par()[\"mar\"]\n  on.exit(par(original_par))\n  \n  # Download and read image\n  tmp <- tempfile(fileext = \".png\")\n  download.file(png_path, tmp, quiet = TRUE)\n  img <- png::readPNG(tmp)\n  unlink(tmp)  # clean up\n  \n  # Set up canvas and plot\n  par(mar = rep(0, 4))  # remove margins\n  plot.new()  # start new plot frame\n  grid::grid.raster(img, x = 0.5, y = 0.5)\n  \n}\n```\n:::\n\n\nTo be specific, I'm using the in-game 'town map' of the fictitious Kanto region from the first generation of [_Pokémon Red_ and _Blue_](https://en.wikipedia.org/wiki/Pok%C3%A9mon_Red_and_Blue) for the Nintendo GameBoy,[^safar6] [downloaded from Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Main_Page). This is good for a demo: the locations are pretty discrete, obvious and clickable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkanto_path <- \n  \"https://cdn2.bulbagarden.net/upload/8/86/Kanto_Town_Map_RBY.png\"\n\nplot_map(kanto_path)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-kanto-1.png){fig-alt='The simple, blocky Kanto town map from the original Pokemon game. Squares represent cities, circles are other points of interest, and there are routes connecting them. The location shows both land and sea.' width=672}\n:::\n:::\n\n\nYou might be thinking that it looks like a schematic map---an abstraction of actual geography---like the London underground map. In fact, the town map is pretty similar to the actual in-game world layout, as demonstrated by folks who have [stitched together all the overworld screens](https://www.reddit.com/r/pokemon/comments/lpttq8/put_together_all_the_images_to_create_a_gen_i/).\n\n## Get points\n\nWith the Kanto map drawn in our active plot window, we can run a function to prompt the user to click on points and record their coordinates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocate_points <- function(places) {\n  \n  places_list <- vector(\"list\", length(places)) |> \n    setNames(places)\n  \n  for (i in places) {\n    cat(paste0(\"Click on \", i, \"... \"))\n    places_list[[i]] <- locator(1, type = \"p\")\n    cat(\"found.\\n\")\n  }\n  \n  places_df <- do.call(rbind, places_list) |>\n    data.frame()\n  \n}\n```\n:::\n\n\nThis is not magic. It is merely powered by the `locator()` function, which records the x and y location of a point clicked on a plot by the user.[^useless] \n\nHere's a simplified version of what's going on when you use `locator()`. If you make a plot and call the function, then the top of the plotting window in RStudio says 'locator active' and your cursor becomes crosshairs. Clicking on the plot returns a list of the x and y coordinates within the plotting space. The first argument is the number of clicks to collect before the locator is deactivated automatically.\n\n![](resources/locator.gif){fig-alt=\"R code is run in RStudio to produce a simple plot with one point in the centre. After running the locator function, the user clicks the point on the plot and the console prints a list with the x and y coordinate values for that point.\" width=\"100%\"}\n\nFor our bespoke `locate_points()` function, we can pass a character vector of place names. For this demo, that'll be Kanto's towns, cities and other places of interest. The function loops through the locations and requests you to click the corresponding point on the map. The console will read like `Click on Pallet Town...` and then `found` once you've clicked it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkanto_names <- c(\n  \"Pallet Town\", \"Viridian City\", \"Viridian Forest\", \"Pewter City\", \n  \"Mt Moon\", \"Cerulean City\", \"Rock Tunnel\", \"Vermilion City\", \n  \"Lavender Town\", \"Celadon City\", \"Fuchsia City\", \"Saffron City\", \n  \"Seafoam Islands\", \"Cinnabar Island\", \"Victory Road\",\n  \"Indigo Plateau\"\n)\n\nkanto_pts <- locate_points(kanto_names)  # initiates clicking prompts\n```\n:::\n\n```\nClick on Pallet Town...\n```\n\nDuring the clickfest, the `locate_points()` function has assembled the points lists into a data.frame with one row per location. The locations vector was passed as the rownames of the dataframe as well. Here's the full list of collected coordindates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkanto_pts\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                        x          y\nPallet Town     0.2470187 0.30648777\nViridian City   0.2451179 0.50103940\nViridian Forest 0.2451179 0.75868886\nPewter City     0.2470187 0.81652853\nMt Moon         0.4275933 0.88225543\nCerulean City   0.6100688 0.87962636\nRock Tunnel     0.7944450 0.81915761\nVermilion City  0.6100688 0.43794158\nLavender Town   0.7963458 0.69296196\nCeladon City    0.4751130 0.69296196\nFuchsia City    0.5207318 0.18292120\nSaffron City    0.6100688 0.69559103\nSeafoam Islands 0.3838752 0.05672554\nCinnabar Island 0.2451179 0.05672554\nVictory Road    0.1538802 0.75343071\nIndigo Plateau  0.1519794 0.87962636\n```\n:::\n:::\n\n\nThe coordinate values are between 0 to 1 because those are the default x- and y-axis limits that were set up in `plot_map()`. They're remarkably precise, but the resolution on the image wasn't great and my hand-eye coordination is bad, so take these with a grain of salt.\n\n## Plot\n\nSo! You can now plot the coordinates independently. To demonstrate, I've plotted the points and added a label whose style is dependent on the type of location. I've added lines to join the locations in the order they appear in a normal playthrough.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkanto_pts$city <- ifelse(\n  grepl(\"Town|City|Island$\", rownames(kanto_pts)), \n  TRUE, FALSE\n)\n\npar(mar = rep(0, 4))\nwith(kanto_pts, plot(x, y, axes = FALSE))\nwith(kanto_pts, lines(x, y, col = \"grey95\", lwd = 5))\n\npoints(\n  kanto_pts$x, kanto_pts$y,\n  pch = 16,\n  cex = ifelse(kanto_pts$city, 2, 1),\n  col = ifelse(kanto_pts$city, \"red\", \"blue\")\n)\n\ntext(\n  kanto_pts$x, kanto_pts$y,\n  gsub(\" \", \"\\n\", row.names(kanto_pts)),\n  cex = ifelse(kanto_pts$city, 0.7, 0.4),\n  pos = c(1, 1, 1, 4, 1, 1, 2, 1, 2, 1, 1, 1, 3, 3, 1, 1),\n  family = \"Press Start 2P\"  # installed locally from Google Fonts\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-cities-1.png){fig-alt='A map where the labelled points are cities from the original Pokemon videogame. Cities are red points with larger text. Non-cities are smaller and blue. A light grey line connects the cities to show the path of travel.' width=672}\n:::\n:::\n\n\nIt might also be fun to do a minimal map of the cities where the points are coloured according to the name of the city. You may have noticed that the city names are all fancy colour names (viridian, fuchsia, etc), so let's use them. Well, except Pallet, for which can just use a mix of all colours, i.e. white.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkanto_colour <- \n  kanto_pts[kanto_pts$city | \n              rownames(kanto_pts) == \"Indigo Plateau\", ]\n\nkanto_colour$city_col <- c(  # close-enough named R colours\n  \"white\", \"aquamarine4\", \"grey57\", \"royalblue3 \",\n  \"red3 \", \"lavender\", \"darkseagreen2\", \"magenta\",\n  \"tomato2\", \"orangered2\", \"blue\"\n) \npar(mar = rep(0, 4))\nwith(kanto_colour, plot(x, y, axes = FALSE))\nwith(kanto_colour, points(x, y, pch = 22, cex = 4, bg = city_col))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-colors-1.png){fig-alt='A minimal plot showing an arrangement of coloured squares that represent the cities from the town map of the original Pokemon game. The squares are coloured to match the town names, so Cerulean City is blue.' width=672}\n:::\n:::\n\n\nI'll admit I struggled to make this given my colourblindness, but also because I had no prior notions of what colours like 'vermilion' and 'celadon' are. Actually they kind of sound more like Pokémon names.\n\nAnyway, these 'maps' are the first steps to create something more exciting. For now they demonstrate the point (literally, lol). Plus they fulfil my belated submission for day one of [the #30DayMapChallenge](https://github.com/tjukanovt/30DayMapChallenge) ('points').\n\n## Distances\n\nBut wait, there's more.\n\nSo, obviously, why not work out the distances between towns? Not in arbitrary units, but in actual metres. There's a few ways we could do this, but basically I'm going to peg a pixel to a known length.[^irlkanto]\n\nFirst, we can create a lookup table of the straight-line 'distances' between locations, given our arbitrary 0 to 1 dimensions. We want to avoid being precise with these values (they're only as good as my ability to click a tiny square on a computer screen), so I'm multiplying and rounding them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkanto_dist <- raster::pointDistance(\n  kanto_pts[, c(\"x\", \"y\")],\n  lonlat = FALSE\n) |>\n  as.data.frame() |>\n  round(2) * 100\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nThe legacy packages maptools, rgdal, and rgeos, underpinning the sp package,\nwhich was just loaded, will retire in October 2023.\nPlease refer to R-spatial evolution reports for details, especially\nhttps://r-spatial.org/r/2023/05/15/evolution4.html.\nIt may be desirable to make the sf package available;\npackage maintainers should consider adding sf to Suggests:.\nThe sp package is now running under evolution status 2\n     (status 2 uses the sf package in place of rgdal)\n```\n:::\n\n```{.r .cell-code}\nnames(kanto_dist) <- kanto_names\nrownames(kanto_dist) <- kanto_names\n\nkanto_dist[1:3, 1:3]  # first few\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                Pallet Town Viridian City Viridian Forest\nPallet Town               0            19              45\nViridian City            19             0              26\nViridian Forest          45            26               0\n```\n:::\n:::\n\n\nThese values are the number of arbitrary distance units between pairs of locations, which are given by the row and column headers. So, Pallet Town to Viridian City is 19 arbitrary units.\n\nBased on my own measurements, the centre of Pallet to the centre of Viridian is 64 in-game 'blocks', where a block is a 16- by 16-pixel square.[^scale] \n\nIt just so happens that [the player-character sprite fills a single block](https://www.spriters-resource.com/fullview/63033/)[^sprite] and we know that the character is probably [about 140 cm tall](https://bulbapedia.bulbagarden.net/wiki/Ash_Ketchum).[^height]\n\nThat means Pallet to Viridian is about 64 * 140 cm = 8960 cm. So, one of our arbitrary units equals 8960 cm / 19 = 472 cm. Now we can correct our distance lookup.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkanto_dist_m <- round(kanto_dist * 472 / 100)\nkanto_dist_m[1:3, 1:3]  # first few\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                Pallet Town Viridian City Viridian Forest\nPallet Town               0            90             212\nViridian City            90             0             123\nViridian Forest         212           123               0\n```\n:::\n:::\n\n\nOnce again I've removed some precision by calculating the result as a rounded distance in metres. Coward.\n\n![](resources/distance.jpg){fig-alt=\"Diagram to show how the known height in pixels of a character sprite from the original Pokemon videogame can be used to ascertain the 'real world' distance between twoo in-game towns, Pallet and Viridian, based on their known distance in pixels. A block is about 16 pixels, which is 140 cm. There are 64 blocks between the two towns, so this is about 90 m.\" width=\"100%\"}\n\nSo this means we can now say some really profound things like it's about 90 m from Pallet Town to Viridian City. Maybe that's true in the context of the game's dimensions, but it's... underwhelming. \n\nWas this scuffed distance-conversion exercise worthwhile? No. \n\nBut it might strengthen my belated submission to day two of [the #30DayMapChallenge](https://github.com/tjukanovt/30DayMapChallenge) ('lines')?\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-07-17 18:26:56 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.31     codetools_0.2-19  fastmap_1.1.1     xfun_0.39        \n [5] lattice_0.21-8    knitr_1.43.1      raster_3.6-20     htmltools_0.5.5  \n [9] png_0.1-8         rmarkdown_2.23    cli_3.6.1         terra_1.7-39     \n[13] grid_4.3.1        compiler_4.3.1    rstudioapi_0.15.0 tools_4.3.1      \n[17] sp_2.0-0          evaluate_0.21     Rcpp_1.0.11       yaml_2.3.7       \n[21] rlang_1.1.1       jsonlite_1.8.7    htmlwidgets_1.6.2\n```\n:::\n:::\n\n</details>\n\n[^irlkanto]: As it happens, in-game Kanto is based on [the real-life Kanto region of Japan](https://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_world_in_relation_to_the_real_world#Kanto). That means another approach might be to measure approximate distances by overlaying the in-game map over real-life Japan.\n[^scale]: Of course, the relative in-game scales are a bit weird. For example, some single-storey houses are only twice the height of the player. It also implies the whole of Kanto is only a few kilometres wide. But, y'know, it's a retro videogame, so. \n[^height]: 4 feet 7 inches, if you prefer. This does seems quite short, although he is meant to be 10 years old.\n[^useless]: I was thinking about this function recently because I remember being taught to use it to help place labels on a plot. Then I saw it appeared [in Tomaz's post for creating interactive, self-updating Voronoi maps](https://tomaztsql.wordpress.com/2021/11/01/little-useless-useful-r-functions-interactive-voronoi-diagram-generator-using-r-and-x11/) and I took it as a sign to make something with it too.\n[^safar6]: Yes: [I recreated the 'Safari Zone' from this game as a playable text adventure in R](https://www.rostrum.blog/2021/01/04/safar6/) and even threw in [an RStudio theme](https://github.com/matt-dray/gamelad) to mimic the original puke-green GameBoy screen.\n[^sprite]: You can [make little animated sprites in R](https://www.rostrum.blog/2021/06/28/pixel-art/), don't you know?\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
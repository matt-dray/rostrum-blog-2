{
  "hash": "5732a4be2d325f1e46b3f18f8b7a5f20",
  "result": {
    "markdown": "---\ntitle: R has obscenely long function names\ndate: 2021-11-27\nslug: long-fns\ncategories:\n  - base\n  - pacman\n  - r\n  - tidyverse\n---\n\n\n![](resources/longboi.png){fig-alt=\"A crudely-drawn long dog with the R function name aspell_write_personal_dictionary_file written along the length of its body.\" width=\"100%\"}\n\n## tl;dr\n\nUse `ls()` on a package name in the form `\"package:base\"` to see all the objects it contains. I've done this to find the longest (and shortest) function names in base R and the {tidyverse} suite.\n\n## Naming things\n\nI try to keep to a few rules when creating function names, like:\n\n* use a verb to make clear the intended action, like [`get_badge()` from {badgr}](https://matt-dray.github.io/badgr/reference/get_badge.html)\n* start functions with a prefix to make autocomplete easier, like the [`dh_*()` functions from {dehex}](https://matt-dray.github.io/dehex/reference/index.html)\n* try to be descriptive but succinct, like [`r2cron()` from {dialga}](https://matt-dray.github.io/dialga/reference/r2cron.html)\n\nIt can be tricky to be succinct. Consider the base R function `suppressPackageStartupMessages()`[^suppress]: it's a whopping 30 characters, but all the words are important. Something shortened, like `suppPkgStartMsg()`, wouldn't be so clear.\n\nIt [made me wonder](https://www.rostrum.blog/2021/08/27/zzz/#fn1): what's the longest function name in R?[^luke]\n\nBut! It seems tricky and time consuming to find the longest function name from _all_ R packages. CRAN alone has over 18,000 at time of writing.\n\nA much easier (lazier) approach is to focus on some package subsets. I'll look at base R and the {tidyverse}.\n\n## The long and the short of it\n\n### Base R\n\nCertain R packages are built-in and attached by default on startup.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_names <- sessionInfo()$basePkgs\nbase_names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"stats\"     \"graphics\"  \"grDevices\" \"utils\"     \"datasets\"  \"methods\"  \n[7] \"base\"     \n```\n:::\n:::\n\nHow can we fetch all the functions from these packages? We can use `ls()` to list all their objects, supplying the package name in the format `\"package:base\"`, for example. Note that I said 'objects', not 'functions', since it will also return names that refer to things like datasets.\n\nFor fun, we can use this as an excuse to demo 'lambda' syntax and [the dog's balls approach](https://milesmcbain.micro.blog/2021/06/23/how-youd-fix.html) to function-writing, both introduced in R v4.1.[^underscore]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_pkgs <- paste0(\"package:\", base_names)\n\nbase_fns <- lapply(base_pkgs, ls) |>\n  setNames(base_names) |> \n  lapply(\\(object) as.data.frame(object)) |> \n  (\\(x) do.call(rbind, x))()  # the balls ()()\n\nbase_fns$package <- gsub(\"\\\\.\\\\d{,4}$\", \"\", row.names(base_fns))\nrow.names(base_fns) <- NULL\nbase_fns$nchar <- nchar(base_fns$object)\n\nbase_fns <- base_fns[order(-base_fns$nchar), ]\n```\n:::\n\n\nOf the 2465 objects across these packages, a quick histogram shows that the most frequent character length is under 10, with a tail stretching out to over 30.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(\n  base_fns$nchar,\n  main = \"Character length of base-object names\",\n  xlab = \"Number of characters\",\n  las = 1\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/hist-base-fns-1.png){fig-alt='Histogram of character lengths for base object names. It\\'s fairly normal around a bin of 6 to 8 characters, which has a peak frequency of over 400, plus there\\'s a tail stretching out to over 30 characters.' width=672}\n:::\n:::\n\n\nHere's the top 10 by character length.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_fns_top <- base_fns[order(-base_fns$nchar), ]\nrownames(base_fns_top) <- seq(length = nrow(base_fns_top))\nhead(base_fns_top, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                                  object package nchar\n1  aspell_write_personal_dictionary_file   utils    37\n2     getDLLRegisteredRoutines.character    base    34\n3       getDLLRegisteredRoutines.DLLInfo    base    32\n4        reconcilePropertiesAndPrototype methods    31\n5         suppressPackageStartupMessages    base    30\n6          as.data.frame.numeric_version    base    29\n7           as.character.numeric_version    base    28\n8            print.DLLRegisteredRoutines    base    27\n9             as.data.frame.model.matrix    base    26\n10            conditionMessage.condition    base    26\n```\n:::\n:::\n\n\nSo there are four objects with names longer than `suppressPackageStartupMessages()`, though they are rarely used as far as I can tell. The longest is `aspell_write_personal_dictionary_file()`, which has 37(!) characters. It's part of the spellcheck functions in {utils}.\n\nIt's interesting to me that it follows some of those rules for function naming that I mentioned earlier. It has a verb, is descriptive and uses a prefix for easier autocomplete; 'aspell' refers to [the GNU open-source Aspell spellchecker](http://aspell.net/) on which it's based.\n\nI'm intrigued that the function uses snake_case rather than camelCase or dot.case, which seem more prevalent in base functions. You could argue then that the underscores have 'inflated' the length by four characters. Similarly, the prefix adds another six characters. So maybe the function could be simplified to `writePersonalDictionaryFile()`, which is merely 27 characters.\n\nWhat about shortest functions? There are many one-character functions in base R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(base_fns[base_fns$nchar == 1, ][[\"object\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"-\" \":\" \"!\" \"?\" \"(\" \"[\" \"{\" \"@\" \"*\" \"/\" \"&\" \"^\" \"+\" \"<\" \"=\" \">\" \"|\" \"~\" \"$\"\n[20] \"c\" \"C\" \"D\" \"F\" \"I\" \"q\" \"t\" \"T\"\n```\n:::\n:::\n\n\nSome of these will be familiar, like `c()` to concatenate and `t()` to transpose. You might wonder why operators and brackets are in here. Remember: everything in R is a function, so `` `[`(mtcars, \"hp\")`` is the same as `mtcars[\"hp\"]`. I have to admit that `stats::C()` and `stats::D()` were new to me.\n\n### Tidyverse\n\nHow about object names from the {tidyverse}?\n\nTo start, we need to attach the packages. Running `library(tidyverse)` only loads the core packages of the tidyverse, so we need another approach to attach them all.\n\nOne method is to get the a vector of the package names with the `tidyverse_packages()` function and pass it to `p_load()` from {pacman}, which prevents the need for a separate `library()` call for each one.[^pac]\n\nFirst, here's the tidyverse packages.\n\n<div class=\"tip\"> ℹ️ <b>Update</b>\n\nI updated this post in July 2023. The {lubridate} package is now installed as part of the tidyverse and many new functions have appeared across the multitude of packages in the metapackage.\n\n</div>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"tidyverse\")  # if not installed\nsuppressPackageStartupMessages(  # in action!\n  library(tidyverse)\n)\ntidy_names <- tidyverse_packages()\ntidy_names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"broom\"         \"conflicted\"    \"cli\"           \"dbplyr\"       \n [5] \"dplyr\"         \"dtplyr\"        \"forcats\"       \"ggplot2\"      \n [9] \"googledrive\"   \"googlesheets4\" \"haven\"         \"hms\"          \n[13] \"httr\"          \"jsonlite\"      \"lubridate\"     \"magrittr\"     \n[17] \"modelr\"        \"pillar\"        \"purrr\"         \"ragg\"         \n[21] \"readr\"         \"readxl\"        \"reprex\"        \"rlang\"        \n[25] \"rstudioapi\"    \"rvest\"         \"stringr\"       \"tibble\"       \n[29] \"tidyr\"         \"xml2\"          \"tidyverse\"    \n```\n:::\n:::\n\n\nAnd now to load them all.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"pacman\")  # if not installed\nlibrary(pacman)\np_load(char = tidy_names)\n```\n:::\n\n\nOnce again we can `ls()` over packages in the form `\"package:dplyr\"`. Now the {tidyverse} is loaded, we might as well use it to run the same pipeline as we did for the base packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_pkgs <- paste0(\"package:\", tidy_names)\n\ntidy_fns <- map(tidy_pkgs, ls) |>\n  set_names(tidy_names) |> \n  enframe(name = \"package\", value = \"object\") |>\n  unnest(object) |> \n  mutate(nchar = nchar(object))\n```\n:::\n\n\nSo we're looking at even more packages this time, since the whole tidyverse contains 3070 of them.\n\nThe histogram is not too dissimilar to the one for base packages, though the tail is shorter, it's arguably more normal-looking and the peak is perhaps slightly closer to 10. The latter could be because of more liberal use of snake_case.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(\n  tidy_fns$nchar,\n  main = \"Character length of {tidyverse} object names\",\n  xlab = \"Number of characters\",\n  las = 1\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/hist-tidy-fns-1.png){fig-alt='Histogram of character lengths for tidyverse object names. It\\'s fairly normal around a bin of 8 to 10 characters, which has a peak frequency of over 600, plus there\\'s a tail stretching out to over 30 characters.' width=672}\n:::\n:::\n\n\nHere's the top 10 by character length.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslice_max(tidy_fns, nchar, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 11 × 3\n   package       object                            nchar\n   <chr>         <chr>                             <int>\n 1 rlang         ffi_standalone_check_number_1.0.7    33\n 2 googlesheets4 vec_ptype2.googlesheets4_formula     32\n 3 googlesheets4 vec_cast.googlesheets4_formula       30\n 4 cli           cli_progress_builtin_handlers        29\n 5 rstudioapi    getRStudioPackageDependencies        29\n 6 rstudioapi    registerCommandStreamCallback        29\n 7 rlang         ffi_standalone_is_bool_1.0.7         28\n 8 dbplyr        supports_star_without_alias          27\n 9 rstudioapi    launcherPlacementConstraint          27\n10 cli           ansi_has_hyperlink_support           26\n11 ggplot2       scale_linewidth_continuous           26\n```\n:::\n:::\n\n\nWell there you are: `ffi_standalone_check_number_1.0.7()` from {rlang} wins the prize with 33 characters. What does it do? The full documentation is literally 'Internal API for standalone-types-check'. Okey doke.\n\nIntriguingly, the next two are both from {googlesheets4}. The help pages say they're 'internal {vctrs} methods'. The names of these are long because of the construction: the first part tells us the method name, e.g. `vec_ptype2`, and the second part tells us that they apply to the `googlesheets4_formula` S3 class.\n\nSo maybe these don't really count because they would be executed as as `vec_ptype2()` and `vec_cast()`? And they're inflated because they contain the package name, {googlesheets4}, which is quite a long one (13 characters). That would leave `cli::cli_progress_builtin_handlers()` and `rstudioapi::getRStudioPackageDependencies()` as the next longest (29 characters). The latter uses camelCase---which is typical of the {rstudioapi} package---so isn't bulked out by underscores.\n\nOn the other end of the spectrum, there's only one function with one character: `dplyr::n()`. I think it makes sense to avoid single-character functions in non-base packages, because they aren't terribly descriptive. `n()` can at least be understood to mean 'number'.\n\nInstead, here's all the two-letter functions from the {tidyverse}. Note that many of these are from {lubridate} and are shorthand expressions that make sense in context, like `hm()` for hour-minute. You can also see some of {rlang}'s operators creep in here, like bang-bang (`!!`) and the walrus (`:=`).[^bandname]\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::filter(tidy_fns, nchar == 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 16 × 3\n   package   object nchar\n   <chr>     <chr>  <int>\n 1 cli       no         2\n 2 dplyr     do         2\n 3 dplyr     id         2\n 4 lubridate am         2\n 5 lubridate hm         2\n 6 lubridate ms         2\n 7 lubridate my         2\n 8 lubridate pm         2\n 9 lubridate tz         2\n10 lubridate ym         2\n11 lubridate yq         2\n12 magrittr  or         2\n13 rlang     :=         2\n14 rlang     !!         2\n15 rlang     ll         2\n16 rlang     UQ         2\n```\n:::\n:::\n\n\nMany of these are due to {lubridate} using single letters to represent time periods, like `hm` is 'hour minute'. You can also see some symbols from {rlang}, like the good ol' `:=`, or 'walrus' operator.\n\nBoth the {dplyr} functions here are no longer intended for use. I'm sad especially for `dplyr::do()`: the help page says it 'never really felt like it belong[ed] with the rest of dplyr'. Sad.\n\n> In memoriam: `do()`.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-07-06 19:26:59 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] xml2_1.3.4          rvest_1.0.3         rstudioapi_0.14    \n [4] rlang_1.1.1         reprex_2.0.2        readxl_1.4.2       \n [7] ragg_1.2.5          pillar_1.9.0        modelr_0.1.11      \n[10] magrittr_2.0.3      jsonlite_1.8.7      httr_1.4.6         \n[13] hms_1.1.3           haven_2.5.2         googlesheets4_1.1.1\n[16] googledrive_2.1.1   dtplyr_1.3.1        dbplyr_2.3.2       \n[19] cli_3.6.1           conflicted_1.2.0    broom_1.0.5        \n[22] pacman_0.5.1        lubridate_1.9.2     forcats_1.0.0      \n[25] stringr_1.5.0       dplyr_1.1.2         purrr_1.0.1        \n[28] readr_2.1.4         tidyr_1.3.0         tibble_3.2.1       \n[31] ggplot2_3.4.2       tidyverse_2.0.0    \n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.3      xfun_0.39         htmlwidgets_1.6.2 gargle_1.5.1     \n [5] tzdb_0.4.0        vctrs_0.6.3       tools_4.3.1       generics_0.1.3   \n [9] fansi_1.0.4       pkgconfig_2.0.3   data.table_1.14.8 lifecycle_1.0.3  \n[13] compiler_4.3.1    textshaping_0.3.6 munsell_0.5.0     htmltools_0.5.5  \n[17] yaml_2.3.7        cachem_1.0.8      tidyselect_1.2.0  digest_0.6.31    \n[21] stringi_1.7.12    fastmap_1.1.1     grid_4.3.1        colorspace_2.1-0 \n[25] utf8_1.2.3        withr_2.5.0       scales_1.2.1      backports_1.4.1  \n[29] timechange_0.2.0  rmarkdown_2.23    cellranger_1.1.0  memoise_2.0.1    \n[33] evaluate_0.21     knitr_1.43.1      glue_1.6.2        DBI_1.1.3        \n[37] R6_2.5.1          systemfonts_1.0.4 fs_1.6.2         \n```\n:::\n:::\n\n</details>\n\n[^suppress]: [I wrote recently a whole post about package startup messages](https://www.rostrum.blog/2021/08/27/zzz/).\n[^luke]: [Luke was curious too](https://twitter.com/mcguinlu/status/1443257017745948677?s=20), so that's at least two of us. (Luke also noticed that [a link to my {linkrot} package was itself rotten](https://twitter.com/mcguinlu/status/1443256485367197708?s=20), lol.)\n[^pac]: In fact, `p_load()` will attempt installation if the package can't be found in your library. Arguably, this is poor behaviour; you should always ask the user before installing something on their machine.\n[^underscore]: My understanding is that a future version of R will allow an underscore as the left-hand-side placeholder, in a similar manner to how the {tidyverse} allows a dot. That will do away with the need for `()()`. Also ignore my badly-written base code; I'm trying to re-learn.\n[^bandname]: Bang-Bang and the Walrus, touring Spring 2022.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "f50d494df9db4f2c4425d734294db14f",
  "result": {
    "markdown": "---\ntitle: Unhinged R Markdown chunk-option parsing\ndate: 2023-09-16\nslug: chunktop\ncategories:\n  - parsermd\n  - r\n  - r-markdown\n---\n\n\n## tl;dr\n\nParsing chunk options out of an R Markdown document. In a single base R pipe chain. To skirt around, but not solve, a problem.\n\n## Problem\n\nJohn asked about [parsing chunk options](https://fosstodon.org/@johnmackintosh/111047625054222865) from R Markdown files. Well, John, have I got the solution for you. Oh wait, I absolutely don't.\n\n## The leading candidate\n\nFirst place to start for parsing RMarkdown files is absolutely [the {parsermd} package](https://CRAN.R-project.org/package=parsermd ). It even has a specific function for extracting chunk options: `rmd_get_options()`.\n\nFor demo purposes, I'll first create a temporary demo Rmd doc. For test purposes it has three chunks: the first has a single logical option; the second has an option with a string and an option with a numeric; and the last chunk has no options. ALl chunks use the R engine and they all have a name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrmd_lines <- c(\n  \"---\",\n  \"title: Test\",\n  \"---\",\n  \"\",\n  \"# A header\",\n  \"\",\n  \"```{r chunk1, warning=FALSE}\",\n  \"1 + 1\",\n  \"```\",\n  \"\",\n  \"## A subheader\",\n  \"\",\n  '```{r chunk2, fig.cap=\"I am a fig caption.\", fig.height=4}',\n  \"plot(mtcars$mpg, mtcars$cyl)\",\n  \"```\",\n  \"\",\n  \"Some text.\",\n  \"\",\n  \"```{r chunk3}\",\n  \"plot(mtcars$mpg, mtcars$cyl)\",\n  \"```\"\n)\n\ndemo_rmd_file <- tempfile(\"rmd-demo\", fileext = \".Rmd\")\nwriteLines(rmd_lines, demo_rmd_file)\n```\n:::\n\n\nYou can read in this file with `parse_rmd()`, which is actually a little abstract syntax (AST) tree that demonstrates the hierarchy of the page and contains all the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!require(\"parsermd\")) install.packages(parsermd)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: parsermd\n```\n:::\n\n```{.r .cell-code}\nrmd_parsed <- parse_rmd(demo_rmd_file)\nrmd_parsed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n├── YAML [1 lines]\n└── Heading [h1] - A header\n    ├── Chunk [r, 1 opt, 1 lines] - chunk1\n    └── Heading [h2] - A subheader\n        ├── Chunk [r, 2 opts, 1 lines] - chunk2\n        ├── Markdown [2 lines]\n        └── Chunk [r, 1 lines] - chunk3\n```\n:::\n:::\n\n\nAnd then `rmd_get_options()` can pull out the options for us as a list of lists.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrmd_opts <- rmd_get_options(rmd_parsed)\nrmd_opts[lengths(rmd_opts) > 0] |> str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ :List of 1\n  ..$ warning: chr \"FALSE\"\n $ :List of 2\n  ..$ fig.cap   : chr \"\\\"I am a fig caption.\\\"\"\n  ..$ fig.height: chr \"4\"\n```\n:::\n:::\n\n\nJob done? Well, it still requires some juggling and there also needs to be a sort of 'reverse' method to return the options back into the Rmd chunk options. So, kinda.\n\nI have three 'problems' from my persepctive:\n\n2. Wouldn't it be more 'fun' to try and 'parse' chunk options from scratch?\n3. Wouldn't it be more 'fun' to do it by using a single chain of base pipes (`|>`)?\n4. Wouldn't it be 'fun' to make each chunk's name the name of its list element?\n\nSo I've turned this into a sort of unhinged code golf. Except we're making things more complicated. And it's totally unnecessary. But it's for fun. So maybe it's more like 'code bumpre cars' than code golf.\n\n## The function\n\nI've got a few input checks that I've put into a `.check_inputs()` so that it causes less clutter.\n\n<details><summary>Click for function to check inputs</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\n.check_inputs <- function(rmd_lines, engine, yaml_out) {\n\n  if (!inherits(rmd_lines, \"character\")) {\n    stop(\"Argument 'rmd_lines' must be a character vector.\", call. = FALSE)\n  }\n\n  if (engine != \"r\") {\n    stop(\"For now, argument 'engine' must be 'r'.\", call. = FALSE)\n  }\n\n  if (!is.null(yaml_out) & !inherits(yaml_out, \"character\")) {\n    stop(\"Argument 'yaml_out' must be NULL or character.\", call. = FALSE)\n  }\n\n  if (!is.null(yaml_out)) {\n\n    if (tools::file_ext(yaml_out) != \"yaml\") {\n      stop(\"Argument 'yaml_out' must have extension '.yaml'.\", call. = FALSE)\n    }\n\n    if (!dir.exists(dirname(yaml_out))) {\n      stop(\"The directory in 'yaml_out' does not exist.\", call. = FALSE)\n    }\n\n  }\n\n}\n```\n:::\n\n</details>\n\nAnd I'll let you look at the main `chunktop2yaml()` function before we dissect it a bit. \n\nAs mentioned, it's exclusively base R, apart from using {yaml} to save the file (I know, what a cop out). Note the use of `|>` base pipe, `_` placeholder, `\\()` anonymous function and `()()` 'dog's balls'. Welcome to base R circa 2023.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\nchunktop2yaml <- function(rmd_lines, engine = \"r\", yaml_out = NULL) {\n\n  .check_inputs(rmd_lines, engine, yaml_out)\n\n  chunktop_list <-\n    rmd_lines[grep(\"```\\\\{\", rmd_lines)] |>\n    gsub(paste0(\"```\\\\{\", engine , \" |\\\\}$\"), \"\", x = _) |>\n    strsplit(x = _, \", \") |>\n    (\\(chunk_str) setNames(object = chunk_str, sapply(chunk_str, \"[[\", 1)))() |>\n    sapply(X = _, \"[\", -1) |>\n    lapply(\n      X = _,\n      \\(opt_str) {\n        str_split(opt_str, \"=\") |>\n          (\\(opt_str) setNames(object = opt_str, sapply(opt_str, \"[[\", 1)))() |>\n          sapply(X = _, \"[\", -1) |>\n          as.list() |>\n          lapply(X = _, \\(val) gsub(r\"{^\\\"|\\\"$}\", \"\", x = val)) |>\n          type.convert(as.is = TRUE)\n      }\n    )\n\n  if (!is.null(yaml_out)) {\n    yaml::write_yaml(chunktop_list, yaml_out)\n    message(\"Wrote YAML to \", path_out)\n  }\n\n  return(chunktop_list)\n\n}\n```\n:::\n\n\nDoes the function name `chunktops2yaml()` imply the existence of a `yaml2chunktops()` function. Yes, but I leave that as a task for you, dear reader. See if you can set yourself some other ridiculous constraint in your function; maybe you'll try to only use functions that don't contain the letter 'a', or something.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-09-13 22:33:10 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] parsermd_0.1.2\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.3       cli_3.6.1         knitr_1.43.1      rlang_1.1.1      \n [5] xfun_0.39         purrr_1.0.1       jsonlite_1.8.7    glue_1.6.2       \n [9] backports_1.4.1   htmltools_0.5.5   hms_1.1.3         fansi_1.0.4      \n[13] rmarkdown_2.23    evaluate_0.21     tibble_3.2.1      tzdb_0.4.0       \n[17] fastmap_1.1.1     yaml_2.3.7        lifecycle_1.0.3   compiler_4.3.1   \n[21] htmlwidgets_1.6.2 Rcpp_1.0.11       pkgconfig_2.0.3   rstudioapi_0.15.0\n[25] digest_0.6.33     R6_2.5.1          readr_2.1.4       utf8_1.2.3       \n[29] pillar_1.9.0      magrittr_2.0.3    checkmate_2.2.0   tools_4.3.1      \n```\n:::\n:::\n\n</details>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "6e1b82b0c0f17bd8daaa264229f188cc",
  "result": {
    "markdown": "---\ntitle: Dear John, I'm sorry\ndate: 2023-09-16\nslug: chunktop\ncategories:\n  - parsermd\n  - r\n  - r-markdown\n---\n\n\n![](resources/chunktop.png){fig.alt=\"Crudely drawn picture of an apologetic face with two documents pointing to each other. One says Rmd on it, one says CSV.\"}\n\n## tl;dr\n\nI developed a convenience function for parsing chunk options out of an R Markdown document for collaborators to edit. But it doesn't work in reverse, which is the whole point. Some notes on failure.\n\n<div class=\"tip\"> \n`<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c13.3 0 24 10.7 24 24V264c0 13.3-10.7 24-24 24s-24-10.7-24-24V152c0-13.3 10.7-24 24-24zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z\"/></svg>`{=html} <b>Note</b>\n\nSince this was posted, the folks at ThinkR have a pretty good solution with [the {lightparser} package](https://github.com/ThinkR-open/lightparser): 'From Rmd And Qmd To Tibble And Back'. The 'And Back' being the crucial part.\n\n</div>\n\n## A very simple problem (?)\n\nJohn asked about [parsing chunk options](https://fosstodon.org/@johnmackintosh/111047625054222865) from R Markdown files (Rmd), passing the content to editors, then reincorporating the edited text back into the chunk whence it came.\n\nWell, John, have I got the solution for you. Oh wait, I absolutely don't. Rather I've looked into [{parsermd}](https://CRAN.R-project.org/package=parsermd), messed around and... gave up. C'est la vie.\n\nIn my hubris, I began the package [{chunktop}](https://github.com/matt-dray/chunktop) to solve John's problem. Goal: parse Rmd chunk options, write them to file, allow for edits, read them back in and reintegrate the strings into the chunks they came from. Then re-write the Rmd with the changes. Boom.\n\nSpoiler: I was naïve.\n\n## A good start\n\nMy advice: don't install {chunktop}; it's already archived on GitHub.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"remotes\")  # if not yet installed\nremotes::install_github(\"matt-dray/chunktop\")\n```\n:::\n\n\nIt steals functionality from the excellent [{parsermd} package](https://CRAN.R-project.org/package=parsermd) to grab Rmd chunk options using the very appropriate `rmd_get_options()` function.\n\nThe package contains a demo Rmd for testing purposes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath <- system.file(\"extdata/demo1.Rmd\", package = \"chunktop\")\n```\n:::\n\n\nYou can read in this demo Rmd with `parsermd::parse_rmd()`, which is actually a little abstract syntax tree (AST) that demonstrates the hierarchy of the page and contains all the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!require(\"parsermd\")) install.packages(parsermd)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: parsermd\n```\n:::\n\n```{.r .cell-code}\n(rmd <- parse_rmd(path))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n├── YAML [1 lines]\n└── Heading [h1] - A header\n    ├── Chunk [r, 1 opt, 1 lines] - chunk1\n    └── Heading [h2] - A subheader\n        ├── Chunk [r, 2 opts, 1 lines] - chunk2\n        ├── Markdown [2 lines]\n        ├── Chunk [r, 1 lines] - chunk3\n        └── Chunk [r, 2 opts, 1 lines] - chunk4\n```\n:::\n:::\n\nAnd we can take a look at the lines in the Rmd doc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(rmd_doc <- parsermd::as_document(rmd))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"---\"                                                                \n [2] \"title: Test\"                                                        \n [3] \"---\"                                                                \n [4] \"\"                                                                   \n [5] \"# A header\"                                                         \n [6] \"\"                                                                   \n [7] \"```{r chunk1, eval = FALSE}\"                                        \n [8] \"1 + 1\"                                                              \n [9] \"```\"                                                                \n[10] \"\"                                                                   \n[11] \"## A subheader\"                                                     \n[12] \"\"                                                                   \n[13] \"```{r chunk2, fig.cap = \\\"I am a fig caption.\\\", fig.height = 4}\"   \n[14] \"plot(mtcars$mpg, mtcars$cyl)\"                                       \n[15] \"```\"                                                                \n[16] \"\"                                                                   \n[17] \"Some text.\"                                                         \n[18] \"\"                                                                   \n[19] \"\"                                                                   \n[20] \"```{r chunk3}\"                                                      \n[21] \"plot(mtcars$mpg, mtcars$disp\"                                       \n[22] \"```\"                                                                \n[23] \"\"                                                                   \n[24] \"```{r chunk4, fig.cap = \\\"I am another fig caption.\\\", eval = TRUE}\"\n[25] \"plot(mtcars$mpg, mtcars$drat)\"                                      \n[26] \"```\"                                                                \n[27] \"\"                                                                   \n```\n:::\n:::\n\n\nSo it contains a bunch of chunks with various options.\n\nSo, here's as far as I got. First off, given our Rmd file, we can use `get_chunktop()` to read the chunk options of interest using {parsermd} and stick them a nice little list. Trivially.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(chunktop)\n(chunktop_list <- get_chunktop(rmd_file = path, opts = c(\"fig.cap\", \"eval\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$chunk1\n$chunk1$eval\n[1] \"FALSE\"\n\n\n$chunk2\n$chunk2$fig.cap\n[1] \"\\\"I am a fig caption.\\\"\"\n\n\n$chunk4\n$chunk4$fig.cap\n[1] \"\\\"I am another fig caption.\\\"\"\n\n$chunk4$eval\n[1] \"TRUE\"\n```\n:::\n:::\n\n\nWhich is trivially massaged into a data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(chunktop_df <- chunktop_to_df(chunktop_list))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  chunk_name option_name                option_value\n1     chunk1        eval                       FALSE\n2     chunk2     fig.cap       \"I am a fig caption.\"\n3     chunk4     fig.cap \"I am another fig caption.\"\n4     chunk4        eval                        TRUE\n```\n:::\n:::\n\n\nWhich is trivially written to a CSV to share with your colleagues for editing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncsv_file <- tempfile(fileext = \".csv\")\nwrite.csv(chunktop_df, csv_file, row.names = FALSE)\n```\n:::\n\n\nWhich is trivially read back into R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(chunktop_df2 <- read.csv(csv_file))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  chunk_name option_name                option_value\n1     chunk1        eval                       FALSE\n2     chunk2     fig.cap       \"I am a fig caption.\"\n3     chunk4     fig.cap \"I am another fig caption.\"\n4     chunk4        eval                        TRUE\n```\n:::\n:::\n\n\nWhich is trivially converted back into a list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(chunktop_list2 <- df_to_chunktop(chunktop_df2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$chunk1\n$chunk1$eval\n[1] \"FALSE\"\n\n\n$chunk2\n$chunk2$fig.cap\n[1] \"\\\"I am a fig caption.\\\"\"\n\n\n$chunk4\n$chunk4$fig.cap\n[1] \"\\\"I am another fig caption.\\\"\"\n\n$chunk4$eval\n[1] \"TRUE\"\n```\n:::\n:::\n\n\nAnd then we trivially, um, well, I don't know, actually. I just assumed there would be an elegant way to convert the listed options back into the chunk options. \n\nThe function `parsermd::rmd_set_options()` exists, but appears to set options for _all_ chunks, not _selected_ options. Maybe I misunderstood, let me know.\n\nFor sure you could do a thing where you parse the strings out of the Rmd and replace them with the new option values. You are welcome to do that, friend.\n\n## Descent into masochism\n\nAnyway, having implied that I am too lazy to do that, I actually tried something much more procastinatory when I hit a brick wall. Enjoy this bonus content.\n\nI wondered if I could just... extract the chunk options from the original Rmd myself, dependency-free. For 'fun'. \n\nBut I turned I into a sort of unhinged [code golf](remotes::install_github(\"matt-dray/chunktop\")\n). Well, maybe 'code wild-goose-chase'. The challenge: is it possible to extract chunk options from an arbitrary Rmd using only base R in a single base-R pipe (`|>`) chain? Haha, of course.\n\nFirst, I've got a few input checks that I've put into a `.check_inputs()` so that it causes less clutter in the main function.\n\n<details><summary>Click for function to check inputs</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\n.check_inputs <- function(rmd_lines, engine, yaml_out) {\n  \n  if (!inherits(rmd_lines, \"character\")) {\n    stop(\"Argument 'rmd_lines' must be a character vector.\", call. = FALSE)\n  }\n  \n  if (engine != \"r\") {\n    stop(\"For now, argument 'engine' must be 'r'.\", call. = FALSE)\n  }\n  \n  if (!is.null(yaml_out) & !inherits(yaml_out, \"character\")) {\n    stop(\"Argument 'yaml_out' must be NULL or character.\", call. = FALSE)\n  }\n  \n  if (!is.null(yaml_out)) {\n    \n    if (tools::file_ext(yaml_out) != \"yaml\") {\n      stop(\"Argument 'yaml_out' must have extension '.yaml'.\", call. = FALSE)\n    }\n    \n    if (!dir.exists(dirname(yaml_out))) {\n      stop(\"The directory in 'yaml_out' does not exist.\", call. = FALSE)\n    }\n    \n  }\n  \n}\n```\n:::\n\n</details>\n\nSo here's an overengineered `grab_chunktop()` function that extracts Rmd chunk options.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrab_chunktop <- function(rmd_lines, engine = \"r\", yaml_out = NULL) {\n  \n  .check_inputs(rmd_lines, engine, yaml_out)\n  \n  rmd_lines[grep(\"```\\\\{\", rmd_lines)] |>  # isolate Rmd chunks\n    gsub(paste0(\"```\\\\{\", engine , \" |\\\\}$\"), \"\", x = _) |>  # retain options\n    strsplit(\", \") |>  # list of chunks, split by commas\n    (\\(chunk_str) {\n      setNames(object = chunk_str, sapply(chunk_str, \"[[\", 1))  # name-value\n    })() |>  # name the list elements after chunks\n    sapply(\"[\", -1) |>  # forget first element (engine)\n    lapply(  # split options/values into nested list under named chunk\n      \\(opt_str) {\n        strsplit(opt_str, \"=\") |>  # \"eval=TRUE\" to \"eval\" and \"TRUE\"\n          (\\(opt_str) {  # first element to name\n            setNames(object = opt_str, trimws(sapply(opt_str, \"[[\", 1)))}\n          )() |>\n          sapply(\"[\", -1) |>  # now remove first element\n          trimws() |> \n          as.list() |>\n          type.convert(as.is = TRUE)  # make sure \"1\" becomes 1\n      }\n    )\n  \n}\n```\n:::\n\n\nAbsolutely disgusting. But it works!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrab_chunktop(rmd_doc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$chunk1\n$chunk1$eval\n[1] FALSE\n\n\n$chunk2\n$chunk2$fig.cap\n[1] \"\\\"I am a fig caption.\\\"\"\n\n$chunk2$fig.height\n[1] 4\n\n\n$chunk3\nlist()\n\n$chunk4\n$chunk4$fig.cap\n[1] \"\\\"I am another fig caption.\\\"\"\n\n$chunk4$eval\n[1] TRUE\n```\n:::\n:::\n\n\nNote the exclusive use of `|>` base pipe, `_` placeholder, `\\()` anonymous function and `()()` 'dog's balls'. Welcome to base R circa 2023.\n\nI'm telling you this works and you can see that's the case. But gosh bless you if you actually try to grok that code by eye.\n\n## Brief grief\n\nNothing good has come of this. I just have more respect for {parsermd}. But here's a brief timeline of my activites on this task:\n\n* there's no way this isn't trivial (denial)\n* I can't believe I can't batter {parsermd} into doing this (anger)\n* I'll start a package and see where we get (bargaining)\n* what if I simply ignore the package and lark about with base R instead (depression)\n* I'll just write a blog post and move on (acceptance)\n\nDon't worry, you only lost a few braincells reading this. I lost an afternoon, woe is me.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2024-01-13 09:55:00 GMT\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] chunktop_0.0.0.9000 parsermd_0.1.2     \n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5       cli_3.6.2         knitr_1.45        rlang_1.1.3      \n [5] xfun_0.41         purrr_1.0.2       jsonlite_1.8.7    glue_1.7.0       \n [9] backports_1.4.1   htmltools_0.5.6.1 hms_1.1.3         fansi_1.0.6      \n[13] rmarkdown_2.25    evaluate_0.23     tibble_3.2.1      tzdb_0.4.0       \n[17] fontawesome_0.5.2 fastmap_1.1.1     yaml_2.3.8        lifecycle_1.0.4  \n[21] compiler_4.3.1    htmlwidgets_1.6.2 Rcpp_1.0.11       pkgconfig_2.0.3  \n[25] rstudioapi_0.15.0 digest_0.6.33     R6_2.5.1          tidyselect_1.2.0 \n[29] readr_2.1.4       utf8_1.2.4        pillar_1.9.0      magrittr_2.0.3   \n[33] checkmate_2.2.0   withr_2.5.2       tools_4.3.1      \n```\n:::\n:::\n\n</details>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "96c34177cda6de706c2ea5f14e06e1eb",
  "result": {
    "markdown": "---\ntitle: Very simple pixel art in R\ndate: 2021-06-28\nslug: pixel-art\ncategories:\n  - magick\n  - dataviz\n  - r\n  - videogames\n---\n\n\n![It's dangerous to code alone...](resources/link.gif){fig-alt=\"Two-frame sprite animation of Link from The Legend of Zelda walking forwards.\" fig-align=\"left\"}\n\n## tl;dr\n\nYou can use R's `image()` function to convert a matrix to a pixelly graphic.\n\n<div class=\"tip\"> `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c13.3 0 24 10.7 24 24V264c0 13.3-10.7 24-24 24s-24-10.7-24-24V152c0-13.3 10.7-24 24-24zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z\"/></svg>`{=html} <b>Note</b>\n\nI've now written [a little R package called {pixeltrix}](https://github.com/matt-dray/pixeltrix), which lets you click on squares in a plot window to generate a matrix of 'pixels'. This means you don't have to type out any vectors by hand. You can read more in [some other blog posts](https://www.rostrum.blog/tags/pixeltrix/).\n\n</div>\n\n## Pixel fixation\n\nMy [last post](https://www.rostrum.blog/2021/06/26/emojiscape/) was about [the {emojiscape} package](https://github.com/matt-dray/emojiscape), which makes a little scene out of sampled emojis.\n\nFollowing a similar approach, you could write a matrix by hand and plot it via the base function `image()`. Here's a very basic example with a 'glider' from [Conway's Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life#Examples_of_patterns). Values of `0` are 'dead' cells and values of `1` are 'live'. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nglider_v <- c(0,0,0,0,0, 0,0,1,0,0, 0,0,0,1,0, 0,1,1,1,0, 0,0,0,0,0)\nglider_m <- matrix(glider_v, 5)           # convert to matrix\nglider_m <- glider_m[, ncol(glider_m):1]  # reverse cols\npar(mar = rep(0, 4))                      # ensure no margins\nimage(glider_m)                           # plot it\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/glider-1.png){width=192}\n:::\n:::\n\n\nNote that I input the vector values from what would become the top left to bottom right of the output matrix. The `image()` function doesn't read them in this order, however, so I've added a step to reverse the column order so the plot output appears as I intended.\n\nAlso, `image()` normally outputs with labelled axes, but we can effectively hide those by minimising the `mar`gins `par()`ameter of the plot to 0.\n\n## Reprologoducibility\n\nBut really my  motivation is to make a reproducible version of [this blog's logo](https://raw.githubusercontent.com/matt-dray/stickers/master/output/rostrum_hex.png): an insect composed of 'pixels' in a 16-by-16 square.\n\nSo, I've hand-coded a binary vector of length 256 (i.e. 16 * 16). The `0`s and `1`s here represent background and insect pixels, respectively. I've used line breaks to make it easier to create and edit the vector manually.\n\nHere's the vector that represents the logo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogo_v <- c(\n  \n  0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,\n  0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,\n  0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,\n  0,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,\n  \n  0,0,0,1,0,1,0,1,1,0,1,0,1,0,0,0,\n  0,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,\n  0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,\n  0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,\n  \n  0,0,1,0,1,1,0,1,1,0,1,1,0,1,0,0,\n  0,0,0,1,0,1,0,1,1,0,1,0,1,0,0,0,\n  0,0,0,0,0,1,0,1,1,0,1,0,0,0,0,0,\n  0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,\n  \n  0,0,0,1,0,1,0,1,1,0,1,0,1,0,0,0,\n  0,0,0,1,0,1,0,1,1,0,1,0,1,0,0,0,\n  0,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,\n  0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0\n\n)\n```\n:::\n\n\nI might as well make a (non-generic) function to matrixify (definitely a word) and plot the vector, so I can then tweak a few parameters as I please.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_logo <- function(\n  x = logo_v,           # vector\n  px = 16,              # width/length of output (square)\n  col_0 = \"black\",      # colour for values of 0\n  col_1 = \"#1e8016\",    # colour for values of 1\n  lwd = 8               # to separate the squares\n) {\n  \n  par(mar = rep(0, 4))  # set margins outside plot region\n  \n  m <- matrix(x, px)    # create a matrix from the vector\n  m <- m[, ncol(m):1]   # reverse cols\n  \n  image(m, col = c(col_0, col_1))  # plot matrix, colour by number\n  \n  # If line width provided, draw lines between squares\n  if (!is.null(lwd)) {\n    px_half <- px * 2\n    s <- seq(-1 / px_half, 1 + (1 / px_half), 1 / (px - 1))\n    abline(h = s, v = s, col = col_0, lwd = lwd)\n  }\n  \n}\n```\n:::\n\n\nNote that I added a line width argument (`lwd`). If specified, horizontal and vertical lines are drawn to give the impression that the squares are 'separated' from each other.\n\nHere's the logo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_logo(lwd = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/logo-vanilla-1.png){width=192}\n:::\n:::\n\n\nAnd here's what happens if we remove the lines and swap the colours, for example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_logo(col_0 = \"#1e8016\", col_1 = \"black\", lwd = NULL)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/logo-altered-1.png){width=192}\n:::\n:::\n\n\nAnd given it's Pride Month:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in rainbow(7)) {\n  plot_logo(lwd = 1, col_0 = \"white\", col_1 = i)\n}\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/rainbow-1.png){width=96}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/rainbow-2.png){width=96}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/rainbow-3.png){width=96}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/rainbow-4.png){width=96}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/rainbow-5.png){width=96}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/rainbow-6.png){width=96}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/rainbow-7.png){width=96}\n:::\n:::\n\n\n## Sprite delight\n\nThis approach is basically [pixel-art](https://en.wikipedia.org/wiki/Pixel_art)-by-numbers, right? \n\nSo I've written and animated two frames of a classic videogame character, [Link from The Legend of Zelda on the NES](https://en.wikipedia.org/wiki/The_Legend_of_Zelda_(video_game)), using [the {magick} package](https://cran.r-project.org/web/packages/magick/vignettes/intro.html) to create a gif.\n\nThere's four colours in this one, so the vectors are no longer binary: there's `0` for the background, `1` for green, `2` for skin and `3` for the darker spots.\n\nThe top part of the sprite doesn't change between frames, but the bottom does. To avoid repetition, we can store the top part as a separate vector, then combine it with each frame's lower section. It's still a bit of a slog to input these by hand!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlink_v_top <- c(\n  0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,\n  0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,\n  0,0,2,0,1,3,3,3,3,3,3,1,0,2,0,0,\n  0,0,2,0,3,3,3,3,3,3,3,3,0,2,0,0,\n  \n  0,0,2,2,3,2,1,2,2,1,2,3,2,2,0,0,\n  0,0,2,2,3,2,3,2,2,3,2,3,2,2,0,0,\n  0,0,0,2,2,2,2,2,2,2,2,2,2,3,0,0\n)\n\nlink_v_b1 <- c(\n  0,0,0,1,1,2,2,3,3,2,2,1,1,3,0,0,\n  \n  0,3,3,3,3,3,2,2,2,2,1,1,3,3,3,0,\n  3,3,2,3,3,3,3,1,1,1,1,1,2,3,3,0,\n  3,2,2,2,3,3,2,3,3,1,1,2,2,2,3,0,\n  3,3,2,3,3,3,2,1,3,3,3,3,2,2,2,0,\n  \n  3,3,2,3,3,3,2,3,3,1,1,1,1,2,0,0,\n  3,3,3,3,3,3,2,1,1,1,1,1,0,0,0,0,\n  0,2,2,2,2,2,3,0,0,3,3,3,0,0,0,0,\n  0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0\n)\n\nlink_v_b2 <- c(\n  0,0,0,0,1,2,2,3,3,2,2,1,3,3,0,0,\n  \n  0,0,3,3,3,3,3,2,2,2,1,1,1,2,0,0,\n  0,3,3,2,3,3,3,3,1,1,1,1,1,2,0,0,\n  0,3,2,2,2,3,3,2,3,3,1,1,3,0,0,0,\n  0,3,3,2,3,3,3,2,1,3,3,3,1,0,0,0,\n  \n  0,3,3,2,3,3,3,2,3,3,1,1,1,0,0,0,\n  0,3,3,3,3,3,3,2,1,1,1,3,0,0,0,0,\n  0,0,2,2,2,2,2,0,0,3,3,3,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0\n)\n\n# Combine vectors to get frames\nlink_f1 <- c(link_v_top, link_v_b1)\nlink_f2 <- c(link_v_top, link_v_b2)\n```\n:::\n\n\nNow we have the vectors representing Link for each frame of the animation. The approach now is like before: convert this to a 16 by 16 matrix and plot it. This time I've got a function that also saves the plots by first opening a `png()` graphics device and closing it at the end with `dev.off()`. I've saved these to a temporary directory for the purposes of the post, rather than my local disk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp <- tempdir()  # store temporary folder path\n\n# Function to write frame to temporary folder\nwrite_link <- function(vec) {\n  write_path <- file.path(tmp, paste0(substitute(vec), \".png\"))\n  png(write_path, width = 160, height = 160)\n  link_m <- matrix(vec, 16)\n  link_m <- link_m[, ncol(link_m):1]\n  par(mar = rep(0, 4))\n  link_cols <- c(\"white\", \"#7bc702\", \"#cc8f2d\", \"#6c430a\")\n  image(link_m, col = link_cols)\n  dev.off()\n}\n\n# Write the frames\nwrite_link(link_f1); write_link(link_f2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nquartz_off_screen \n                2 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nquartz_off_screen \n                2 \n```\n:::\n:::\n\n\nWe get a couple of messages to say that the devices have been closed, confirming the save.\n\nNow we can use the {magick} package to create a gif: `image_read()` to load both PNG frames into a single object from their save location, and then `image_animate()` to combine the images into an output that flips between the two frames. You could also use `image_write()` to save this object to gif format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate a gif from the saved frames\npng_paths <- list.files(tmp, \"*.png$\", full.names = TRUE)     # get file paths\nframes <- magick::image_read(png_paths)                       # load the files\nmagick::image_animate(frames, fps = 2, dispose = \"previous\")  # combine frames\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/link-out-1.gif)\n:::\n:::\n\n\nI'm not sure I'll be coding the graphics for the whole game anytime soon...\n\n## Hip to be square\n\nI'm not the first person to think or do this in R, I'm sure.\n\nI did come across [a really neato {pixelart} package and Shiny app by Florian PrivÃ©](https://github.com/privefl/pixelart) where you upload an image and it gets converted into a pixel form. As [Florian said in his blogpost](https://privefl.github.io/blog/shiny-app-for-making-pixel-art-models/):\n\n> Kids and big kids can quickly become addicted to this\n\nYes. And that's exactly why this post exists.\n\nLet me know if you know of any more packages or whatever that do this sort of thing.\n\n<div class=\"tip\"> `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c13.3 0 24 10.7 24 24V264c0 13.3-10.7 24-24 24s-24-10.7-24-24V152c0-13.3 10.7-24 24-24zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z\"/></svg>`{=html} <b>Note</b>\n\nTurns out that [mikefc, aka coolbutuseless](https://twitter.com/coolbutuseless), (who else?) wrote [a great blog post](https://coolbutuseless.github.io/2018/08/13/gganimate-with-sprites/) with a method for grabbing, plotting and animating sprites with the packages {png}, {raster}, {ggplot2} and {gganimate}. Slightly less painful than writing vectors by hand! \n\nIf you want to design your own sprites rather than copy others, [try my little {pixeltrix} package](https://github.com/matt-dray/pixeltrix) for interactive pixel selection from a plot window, which returns a matrix.\n\n</div>\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-07-17 18:34:30 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.31     fastmap_1.1.1     xfun_0.39         fontawesome_0.5.1\n [5] magrittr_2.0.3    knitr_1.43.1      htmltools_0.5.5   rmarkdown_2.23   \n [9] cli_3.6.1         compiler_4.3.1    rstudioapi_0.15.0 tools_4.3.1      \n[13] evaluate_0.21     Rcpp_1.0.11       yaml_2.3.7        magick_2.7.4     \n[17] rlang_1.1.1       jsonlite_1.8.7    htmlwidgets_1.6.2\n```\n:::\n:::\n\n</details>\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "7ee13bef179166892c8e7ecaa160c866",
  "result": {
    "markdown": "---\ntitle: \"You are a halfling, trying to harvest {potato}\"\ndate: 2022-09-13\nslug: potato\ntags:\n  - gamedev\n  - potato\n  - r\n  - videogames\n---\n\n\n![](resources/potato.png){fig-alt=\"A low-quality cartoon drawing of a potato with a little cute face.\" width=\"50%\"}\n\n## tl;dr\n\nPlay an interactive version of ['Potato'](https://twitter.com/deathbybadger/status/1567425842526945280)---a one-page halfling-themed role-playing game (RPG) by Oliver Darkshire ([Twitter](https://www.twitter.com/deathbybadger), [Patreon](https://www.patreon.com/deathbybadger))---in your R console with [the {potato} package](https://github.com/matt-dray/potato).\n\n## Potato?\n\nI've recently put together [a GitHub repo](https://github.com/matt-dray/splendid-r-games) to collect together a bunch of neat games that you can play. The twist? They were built using R. \n\nYes, R: 'a FrEe SoFtWaRe EnViRoNmEnT fOr StAtIsTiCaL cOmPuTiNg AnD gRaPhIcS'.\n\nI think R is best suited to either text-based user-input games on the R console, or via a more dedicated interface, like Shiny.[^mike]\n\nIn this vein, [Oliver Darkshire](https://www.twitter.com/deathbybadger) wrote an excellent 'one-page role-playing game' called [Potato](https://twitter.com/deathbybadger/status/1567425842526945280) that seems ripe for plucking (well, I guess you 'pull' potatoes?) into an R implementation. A simple text interface; updating and tracking variables; clear win conditions. The basic desire to avoid action and simply tend to vegetables.\n\nSo... {potato}.\n\n## Potato!\n\nYou can install [the {potato} package from GitHub](https://github.com/matt-dray/potato) thanks to {remotes}:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"remotes\")  # if not yet installed\nremotes::install_github(\"matt-dray/potato\")\n```\n:::\n\n\nYou start a game with:[^potayto]\n\n\n::: {.cell}\n\n```{.r .cell-code}\npotato::potato()\n```\n:::\n\n```\n--- POTATO ---\n\nA (one-page) RPG by Oliver Darkshire (@deathbybadger)\nThese and more at https://www.patreon.com/deathbybadger\n\nYou are a halfling, just trying to exist.\nMeanwhile, the dark lord rampages across the world.\nYou do not care about this. You are trying to farm potatoes.\nBecause what could a halfling possibly do about it anyway?\n\nKeep rolling until DESTINY, POTATO or ORC reach 10/10.\n\n- DESTINY: 0/10\n- POTATO:  0/10\n- ORC:     0/10\n- PAY:     1 POTATO to remove 1 ORC\n\nPress [ENTER] to roll... \n```\n\nThe console will prompt you for input as you play. It's basically luck-based die rolls, though you will have the chance to intervene with an option to hurl a certain number of precious potatoes at an orc to make it clear off.\n\nYou win when `POTATO` reaches `10`. You lose when `ORC` reaches `10`. You also... 'don't lose'... if `DESTINY` reaches `10`.\n\nPlease see [the one-page RPG that David put together](https://twitter.com/deathbybadger/status/1567425842526945280) and/or [support him on Patreon](https://www.patreon.com/deathbybadger) if you like it or any of the other hilarious one-page RPGs that he's made.\n\nI cannot stress enough that this is his work and all I've done is put it into an obscure format that literally three people might look at for a laugh.\n\n## Potato...\n\nI could just leave it there, but I think the interesting thing for R users are the various little methods required to make the 'game' function.\n\nTo display text to the user in the console, we can use `cat()` or `message()`. I kinda prefer `message()` because the user has more control over it in general, like `suppressMessages()` (which does what you think it does). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmessage(\"Hello world!\")\n```\n:::\n\n```\nHello world!\n```\n\nThere's a subtlety in presentation too, which is that the two functions return text in different colours.\n\nThe game loop itself runs inside a `repeat`, which is maybe uncommon for some R users. We're mostly used to `for` or `while` loops for iteration with a known set of things to iterate over, whereas `repeat` will keep going until we specify a `break`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrepeat {\n  \n  if (keep_going) {\n    do_something()\n  }\n  \n  if (!keep_going) {\n    break\n  }\n  \n}\n```\n:::\n\n\nYou can imagine a scenario where `keep_going` is set to `TRUE` and some actions happen as a result; and that if it becomes `FALSE` then the game loop ends. In {potato}, we make sure to first print the current values of `DESTINY`, `POTATO` and `ORC` so the user sees them before the game continues or ends.\n\nWhat are `DESTINY`, `POTATO` and `ORC`? Before we initiate that `repeat` loop we can specify a bunch of starting values for some important scoring variables. Stylistically, it makes sense to use ALL CAPS for these (that's how they were written in the original game, after all), but there's also an old-school rule-of-thumb to specify variables this way in R code so you can more easily spot them in your code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDESTINY <- 0L\nPOTATO  <- 0L\nORC     <- 0L\n```\n:::\n\n\nin addition, we clearly need user input to decide what to do during the game. Most of the time, a user's hand is forced and they need to roll. But sometimes they have the choice to remove an orc at the cost of one or more potatoes (depending on how the die falls).\n\nThis is a logical variable that we can keep track of, i.e. can the user pay (`TRUE` or `FALSE`)?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncan_pay <- FALSE\n\nif (COST <= POTATO) {\n  can_pay <- TRUE\n} else if (COST > POTATO) {\n  can_pay <- FALSE\n}\n```\n:::\n\n\nIf the cost to yeet an orc is equal-to or less-than the number of potatoes, we can elect to make the payment. This is expressed in the options provided to the user on the command line.\n\nGiven the `can_pay` value, the user will get the option to either roll the die (`FALSE`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nevent <- readline(\n  \"Press [ENTER] to roll... \"\n)\n```\n:::\n\n\nOr choose to roll the die _or_ make the payment (`TRUE`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nevent <- readline(\n  \"Press [ENTER] to roll or [p] to pay 1 POTATO to remove 1 ORC... \"\n)\n```\n:::\n\n\nBoth of which require user input that results in a value stored in the `event` object. Note that hitting <kbd>Enter</kbd> results in an empty string (`\"\"`).\n\nDie-roll values pass through a series of `if` statements that are activated based on the number rolled. So if you roll `1` or `2`, you're `In the garden...`; if 3 or 4, you'll get `A knock on the door...`; else the potato cost per orc-yeet increases by 1).\n\nA second roll is made automatically when in the garden or when a knock is heard. Here's what happens if a `1` is rolled when in the garden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (rolled_garden == 1L) {\n  \n  message(\n    paste(\n      rolled_garden_msg,\n      \"You happily root about all day in your garden.\"\n    )\n  )\n  \n  message(\"- Result: +1 POTATO\")\n  \n  POTATO <- POTATO + 1L\n  \n}\n```\n:::\n\n\nExcellent, the `POTATO` variable counter is increased by 1 in this case and confirmed to the user in a `message()`. The latest `DESTINY`, `POTATO` and `ORC` scores are then printed back to the user at the start of the next `repeat` loop.\n\nAnd then you just... keep potatoing.\n\n## Potato.\n\nOnce again, you can visit Oliver Darkshire on Twitter as [@deathbybadger](https://www.twitter.com/deathbybadger) and support him on [Patreon](https://www.patreon.com/deathbybadger).\n\nYou can find [the source code for {potato} on GitHub](https://github.com/matt-dray/potato). Issues and pull requests welcome. Just make sure you can afford the charge of one potato to submit.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2024-07-14 20:25:55 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.4.0 (2024-04-24)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.4 compiler_4.4.0    fastmap_1.2.0     cli_3.6.3.9000   \n [5] tools_4.4.0       htmltools_0.5.8.1 rstudioapi_0.16.0 yaml_2.3.8       \n [9] rmarkdown_2.26    knitr_1.46        jsonlite_1.8.8    xfun_0.43        \n[13] digest_0.6.35     rlang_1.1.4.9000  evaluate_0.23    \n```\n:::\n:::\n\n</details>\n\n[^mike]: Yeah, but have you seen the mind-boggling extent to which [Mike Cheng (AKA mikefc, AKA coolbutuseless, AKA R legend)](https://coolbutuseless.github.io/) has gone to [turn R into a proper game engine?](https://www.rstudio.com/conference/2022/talks/polygons-of-another-world-realtime/)\n[^potayto]: Potayto, potahto, let's call the whole thing off.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
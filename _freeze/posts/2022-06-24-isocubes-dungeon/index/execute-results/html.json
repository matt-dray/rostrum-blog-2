{
  "hash": "136a66dae3418e32380ebce6e27576c6",
  "result": {
    "markdown": "---\ntitle: An isometric dungeon chase in R\ndate: '2022-06-28'\nslug: isometric-dungeon\ncategories:\n  - eventloop\n  - game-dev\n  - isocubes\n  - r\n  - r.oguelike\n  - videogames\n---\n\n\n\n\n![](resources/04-isocubes-chase.gif){fig-alt=\"Gif of an R graphics window showing a tiled dungeon space made of isometric cubes. A user is controlling the movement of a blue cube around the black floor within the brown walls. A yellow cube chases the player around, narrowing the distance over time. When the enemy and player inhabit the same tile, they fuse to become a green cube that moves around as a single entity.\" width=\"100%\"}\n\n## tl;dr\n\nI made an interactive isometric-dungeon demo in R, thanks to [{r.oguelike}](https://matt-dray.github.io/r.oguelike/) for dungeon building and [mikefc](https://twitter.com/coolbutuseless)'s [{isocubes}](https://github.com/coolbutuseless/isocubes) for drawing isometric cube graphics and [{eventloop}](https://github.com/coolbutuseless/eventloop) for continuous keypress inputs.\n\n## A new dimension\n\n[Mike](https://twitter.com/coolbutuseless) (AKA mikefc, AKA coolbutuseless) is well known for off-label R creations that desecrate the assumption that ['R is a language for statistical computing'](https://twitter.com/mattdray/status/1539371338250522624).\n\nMike revealed [the {isocubes} package](https://github.com/coolbutuseless/isocubes) recently, which lets you print objects made of isometric cubes to a graphics device. I immediately thought of [the toy {r.oguelike} package](https://matt-dray.github.io/r.oguelike/) I've [been developing recently](https://www.rostrum.blog/2022/04/25/r.oguelike-dev/), which has the goal of creating (really) basic features of [a roguelike game](https://en.wikipedia.org/wiki/Roguelike) in R.[^wolfgang] The dungeons are currently ASCII tiles printed to the console. How would it look in isometric?\n\nIn a frenzied series of tweets, I built up a little toy that creates a procedural isometric dungeon and adds a user-controlled player character and a pathfinding enemy. The steps were to:\n\n1. Build an isometric dungeon ([tweet](https://twitter.com/mattdray/status/1539281300619763718))\n2. Add a player ([tweet](https://twitter.com/mattdray/status/1539370837219868673))\n3. Accept continuous input ([tweet](https://twitter.com/mattdray/status/1539400843409207296))\n4. Add a pathfinding enemy ([tweet](https://twitter.com/mattdray/status/1540107713681788928))\n\nThis post talks through those steps. You can [find the code for the final product in a GitHub Gist](https://gist.github.com/matt-dray/dcbd5cd2f4bdc471921e5c741a1233c0). It is absolutely not polished and really is just a Frankenstein's monster of code that I stapled together.\n\n### 1. Build an isometric dungeon\n\n{r.oguelike} creates procedural dungeons in the form of a matrix where `#` symbols are non-traversable wall tiles and `.` indicates traversable floor tiles. I wrote about the inception of the package [in a recent blog post](https://www.rostrum.blog/2022/05/01/dungeon/).\n\nWe can swap the characters for height values, where the floor is `1` and the walls are `2`, and {isocubes} will project the walls one cube above the plane of the floor. We can also use this information to provide colours; black for the floor and brown for the walls, for example, so it looks like a cavern.\n\nHere's a few examples:\n\n![](resources/01-isocubes-dungeons.gif){fig-alt=\"A gif of several successive procedural dungeons composed of isometric cubes. The bottom cube layer represents the floor. The top layer is composed of brown 'wall' cubes. Gaps in the second layer expose the black floor cubes beneath. The result is an enclosed cavern-like space. Each frame is a new random pattern of open floor space.\" width=\"100%\"}\n\nI think that looks pretty good (ignore the graphical artefacts from the gif compression). I didn't time how long it took for each image to be rendered because it was near-instantaneous. \n\nBut we don't want to just look at pictures of dungeons, we want to explore them.\n\n### 2. Add a player\n\n{r.oguelike} lets a user move a character around the the floor tiles. The player is represented by `@` in the dungeon matrix, which we can again substitute with a height value of `1` so it's one cube higher than the floor. Of course, we should colour it to distinguish it from the walls; I chose blue.\n\nThe user's keyboard input is accepted by `readline()` and this determines the character's movement. Typing <kbd>W</kbd> then <kbd>Enter</kbd> will make the player move north one tile, for example. In {r.oguelike}, a keypress input causes the current location to be overwritten with a floor tile (`.`); the tile above to be replaced with the player symbol (`@`); and then the updated matrix is re-printed to the console. \n\nAgain, this all takes place inside the matrix that represents the dungeon, so we can also just lift this functionality into the {isocubes} version. Here you can see a series of user inputs to the console that result in the player moving around the floor tiles.\n\n<div class=\"figure\">\n<img src=\"resources/02-isocubes-readline.gif\" alt=\"Gif of a procedural dungeon in RStudio, which is composed of isometric cubes. The bottom cube layer represents the floor. The top layer is composed of brown 'wall' cubes. Gaps in the second layer expose the black floor cubes beneath. The result is an enclosed cavern-like space. A blue 'player' cube is controlled by inputs to the console: W, A, S and D keypresses move it up, left, down and right.\" width=\"100%\"/>\n</div>\n\n![](resources/02-isocubes-readline.gif){fig-alt=\"Gif of a procedural dungeon in RStudio, which is composed of isometric cubes. The bottom cube layer represents the floor. The top layer is composed of brown 'wall' cubes. Gaps in the second layer expose the black floor cubes beneath. The result is an enclosed cavern-like space. A blue 'player' cube is controlled by inputs to the console: W, A, S and D keypresses move it up, left, down and right.\" width=\"100%\"}\n\nIt was really pleasing when I got this to work, but it's also quite tedious to tap in a key and hit enter for each movement.\n\n### 3. Accept continuous input\n\n{r.oguelike} simply prints the dungeon matrix to the console at the end of each turn, whereas our {isocubes} version takes place in a graphics window that's refreshed with every turn. \n\nMike also has [a package called {eventloop}](https://github.com/coolbutuseless/eventloop),[^eventloop] which he suggested might be useful for continuous input from the user. The package contains:\n\n> a framework for rendering interactive graphics and handling mouse+keyboard events from the user at speeds fast enough to be considered interesting for games and other realtime applications\n\nBear in mind that it doesn't work on Windows. Read more about it in [Mike's blog](https://coolbutuseless.github.io/2022/05/06/introducing-eventloop-realtime-interactive-rendering-in-r/).\n\nHere you can see the result of incorporating {eventloop}. The user is pressing the arrow keys---which you can see being printed to the console---to move the player. This is way more seamless than the previous `readline()` method.\n\n<div class=\"figure\">\n<img src=\"\" alt=\"Gif of an R graphics window showing a dungeon space made of isometric cubes. A user is controlling the movement of a blue cube around the black floor within the brown walls. The latest input is shown in the console as 'pressed left', etc.\" width=\"100%\"/>\n</div>\n\n![](resources/03-isocubes-eventloop.gif){fig-alt=\"Gif of an R graphics window showing a dungeon space made of isometric cubes. A user is controlling the movement of a blue cube around the black floor within the brown walls. The latest input is shown in the console as 'pressed left', etc.\" width=\"100%\"}\n\nThis is a nice demo, but it would be great to make this more of a 'game'.\n\n### 4. Add a pathfinding enemy\n\n{r.oguelike} has an enemy character, represented in the dungeon matrix as `E`. Again, we can replace this with a height of `1` and colour it yellow, for example. \n\n[I wrote recently about implementing simple breadth-first pathfinding](https://www.rostrum.blog/2022/06/10/basic-search/) so that the enemy can head toward wherever the player currently is. At time of writing I haven't fully implemented the pathfinding into {r.oguelike}, but that didn't stop me adding it into the code for this isometric demo.\n\nHere you can see the enemy cube (yellow) hunting down the player-controlled cube (blue). I was [motivated to add a capture condition](https://twitter.com/coolbutuseless/status/1540080432829665281) and decided to have fun with it.\n\n![](resources/04-isocubes-chase.gif){fig-alt=\"Gif of an R graphics window showing a tiled dungeon space made of isometric cubes. A user is controlling the movement of a blue cube around the black floor within the brown walls. A yellow cube chases the player around, narrowing the distance over time. When the enemy and player inhabit the same tile, they fuse to become a green cube that moves around as a single entity.\" width=\"100%\"}\n\nI hope you enjoyed the victory dance at the end of the gif (it was the best I could do with the limited graphics).[^enemy]\n\n<div class=\"tip\"> ℹ️ <b>Update</b>\n\nAfter this post was published, [the {oblicubes} package](https://github.com/trevorld/oblicubes) was published by [Trevor L Davies](https://github.com/trevorld). It allows you to use oblique projections. So obviously I had a go with {r.oguelike}.\n\n![](resources/oblicubes-eventloop.gif){fig-alt=\"A procedurally-generated tile-based dungeon room, made of obliquely-projected cubes. Walls are brown cubes of height one, floors are white. A player-controlled cube (blue) is chased and captured by a pathfinding enemy cube (yellow).\" width=\"100%\"}\n\n<details><summary>Click for the required code changes.</summary>\n\nIn [the code I wrote](https://gist.github.com/matt-dray/dcbd5cd2f4bdc471921e5c741a1233c0), you pretty much replace:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- isocubes::coords_heightmap(dungeon_h, col = dungeon_c)\n\ncubes  <- isocubes::isocubesGrob(\n  coords,\n  max_y = ncol(dungeon_h) + 0.1 * ncol(dungeon_h),\n  fill = coords$col,\n  xo = 0.7\n)\n\ngrid::grid.newpage()  # 'clear'\ngrid::grid.draw(cubes)  # render\n```\n:::\n\n\nWith:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- oblicubes::xyz_heightmap(\n  dungeon_h,\n  col = dungeon_c,\n  scale = 0.3,\n  ground = \"xy\"\n)\n\ngrid::grid.newpage()  # 'clear'\noblicubes::grid.oblicubes(coords)  # render\n```\n:::\n\n\n</details>\n\n</div>\n\n## The fourth dimension\n\nI need to tie up some loose ends in the current version of {r.oguelike}, but I'm considering the possibilities for {isocubes} and {eventloop} in future. Maybe the `start_game()` function could have an argument where the user can choose 2D or 3D (isometric or oblique) representations of the game.\n\nI also have a few ideas of how I can use my basic {r.oguelike} 'engine' with {isocubes} to develop some other, non-roguelike games. For example, [Dmytro (AKA Deemah) suggested {rsokoban}](https://twitter.com/dmi3k/status/1539501583431610370). [Sokoban](https://en.wikipedia.org/wiki/Sokoban) is a game where you solve small tile-based puzzles by pushing crates onto designated spots. I was also reminded of [Q*bert](https://en.wikipedia.org/wiki/Q*bert), where you try and touch all the floor tiles to change their colour.\n\nSo many ideas for off-label R use, so little time.\n\n## Postscript\n\nI lied a bit earlier. The actual first thought I had when seeing {isocubes} was pixel art. [I wrote a post (exactly) one year ago](https://www.rostrum.blog/2021/06/28/pixel-art/) where I converted some vectors into little pixel drawings using R's `image()` function.\n\nIt's fairly straightforward to convert those vectors into a format accepted by {isocubes}, which means you can have an [isometric sprite of Link from The Legend of Zelda](https://twitter.com/mattdray/status/1538869234410967041), or [a rainbow version of the insect logo for this blog](https://twitter.com/mattdray/status/1538862896855359499).\n\n![](resources/isometric-link-rostrum.png){fig-alt=\"Two images side-by-side. A sprite of Link from the Legend of Zelda on the NES, rendered with isometric cubes thanks to the 'isocubes' R package. A pixelated image of an insect—the logo of rostrum.blog—rendered with isometric cubes, thanks to the 'isocube' package. The cubes are rainbow-coloured from left to right.\" width=\"100%\"}\n\nI wrote [a GitHub Gist with the code for these images](https://gist.github.com/matt-dray/389af1afa61a778bbd1f286912b43627), so feel free to steal. Let me know what you end up making.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-06-30 22:50:04 CEST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Zurich\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2 compiler_4.3.1    fastmap_1.1.1     cli_3.6.1        \n [5] tools_4.3.1       htmltools_0.5.5   rstudioapi_0.14   yaml_2.3.7       \n [9] rmarkdown_2.22    knitr_1.43.1      jsonlite_1.8.5    xfun_0.39        \n[13] digest_0.6.31     rlang_1.1.1       evaluate_0.21    \n```\n:::\n:::\n\n</details>\n\n[^wolfgang]: But yo, [have you seen what Wolfgang has been up to](https://twitter.com/wviechtb/status/1539701716844781573) re roguelikes in R? What the actual heck.\n[^enemy]: Yes, the 'game' is an existential one: was the enemy chasing you, or _were you the enemy all along?_\n[^eventloop]: You can find more examples of {eventloop} [in a dedicated GitHub repo](https://github.com/coolbutuseless/eventloop-examples/), including apps, games, sounds and graphics.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
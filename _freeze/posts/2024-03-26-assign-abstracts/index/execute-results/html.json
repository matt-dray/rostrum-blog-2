{
  "hash": "fe88ec51b97bd1ddce3172d13378ce75",
  "result": {
    "markdown": "---\ntitle: \"Assign abstracts to sifters\"\ndate: 2024-03-26\nslug: \"assign-abstracts\"\ncategories:\n  - charlatan\n  - r\n---\n\n\n## tl;dr\n\nA quick and dirty R function to assign abstracts to sifters.\n\n## Assign me up\n\nI hacked together a function to assign conference abstracts to sifters so they could be assessed. There were several requirements that complicated things. The function:\n\n* tries to make assignment counts equal between sifters where possible\n* results in each abstract being assigned _n_ times, to assure fairness in assessment\n* ensures each sifter receives a unique set of abstracts\n* prevents the sifter seeing their own abstracts, if they submitted any\n* prevents the sifter seeing abstracts by authors with the same affiliation as the sifter, if relevant\n* respects a maximum assignment 'cap', if the sifter has one\n* allows the user to set a maximum number of iterations to prevent infinite looping (may be possible under certain conditions)\n\n### Process\n\nThe function itself is split into three main parts:\n\n1. Setup of variables to be used in iteration.\n2. A `repeat` loop that will keep assigning abstracts to the set of sifters until the total abstract pool is exhausted and the various requirements are met.\n3. Within the `repeat` loop, a `for` loop that iterates over each sifter to assign them an abstract from their pool of viable abstracts.\n\nWithin the `for` loop are three main steps:\n\n1. Find the pool of abstracts available to the sifter (if any).\n2. Select randomly an abstract from the pool and assign it to the sifter.\n3. Increment the assignment counter for the selected abstract.\n\nThe `for` loop will go to the `next` sifter if the pool of abstracts for the current sifter is zero. The `repeat` loop will `break` if all of the abstracts have been assigned _n_ number of times, according to the `assignment_cap` argument. It will also `break` if the number of iterations given by `max_iterations` has been met.\n\n### Definition\n\nThe function is not optimised at all, is not fully tested and has no defensive programming. But it fulfilled the requirements for the task. I'm recording it here for posterity.\n\nI've added some comments and tried to make variable names informative. The `abstracts_df` and `sifters_df` inputs are dataframes that have columns for the `name` and `affiliation`, along with a maximum-assignment `cap` column in the `sifters_df`.\n\nOf course, it's too big and should be broken into smaller functions, particularly each of the steps in the `for` loop. Also, you feed in dataframes, but these are converted immediately to named vectors for processing. In part this reflects the ease of handling named vectors, but is also a legacy of when the requirements were far simpler. The requirements grew more complicated over time, so it became a Frankenfunction\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassign_abstracts <- function(\n    abstracts_df,\n    sifters_df,\n    assignment_cap = 2, \n    max_iterations = 1000\n) {\n  \n  # Set up named vectors\n  abstracts <- with(abstracts_df, setNames(affiliation, name))\n  sifters <- with(sifters_df, setNames(affiliation, name))\n  sifter_caps <- with(sifters_df, setNames(cap, name))\n  sifter_caps <- sifter_caps[!is.na(sifter_caps)]\n  \n  # Set up starting variables\n  n_abstracts <- length(abstracts)\n  seq_abstracts <- seq_len(n_abstracts)\n  sifter_assignments <- setNames(vector(\"list\", length(sifters)), names(sifters))\n  assignment_counts <- rep(0, n_abstracts)\n  iter <- 0\n  \n  repeat {\n    \n    for (name in names(sifter_assignments)) {\n      \n      # 1. Find the pool of abstracts available to this sifter (if any)\n      \n      # a. Check if sifter cap has been met\n      sifter_has_cap <- name %in% names(sifter_caps)\n      if (sifter_has_cap) {\n        sifter_cap <- sifter_caps[[name]]\n        sifter_assignment_count <- length(sifter_assignments[[name]])\n      }\n      if (sifter_has_cap && sifter_assignment_count == sifter_cap) next\n      \n      # b. Add abstracts to pool if they have <n assignments\n      abstracts_under_cap <- which(assignment_counts < assignment_cap)\n      if (length(abstracts_under_cap) == 0) next\n      \n      # c. Remove abstracts that are already assigned to this sifter\n      already_assigned_to_sifter <- sifter_assignments[[name]]\n      abstracts_available <- \n        abstracts_under_cap[!abstracts_under_cap %in% already_assigned_to_sifter]\n      if (length(abstracts_available) == 0) next\n      \n      # d. Remove abstracts by the named sifter\n      abstracts_by_sifter <- which(name == names(abstracts[abstracts_available]))\n      if (length(abstracts_by_sifter) > 0) {\n        abstracts_available <- abstracts_available[-abstracts_by_sifter]\n      }\n      if (length(abstracts_available) == 0) next\n      \n      # e. Remove abstracts with the same affiliation as the sifter\n      sifter_affiliation <- unname(sifters[name])\n      abstracts_by_same_affiliation <- \n        which(sifter_affiliation == unname(abstracts[abstracts_available]))\n      if (length(abstracts_by_same_affiliation) > 0) {\n        abstracts_available <- \n          abstracts_available[-abstracts_by_same_affiliation]\n      }\n      if (length(abstracts_available) == 0) next\n      \n      # 2. Select randomly from pool and assign to sifter\n      abstract_selected <- .resample(abstracts_available, 1)\n      sifter_assignments[[name]] <- \n        c(sifter_assignments[[name]], abstract_selected)\n      \n      # 3. Increment count for sampled abstract\n      assignment_counts[abstract_selected] <- \n        assignment_counts[abstract_selected] + 1\n      if (all(assignment_counts == assignment_cap)) break\n      \n    }\n    \n    # Reorder so sifter with fewest assignments gets next assignment first\n    sifter_assignments <- sifter_assignments[order(lengths(sifter_assignments))]\n    \n    iter <- iter + 1\n    \n    if (all(assignment_counts == assignment_cap)) break\n    \n    if (iter == max_iterations) {\n      message(\"max_iterations reached\")\n      break\n    }\n    \n  }\n  \n  sifter_assignments <- lapply(sifter_assignments, sort)\n  sifter_assignments[order(names(sifter_assignments))]\n  \n}\n\n.resample <- function(x, ...) x[sample.int(length(x), ...)]\n```\n:::\n\n\nNote the bespoke `.resample()` function because `sample()` operates differently depending on whether you give it a vector or a single value[^inferno]. If only one abstract is left in the pool, e.g. abstract number 13, then `sample(13)` won't output 13, it will actually output a value from 1 to 13.\n\n## Example\n\n### Demo data\n\nLet's create some fake data using [the {charlatan} package](https://docs.ropensci.org/charlatan/). Let's imagine we have some sifters and their affiliations. One sifter only has time to do 10 assessments, so they have a `cap` value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n\nn_sifters <- 5\nsifter_companies <- charlatan::ch_company(n_sifters)\nsifter_names <- charlatan::ch_name(n_sifters)\n\n(sifters_df <- data.frame(\n  name = sifter_names,\n  affiliation = sifter_companies,\n  cap = c(10, rep(NA_real_, n_sifters - 1))\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              name                        affiliation cap\n1 Justen Powlowski                         Paucek Inc  10\n2 Jon Blick-Erdman                    Ziemann-Ziemann  NA\n3   Cannon Hegmann                        Wyman-Wyman  NA\n4  Nichelle Schoen Daugherty, Daugherty and Daugherty  NA\n5   Earley Monahan                        Walsh-Walsh  NA\n```\n:::\n:::\n\n\nNow let's create some fake abstracts, again with names and affiliations. The abstract titles here are just random species names, so let's pretend we're at a taxonomists' conference or something. Let's make it so the sifters have each submitted an abstract of their own and that there's at least one other submission from their organisation. \n\nOf course, your abstract dataset is likely to contain more information, like the actual text of the abstract and other details like the author's geographic location and talk-type preference (poster, plenary, etc). If you've used an online survey service then you can usually download a CSV of the results or connect to their API to get the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntotal_abstracts <- 30\n\nabstracts_df <- data.frame(\n  name = c(sifter_names, charlatan::ch_name(total_abstracts - n_sifters)),\n  affiliation = c(\n    rep(sifter_companies, 2),\n    charlatan::ch_company(total_abstracts - (2 * n_sifters))\n  ),\n  title = charlatan::ch_taxonomic_species(total_abstracts)\n)\n\nabstracts_df <- abstracts_df[sample(nrow(abstracts_df)), ]  # shuffle\nrow.names(abstracts_df) <- NULL\n\nhead(abstracts_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  name                        affiliation                 title\n1     Jon Blick-Erdman                    Ziemann-Ziemann   Coniogramme euantha\n2       Tavaris Reilly                        Wyman-Wyman       Tristemon egena\n3 Shavonne Ziemann PhD            Satterfield-Satterfield  Pichleria majungense\n4      Nichelle Schoen Daugherty, Daugherty and Daugherty      Zelkova vigilans\n5        Durrell Mertz                Jaskolski-Jaskolski Papuechites denutatum\n6      Mikayla Rau DDS                        Stark-Stark   Oldfieldia mohriana\n```\n:::\n:::\n\n\n### Run\n\nLet's provide the `abstracts_df` and `sifters_df` dataframes to the function, along with the number of times each abstract will need to be assessed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 2\n\nassignments <- assign_abstracts(\n  abstracts_df,\n  sifters_df,\n  assignment_cap = n\n)\n```\n:::\n\n\nHere's what the output looks like. It's a named list with one element per sifter. The values are the index of that abstract in the vector provided to the `abstracts_df` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassignments\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`Cannon Hegmann`\n [1]  1  4  6  8 10 12 16 19 20 26 28 29\n\n$`Earley Monahan`\n [1]  1  4  5  7 10 12 13 17 22 25 27 28\n\n$`Jon Blick-Erdman`\n [1]  7  8 11 14 15 16 17 18 21 22 23 24 30\n\n$`Justen Powlowski`\n [1]  2  3  5  9 14 18 20 23 26 29\n\n$`Nichelle Schoen`\n [1]  2  3  6  9 11 13 15 19 21 24 25 27 30\n```\n:::\n:::\n\n\nThese indices can be matched back to the original dataset. Here's an example for the first sifter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassignment_df <- abstracts_df[assignments[[1]], ]\nhead(assignment_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                             name                        affiliation\n1                Jon Blick-Erdman                    Ziemann-Ziemann\n4                 Nichelle Schoen Daugherty, Daugherty and Daugherty\n6                 Mikayla Rau DDS                        Stark-Stark\n8                  Earley Monahan                        Walsh-Walsh\n10               Heriberto Feeney                    Ziemann-Ziemann\n12 Muhammad Stoltenberg-Hermiston                        Tillman LLC\n                     title\n1      Coniogramme euantha\n4         Zelkova vigilans\n6      Oldfieldia mohriana\n8      Isoetella flaccidum\n10     Tylophora serrulata\n12 Microtropis turubalense\n```\n:::\n:::\n\n\nYou could wrangle this into an anonymised dataframe with columns for the sifter to provide their assessment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanon_df <- assignment_df[, \"title\", drop = FALSE]\nanon_df$score <- NA_real_\nanon_df$comments <- NA_character_\nanon_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                         title score comments\n1          Coniogramme euantha    NA     <NA>\n4             Zelkova vigilans    NA     <NA>\n6          Oldfieldia mohriana    NA     <NA>\n8          Isoetella flaccidum    NA     <NA>\n10         Tylophora serrulata    NA     <NA>\n12     Microtropis turubalense    NA     <NA>\n16         Coussapoa anatuyana    NA     <NA>\n19 Chiloglottis brideliifolius    NA     <NA>\n20            Crocus candollei    NA     <NA>\n26         Pistacia weinmannii    NA     <NA>\n28         Baillaudea dodsonii    NA     <NA>\n29         Syngonium tangutica    NA     <NA>\n```\n:::\n:::\n\n\nAnd then you can return this back to the sifter. The low-tech mechanism would be to put this into a spreadsheet output with {openxlsx}, for example. Much better would be to create a simple Shiny app hosted on Posit Connect or something, allowing each sifter to see their assigned abstracts and submit their assessments.\n\n### Check\n\nGreat, but the output actually meet the initial requirements for the system? Let's take a look.\n\nWas each abstract assigned the number of times specified by `assignment_cap`?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(table(unlist(assignments)) == n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nHere you can see that sifters received a near-equal number of abstracts, apart from the sifter who had a specified maximum-assignment cap.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlengths(assignments)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Cannon Hegmann   Earley Monahan Jon Blick-Erdman Justen Powlowski \n              12               12               13               10 \n Nichelle Schoen \n              13 \n```\n:::\n:::\n\n\nWas each sifter assigned a unique set of abstracts?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(lengths(lapply(assignments, unique)) == lengths(assignments))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nDid anyone receive their own abstract?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsifter_names <- sifters_df[sifters_df$name %in% names(assignments), \"name\"]\n\nhas_own_abstract <- vector(\"list\", length = length(sifter_names)) |> \n  setNames(sifter_names)\n\nfor (i in seq_along(sifter_names)) {\n  sifter_name <- sifter_names[i]\n  abstract_names <- abstracts_df$name[assignments[[i]]]\n  has_own_abstract[[i]] <- all(sifter_name == abstract_names)\n}\n\nunlist(has_own_abstract)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJusten Powlowski Jon Blick-Erdman   Cannon Hegmann  Nichelle Schoen \n           FALSE            FALSE            FALSE            FALSE \n  Earley Monahan \n           FALSE \n```\n:::\n:::\n\n\nDid any of the sifters get assigned abstracts from their own affiliation?\n\n\n::: {.cell}\n\n```{.r .cell-code}\naffiliations <- \n  sifters_df[sifters_df$name %in% names(assignments), \"affiliation\"]\n\nhas_affiliate_abstract <- vector(\"list\", length = length(assignments)) |> \n  setNames(affiliations)\n\nfor (i in seq_along(affiliations)) {\n  sifter_affiliation <- affiliations[i]\n  abstract_affiliations <- abstracts_df$affiliation[assignments[[i]]]\n  has_affiliate_abstract[[i]] <- all(sifter_affiliation == abstract_affiliations)\n}\n\nunlist(has_affiliate_abstract)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                        Paucek Inc                    Ziemann-Ziemann \n                             FALSE                              FALSE \n                       Wyman-Wyman Daugherty, Daugherty and Daugherty \n                             FALSE                              FALSE \n                       Walsh-Walsh \n                             FALSE \n```\n:::\n:::\n\n\nOkey-doke.\n\n## What now?\n\nThis could definitely be better. \n\nAs mentioned, there's a lot of refactoring that could be done, recognising that it was developed rapidly with changing requirements. I'm reflecting on it now that it's solved the problem, but eventually it may be refactored or rewritten from scratch. \n\nThis would make sense if we (or you) want to use it in other scenarios or as part of a more generic package in future.\n\nOr, as usual, this functionality probably exists in some package already and you can tell me all about it. \n\n### Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2024-03-26 18:34:06 GMT\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.33     utf8_1.2.4        R6_2.5.1          fastmap_1.1.1    \n [5] xfun_0.41         magrittr_2.0.3    glue_1.7.0        tibble_3.2.1     \n [9] knitr_1.45        pkgconfig_2.0.3   htmltools_0.5.6.1 rmarkdown_2.25   \n[13] lifecycle_1.0.4   cli_3.6.2         fansi_1.0.6       vctrs_0.6.5      \n[17] compiler_4.3.1    rstudioapi_0.15.0 tools_4.3.1       whisker_0.4.1    \n[21] pillar_1.9.0      evaluate_0.23     charlatan_0.5.1   yaml_2.3.8       \n[25] rlang_1.1.3       jsonlite_1.8.7    htmlwidgets_1.6.2\n```\n:::\n:::\n\n</details>\n\n[^inferno]: The 'single sample switch' as Patrick Burns puts it [in The R Inferno](https://www.burns-stat.com/pages/Tutor/R_inferno.pdf) (section 8.2.33).",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
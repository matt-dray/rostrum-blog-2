{
  "hash": "dedc8905afb89e7b98cbf52189707527",
  "result": {
    "markdown": "---\ntitle: \"A bank holiday to honour uv?\"\ndate: 2025-08-11\nslug: \"uv-standalone\"\nimage: resources/bank.png\ncategories:\n  - api\n  - executable\n  - python\n  - shell\n  - uv\n---\n\n\n![](resources/bank.png){fig-align=\"left\" fig-alt=\"The command bank.py is run in a macOS terminal Window, yielding the phrase 'Summer bank holiday is on 25 August 2025', with a series of triangle symbols alternating with a black-and-white fill to look like bunting.\" width='100%'}\n\n## tl;dr\n\nYou can use [uv](https://docs.astral.sh/uv/) to help turn a Python[^streak] script into a self-contained executable. Useful for really important stuff, like... discovering the next public holiday from your terminal?\n\nThis is my own attempt at something [I saw Rodrigo do](https://mathspp.com/blog/til/standalone-executable-python-scripts-with-uv)[^credit].\n\n## Worth a bunt\n\nThe UK government maintains [an API catalogue](https://www.api.gov.uk/#uk-public-sector-apis). A very (very) simple API example is [the bank-holidays API](https://www.api.gov.uk/gds/bank-holidays/#bank-holidays) run by the Government Digital Service (GDS). It's perhaps most well-known for [the associated page on the GOV.UK website](https://www.gov.uk/bank-holidays). \n\nAll the API does is serve a JSON file with upcoming public holidays. I wrote a ramshackle little Python script that grabs the file, works out what the next holiday is, and prints it out.\n\nCrucially, it also prints [bunting](https://en.wikipedia.org/wiki/Bunting_(decoration)) if, according to the JSON, the occasion calls for it.\n\n## Banking crisis\n\nSo, here's the quite-ordinary code for this demonstration[^critique]:\n\n\n::: {.cell filename='bank.py'}\n\n```{.python .cell-code}\nimport httpx\nfrom datetime import date\n\n# Fetch bank holidays\n\nresp = httpx.get(\"https://www.gov.uk/bank-holidays.json\")\nevents = resp.json()[\"england-and-wales\"][\"events\"]\n\nfor event in events:\n    event[\"date\"] = date.fromisoformat(event[\"date\"])\n\n# Find next holiday\ntoday = date.today()\nfuture = [event for event in events if event[\"date\"] >= today]\nnext = future[0]\n\n# Print message\n\nis_today = next[\"date\"] == today\nneeds_bunting = next[\"bunting\"]\n\nif is_today:\n    when = \"today!\"\nelse: \n    when = f\"on {next['date'].strftime('%d %B %Y')}\"\n\nstr_out = f\"{next['title']} is {when}\"\n\nif needs_bunting:\n    str_out = str_out + \" ▼▽▼▽▼▽\"\n\nprint(str_out)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSummer bank holiday is on 25 August 2025 ▼▽▼▽▼▽\n```\n:::\n:::\n\n\nVery simple. Does the job[^r]. But if we want to use the script, maybe we'll have to clone a repo containing the script, change directory, activate the virtual environment and only then run the script. Every time we want to use it.\n\nWouldn't it be better if I could just call it quickly from my macOS Terminal when I need it? To just type `bank.py` and get a quick response?\n\n## uv protection\n\nThis is where [uv](https://docs.astral.sh/uv/) can help out[^uv]. You can [install](https://docs.astral.sh/uv/getting-started/installation/) via Homebrew with `brew install uv`, for example.\n\nYou can start by adding a block at the top of your file to declare dependencies. Kind of like bundling a `pyproject.toml` inside your script[^inscript]. No need to worry about a separate dependencies file, lockfile or virtual environment.\n\nTo add your dependencies, use `uv add` with the `--script` option in the form:\n\n\n::: {.cell}\n\n```{.sh .cell-code}\nuv add httpx datetime --script bank.py\n```\n:::\n\n\nWhich will add the following section at the top of our `bank.py` script, including the Python requirement:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# /// script\n# requires-python = \">=3.12\"\n# dependencies = [\n#     \"datetime\",\n#     \"httpx\",\n# ]\n# ///\n```\n:::\n\n\nAnd there you have it: all the information needed to run this file in an isolated manner. You'll be able to run `uv run bank.py` from your terminal without any additional files required.\n\nBut wait! There's more. How boring, how _painful_ to have to write the `uv run` bit. That's _six_ characters[^typo]. And you'll have to provide the full path to the script, yikes.\n\nInstead, you can add a [shebang](https://en.wikipedia.org/wiki/Shebang_%28Unix%29)[^shebang] at the top of the file to make it executable:\n\n::: {.cell}\n\n```{.python .cell-code}\n#!/usr/bin/env -S uv run\n```\n:::\n\n\nNote the unusual bit on the end... aha! uv again! The `-S uv run` bit asks the interpreter to let good ol' uv handle the whole operation.\n\nFinally, you can change the mode (`chmod`) of the file by adding (`+`) executable (`x`) status. Then put the file where you terminal will look if you type the name of the file.\n\n\n::: {.cell}\n\n```{.sh .cell-code}\nchmod +x bank.py\nmv bank.py ~/.local/bin\n```\n:::\n\n\nThen you can merely call `bank.py` from the terminal to know when the next bank holiday is.\n\n<div class=\"tip\"> \n`<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c13.3 0 24 10.7 24 24V264c0 13.3-10.7 24-24 24s-24-10.7-24-24V152c0-13.3 10.7-24 24-24zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z\"/></svg>`{=html} <b>Note</b>\n\nIn fact, I discovered later [in uv's docs](https://docs.astral.sh/uv/guides/scripts/#using-a-shebang-to-create-an-executable-file) that you can add the `--script` flag to the shebang and remove the `.py` extension from the filename to ensure you only need to type `bank` into the terminal. Much sleeker.\n\n</div>\n\n## One man's trash\n\nYou can find a [GitHub Gist of my code](https://gist.github.com/matt-dray/c97603f294fb80736b669141191d827b)[^gist], or:\n\n<details><summary>Click to see the complete `bank.py` script.</summary>\n\n\n::: {.cell filename='bank.py'}\n\n```{.python .cell-code}\n#!/usr/bin/env -S uv run\n\n# /// script\n# requires-python = \">=3.12\"\n# dependencies = [\n#     \"datetime\",\n#     \"httpx\",\n# ]\n# ///\n\nimport httpx\nfrom datetime import date\n\n# Fetch bank holidays\n\nresp = httpx.get(\"https://www.gov.uk/bank-holidays.json\")\nevents = resp.json()[\"england-and-wales\"][\"events\"]\n\nfor event in events:\n    event[\"date\"] = date.fromisoformat(event[\"date\"])\n\n# Find next holiday\ntoday = date.today()\nfuture = [event for event in events if event[\"date\"] >= today]\nnext = future[0]\n\n# Print message\n\nis_today = next[\"date\"] == today\nneeds_bunting = next[\"bunting\"]\n\nif is_today:\n    when = \"today!\"\nelse: \n    when = f\"on {next['date'].strftime('%d %B %Y')}\"\n\nstr_out = f\"{next['title']} is {when}\"\n\nif needs_bunting:\n    str_out = str_out + \" ▼▽▼▽▼▽\"\n\nprint(str_out)\n```\n:::\n\n\n</details>\n\nNext, more important goal: write something similar to help me know what bin day it is (we alternate fortnightly between refuse and recycling). I saved a neighbour from getting erroneously binfluenced recently, so this is dear to my heart.\n\n### Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[project]\nname = \"2025-08-11-uv-standalone\"\nversion = \"0.1.0\"\ndescription = \"rostrum.blog post: uv-standalone\"\nrequires-python = \">=3.12\"\ndependencies = [\n    \"datetime>=5.5\",\n    \"httpx>=0.28.1\",\n]\n```\n:::\n:::\n\n</details>\n\n[^inscript]: _The call was coming from inside the script._\n[^critique]: Please feel free to critique my Python code. How could it possibly be worse than my R code?\n[^r]: As a more frequent R user: _0 days since last zero-indexing mistake._\n[^typo]: Likely more, given [my terrible typo history](https://www.rostrum.blog/posts/2021-02-27-typos/index.html).\n[^shebang]: Basically says 'if I'm called, execute me like a little standalone program'.\n[^uv]: Perhaps you have been living under a rock where uv rays have not struck you. uv is all the rage for doing all-the-Python-setup-things-that-make-Python-setup-a-headache. And it's super fast. Because Rust. Because carcinisation is coming for all of us.\n[^gist]: I'm losing my mind becuase I've discovered recently that the pronunciation of 'gist' is another 'how do you pronounce gif?' situation. To be clear, it should be pronounced 'gist'.\n[^streak]: And thus my 182-post streak without running Python comes to an end.\n[^credit]: I found this [thanks to Rodrigo](https://mathspp.com/blog/til/standalone-executable-python-scripts-with-uv), who spotted it via [Simon](https://simonwillison.net/2024/Aug/21/usrbinenv-uv-run/), who spotted it [via David](https://github.com/alsuren/sixdofone/pull/8). And now I'm ripping it off.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "c906f81f3b79b2a553bb84b27b83c3fb",
  "result": {
    "markdown": "---\ntitle: \"A bank holiday to honour uv?\"\ndate: 2025-08-11\nslug: \"uv-standalone\"\nimage: resources/bank.png\ncategories:\n  - api\n  - python\n  - uv\n---\n\n\n![](resources/bank.png){fig-align=\"left\" fig-alt=\"The command bank.py is run in a macOS terminal Window, yielding the phrase 'Summer bank holiday is on 25 August 2025', with a series of triangle symbols alternating with a black-and-white fill to look like bunting.\" width='100%'}\n\n## tl;dr\n\nYou can use [uv](https://docs.astral.sh/uv/) to help turn a Python script into a self-contained executable. Useful for really important stuff, like... discovering the next public holiday from your terminal?\n\nThis is my own attempt at something [I saw Rodrigo do](https://mathspp.com/blog/til/standalone-executable-python-scripts-with-uv).\n\n## Worth a bunt\n\nThe UK government maintains [an API catalogue](https://www.api.gov.uk/#uk-public-sector-apis). A very (very) simple API example is [the bank-holidays API](https://www.api.gov.uk/gds/bank-holidays/#bank-holidays) run by the Government Digital Service (GDS). It's perhaps most well-known for [the associated page on the GOV.UK website](https://www.gov.uk/bank-holidays). \n\nAll the API does is serve a JSON file with upcoming public holidays. I wrote a ramshackle little Python script that grabs the file, works out what the next holiday is, and prints it out.\n\nCrucially, it also prints [bunting](https://en.wikipedia.org/wiki/Bunting_(decoration)) if, according to the JSON, the occasion calls for it.\n\n## Banking crisis\n\nSo, here's the quite-ordinary code for this demonstration[^critique]:\n\n\n::: {.cell filename='bank.py'}\n\n```{.python .cell-code}\nimport httpx\nfrom datetime import date\n\n# Fetch bank holidays\n\nresp = httpx.get(\"https://www.gov.uk/bank-holidays.json\")\nevents = resp.json()[\"england-and-wales\"][\"events\"]\n\nfor event in events:\n    event[\"date\"] = date.fromisoformat(event[\"date\"])\n\n# Find next holiday\ntoday = date.today()\nfuture = [event for event in events if event[\"date\"] >= today]\nnext = future[0]\n\n# Print message\n\nis_today = next[\"date\"] == today\nneeds_bunting = next[\"bunting\"]\n\nif is_today:\n    when = \"today!\"\nelse: \n    when = f\"on {next['date'].strftime('%d %B %Y')}\"\n\nstr_out = f\"{next['title']} is {when}\"\n\nif needs_bunting:\n    str_out = str_out + \" ▼▽▼▽▼▽\"\n\nprint(str_out)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSummer bank holiday is on 25 August 2025 ▼▽▼▽▼▽\n```\n:::\n:::\n\n\nVery simple. Does the job[^r]. But if we want to use the script, maybe we'll have to clone a repo containing the script, change directory, activate the virtual environment and only then run the script. Every time we want to use it.\n\nWouldn't it be better if you could 'install' it and use it from the command line when you need it? Like just type `bank.py` to get a response? A really fast response?\n\n## uv protection\n\nThis is where the life-changing magic of [uv](https://docs.astral.sh/uv/) comes in[^uv]. \n\nYou can start by adding a block at the top of your file to declare dependencies. No need to worry about a separate dependecies file, lockfile or virtual environment. You can use `uv add` with the `--script` option in the form:\n\n\n::: {.cell}\n\n```{.sh .cell-code}\nuv add httpx datetime --script bank.py\n```\n:::\n\n\nWhich will add the following section at the top of our `bank.py` script:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# /// script\n# requires-python = \">=3.12\"\n# dependencies = [\n#     \"datetime\",\n#     \"httpx\",\n# ]\n# ///\n```\n:::\n\n\nAnd there you have it: all the information needed to run this file in a standalone manner. Like putting your `pyproject.toml` inside your script[^inscript]. So you'll be able to run `uv run bank.py` without any additional files required.\n\nBut wait! There's more. How boring, how _painful_ to have to write the `uv run` bit. That's _six_ characters[^typo].\n\nInstead, you can add a [shebang](https://en.wikipedia.org/wiki/Shebang_%28Unix%29)[^shebang] to the top of the file:\n\n::: {.cell}\n\n```{.python .cell-code}\n#!/usr/bin/env -S uv run\n```\n:::\n\n\nBut there's something different and interesting there... aha! uv again! The `-S uv run` bit is quite clever because it asks the interpreter to let good ol' uv do all the dependency and Python-version handling. Great! Especially given the raw speed of uv.\n\nFinally, you can make the file executable and add it to your path like:\n\n\n::: {.cell}\n\n```{.sh .cell-code}\nchmod +x bank.py\nmv bank.py ~/.local/bin\n```\n:::\n\n\nIn other words, change the mode (`chmod`) of the file by adding (`+`) executable (`x`) status. Then put the file where you terminal will look if you type the name of the file.\n\nThen you can merely call `bank.py` from the terminal to know when the next bank holiday is.\n\nI only found this [thanks to Rodrigo](https://mathspp.com/blog/til/standalone-executable-python-scripts-with-uv), who spotted it via [Simon](https://simonwillison.net/2024/Aug/21/usrbinenv-uv-run/), who spotted it [via David](https://github.com/alsuren/sixdofone/pull/8). And now I'm ripping it off.\n\n## The vital code snippet\n\nYou can find a [GitHub Gist of the code](https://gist.github.com/matt-dray/c97603f294fb80736b669141191d827b)[^gist] I put together, or:\n\n<details><summary>Click to see the complete `bank.py` script.</summary>\n\n\n::: {.cell filename='bank.py'}\n\n```{.python .cell-code}\n#!/usr/bin/env -S uv run\n\n# /// script\n# requires-python = \">=3.12\"\n# dependencies = [\n#     \"datetime\",\n#     \"httpx\",\n# ]\n# ///\n\nimport httpx\nfrom datetime import date\n\n# Fetch bank holidays\n\nresp = httpx.get(\"https://www.gov.uk/bank-holidays.json\")\nevents = resp.json()[\"england-and-wales\"][\"events\"]\n\nfor event in events:\n    event[\"date\"] = date.fromisoformat(event[\"date\"])\n\n# Find next holiday\ntoday = date.today()\nfuture = [event for event in events if event[\"date\"] >= today]\nnext = future[0]\n\n# Print message\n\nis_today = next[\"date\"] == today\nneeds_bunting = next[\"bunting\"]\n\nif is_today:\n    when = \"today!\"\nelse: \n    when = f\"on {next['date'].strftime('%d %B %Y')}\"\n\nstr_out = f\"{next['title']} is {when}\"\n\nif needs_bunting:\n    str_out = str_out + \" ▼▽▼▽▼▽\"\n\nprint(str_out)\n```\n:::\n\n\n</details>\n\nNext, more important goal: write something similar to help me know what bin day it is (we alternate fortnightly between refuse and recycling). I saved a neighbour from getting erroneously binfluenced recently, so this is dear to my heart.\n\n### Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[project]\nname = \"2025-08-11-uv-standalone\"\nversion = \"0.1.0\"\ndescription = \"rostrum.blog post: uv-standalone\"\nrequires-python = \">=3.12\"\ndependencies = [\n    \"datetime>=5.5\",\n    \"httpx>=0.28.1\",\n]\n```\n:::\n:::\n\n</details>\n\n[^inscript]: _The call was coming from inside the script._\n[^critique]: Please feel free to critique my Python code. How could it possibly be worse than my R code?\n[^r]: As a more frequent R user: _0 days since last zero-indexing mistake._\n[^typo]: Likely more, given [my terrible typo history](https://www.rostrum.blog/posts/2021-02-27-typos/index.html).\n[^shebang]: Basically says 'if I'm called, execute me like a little standalone program'.\n[^uv]: Perhaps you have been living under a rock where uv rays have not struck you. uv is all the rage for doing all-the-Python-setup-things-that-make-Python-setup-a-headache. And it's super fast. Because Rust. Because carcinisation is coming for all of us.\n[^gist]: I'm losing my mind becuase I've discovered recently that the pronunciation of 'gist' is another 'how do you pronounce gif?' situation. To be clear, it should be pronounced 'gist'.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
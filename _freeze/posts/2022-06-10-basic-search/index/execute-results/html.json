{
  "hash": "8160544650c253d520c1c94c35a04b66",
  "result": {
    "markdown": "---\ntitle: \"Automated pathfinding in {r.oguelike}\"\ndate: 2022-06-10\nslug: basic-search\ncategories:\n  - gamedev\n  - r\n  - r.oguelike\n  - videogames\n---\n\n\n\n\n![The enemy `E` chases the player `@` who collects gold `$` and and an apple `a`.](resources/chase.gif){fig-alt=\"Animation of an R console, showing a rectangular grid of tiles that represents a dungeon room. Floor tiles are periods. Surrounding walls are hashmarks. There's an enemy character represented by a letter 'E' and a player character represented by an 'at' symbol. There's some obstacle walls separating them. The enemy character moves tile by tile around the obstacle until towards the player who is running away.\" width=\"100%\"}\n\n## tl;dr\n\nI've experimented with simple [breadth-first search](https://en.wikipedia.org/wiki/Breadth-first_search) for [{r.oguelike}](https://github.com/matt-dray/r.oguelike), a work-in-progress  game-in-a-package for R. This means enemies can pathfind and chase down the player character.\n\n## Hunting the hunter\n\nI've [written before about the inception of {r.oguelike}](https://www.rostrum.blog/2022/04/25/r.oguelike-dev/), a concept for [a roguelike game](https://en.wikipedia.org/wiki/Roguelike) written in R, along with a simple method for creating [procedural tile-based cave-like dungeons](https://www.rostrum.blog/2022/05/01/dungeon/).\n\n![](resources/r.oguelike-hex.png){fig-alt=\"Hex sticker design for the 'r.oguelike' R package. Black background with bright green font, reminiscent of old computer terminal output. In the centre, a three-by-ten arrangement of hashmarks and periods, along with a single at symbol and dollar sign, which looks like a classic ACII tile-based roguelike game. The text 'r.oguelike' is underneath.\" width=\"25%\"}\n\nSo far the enemies in the game have been stationary.\n\nI could let them wander randomly on each turn, which is easy to implement, but boring and unrealistic. Far better would be to introduce some kind of pathfinding via an algorithm, which would make enemies head toward the player character to engage in battle.\n\nIn this post I'll start with a naive approach---simply labelling all tiles with distance from the target---then show how an approach called ['breadth-first search'](https://en.wikipedia.org/wiki/Breadth-first_search) can alleviate the problem.\n\n## Layers deep\n\nThere's a number of ways I could implement pathfinding in R. For purposes of this post, I'm using an approach that I think makes it easier to grasp conceptually.\n\nEach dungeon will be composed of two related matrices: one matrix is the tile map, which holds the tiles the user sees (i.e. `#` for walls, `.` for floor, `@` for the player character, `E` for enemy); the second matrix isn't seen by the user, but holds travel-distance scores used by the enemy character to find a path to the target.\n\nI'll use `m` throughout as the name of the matrix object holding the tile map and `d` as the name of the matrix object holding the distance map.\n\nBear in mind that the characters can only move one tile per turn in a north, south, east or west direction, which has implications for how we label tiles with their distances.\n\n## Don't keep it simple, stupid\n\nConsider this very basic dungeon room that hosts an enemy character `E` that is seeking the player character `@`. It's just an R matrix object, but we can print it nicely so it's easier to read.\n\n<details><summary>Click for R code</summary>\n\nManually create a basic, rectangular dungeon room:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create room\nn_rows <- 9\nn_cols <- 10\nm <- matrix(rep(\".\", n_rows * n_cols), n_rows, n_cols)\nm[1, ] <- \"#\"  # walls\nm[, 1] <- \"#\"\nm[nrow(m), ] <- \"#\"\nm[, ncol(m)] <- \"#\"\n\n# Add player and enemy\nm[7, 3] <- \"@\"  # player\nm[3, 3] <- \"E\"  # enemy\n```\n:::\n\n\nFor convenience, a function that pretty-prints the matrix to the console:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to print the map nicely\nprint_tiles <- function(x) {\n  for (i in seq(nrow(x))) {\n    cat(x[i, ], \"\\n\")\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint_tiles(m)\n```\n:::\n\n</details>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint_tiles(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# # # # # # # # # # \n# . . . . . . . . # \n# . E . . . . . . # \n# . . . . . . . . # \n# . . . . . . . . # \n# . . . . . . . . # \n# . @ . . . . . . # \n# . . . . . . . . # \n# # # # # # # # # # \n```\n:::\n:::\n\n\nWhat's the simplest way that the enemy can find a path to the player?\n\nProbably it's to label every traversable tile with [a Manhattan-distance](https://en.wikipedia.org/wiki/Taxicab_geometry) (i.e. like a taxicab would move on the gridded streets of New York) away from the player's position. Then the enemy can check its neighbouring tiles on each turn and select the next highest distance score until it reaches the player.\n\nSo, below I've created a distance map by assigning the player position a score of 100, then I've decreased the score by 1 with each additional tile away from the player (remembering that characters can only move north, south, east or west). Walls score zero, so they're effectively ignored.\n\n<details><summary>Click for R code</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\nget_distance <- function(m, peak_score) {\n\n  # Initiate distance matrix filled with zero\n  n_rows <- nrow(m)\n  n_cols <- ncol(m)\n  d <- matrix(rep(0, n_cols * n_rows), n_rows, n_cols)\n\n  # Player location gets peak_score\n  player_loc <- which(m == \"@\", arr.ind = TRUE)\n  m[player_loc[1], player_loc[2]] <- peak_score\n\n  # Surrounding tiles get successively smaller distance scores\n  for (col_ind in seq(n_cols)) {\n    for (row_ind in seq(n_rows)) {\n      distance <- abs(player_loc[1] - row_ind) + abs(player_loc[2] - col_ind)\n      value <- peak_score - distance\n      if (value < 0) value <- 0\n      d[row_ind, col_ind] <- value\n    }\n  }\n\n  # Walls aren't traversable, assign low value\n  walls <- which(m == \"#\")\n  d[walls] <- 0\n\n  d\n\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nget_distance(m, 100)\n```\n:::\n\n</details>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]    0    0    0    0    0    0    0    0    0     0\n [2,]    0   94   95   94   93   92   91   90   89     0\n [3,]    0   95   96   95   94   93   92   91   90     0\n [4,]    0   96   97   96   95   94   93   92   91     0\n [5,]    0   97   98   97   96   95   94   93   92     0\n [6,]    0   98   99   98   97   96   95   94   93     0\n [7,]    0   99  100   99   98   97   96   95   94     0\n [8,]    0   98   99   98   97   96   95   94   93     0\n [9,]    0    0    0    0    0    0    0    0    0     0\n```\n:::\n:::\n\n\nSee how the player-position at [7,3] is 100 and the values then drop by 1 in all directions?\n\nSo the enemy would move south from its start position at [3,3] to the target position at [7,3], moving along a score gradient of 96 to 100.\n\nThere's an issue with this though: obstacles. What do you think will happen if we put a dividing wall between the characters? Here's the same room with a wall splitting the characters, plus the distance matrix using the same approach as above.\n\n<details><summary>Click for R code</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\nm[5, 2:8] <- \"#\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint_tiles(m)\n```\n:::\n\n</details>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# # # # # # # # # # \n# . . . . . . . . # \n# . E . . . . . . # \n# . . . . . . . . # \n# # # # # # # # . # \n# . . . . . . . . # \n# . @ . . . . . . # \n# . . . . . . . . # \n# # # # # # # # # # \n```\n:::\n:::\n\n\n<details><summary>Click for R code</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- get_distance(m, 100)\n\nd\n```\n:::\n\n</details>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]    0    0    0    0    0    0    0    0    0     0\n [2,]    0   94   95   94   93   92   91   90   89     0\n [3,]    0   95   96   95   94   93   92   91   90     0\n [4,]    0   96   97   96   95   94   93   92   91     0\n [5,]    0    0    0    0    0    0    0    0   92     0\n [6,]    0   98   99   98   97   96   95   94   93     0\n [7,]    0   99  100   99   98   97   96   95   94     0\n [8,]    0   98   99   98   97   96   95   94   93     0\n [9,]    0    0    0    0    0    0    0    0    0     0\n```\n:::\n:::\n\n\nSo, as before, the enemy begins on a distance score of 96 at [3,3] and will move south to 97 on [4,3]. \n\nNow what? The wall has been scored as zero, so the enemy looks around for the largest distance score of its remaining neighbours. They all score 96, so the enemy character just selects randomly one of west, north or east.\n\nUhoh: this means the enemy will be stuck in an infinite loop between the adjacent scores of 96 and 97. This isn't very intelligent.\n\nHow can we account for blockages like this?\n\n## Here comes the flood-fill\n\nPerhaps a better approach is to 'flood fill' the distance scores. Imagine the start point is a source of water and it's filling up the dungeon. Obviously the water will have to flow around walls and the hardest-to-reach areas will be filled last.\n\nA basic flood-fill approach we can implement is ['breadth-first'](https://en.wikipedia.org/wiki/Breadth-first_search), which visits tiles in a 'frontier' expanding from the start point. Distance scores are assigned once to frontier tiles and neighbours are consecutively added to a 'queue' to be checked. \n\nThis is slightly expensive because every traversable tile has to be assessed, but it means that multiple enemies can all use the same distance map to navigate.[^complicated]\n\nWe don't need to get too complicated for {r.oguelike}; it just has to work. I'll illustrate the breadth-first approach with a pretty basic and verbose implementation.[^implementation]\n\n### Deep breadth-first\n\nNow to implement it in R. Reminder: we'll use two matrices to represent the tile grid (seen by player) and the distance grid (just holds the distance scores).\n\nI'm going to use three main functions:\n\n1. `initiate_distance_map()`, which creates a distance-map matrix of equal size to the tile map and fills all traversable spaces with zero and all non-traversable spaces with `Inf`inity (which the character will want to avoid)\n1. `populate_distance_map`, which flood-fills the traversable space by expanding a frontier from the start point, assigning a distance score to each neighbour that's +1 of the score of the parent tile and adding those neighbours to the frontier queue so they can be inspected next\n1. `move_enemy()` to move the enemy character one tile per turn towards the tile with the lowest distance score (i.e. the tile that holds the player `@`)\n\n#### Create the distance-score matrix\n\nUsing the same obstacle map from earlier in the post, we can first initiate a complementary distance-score matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninitiate_distance_map <- function(m) {\n\n  d <- m  # copy the tile map\n  d[which(d != \"#\")] <- 0  # set non-wall tiles to 0\n  d[which(d == \"#\")] <- Inf  # set wall tiles to infinity\n  matrix(as.numeric(d), nrow(d), ncol(d))  # recast as numeric\n\n}\n```\n:::\n\n\nNow we can adjust those distance scores. The algorithm is basically:\n\n1. Create a frontier vector of tile indices  (i.e. the edges of the flood-fill as it moves outward) and add the starting tile (i.e. the tile index that holds the player character)\n2. Create a vector to hold tile indices that we've already visited\n3. Begin a loop where:\n    - the first tile in the frontier queue becomes the 'current' tile\n    - the current tile is removed to the frontier\n    - the current tile is added to the visited list\n    - the tile indices of the current tile's neighbours (north, south, east and west) are identified\n    - if not yet visited, the neighbours are assigned distance scores that are +1 of the current tile\n4. Continue the loop until you run out of tiles in the frontier queue\n\nI've written a small sub-function to handle neighbour-finding:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_neighbours <- function(m, current) {\n\n  n_rows <- nrow(m)\n\n  c(\n    if (m[current - n_rows] != \"#\") current - n_rows,\n    if (m[current - 1] != \"#\") current - 1,\n    if (m[current + 1] != \"#\") current + 1,\n    if (m[current + n_rows] != \"#\") current + n_rows\n  )\n\n}\n```\n:::\n\n\nWhich plugs into the main function for implementing the algorithm that assigns distance scores:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulate_distance_map <- function(m, d) {\n\n  start <- which(m == \"@\")  # start tile, i.e. player tile\n  \n  # Initiate vectors\n  frontier <- start  # to be assessed\n  visited <- c()  # have been assessed\n\n  while (length(frontier) > 0) {\n\n    current  <- frontier[1]  # set first tile of frontier as current\n    frontier <- frontier[!frontier == current]  # remove current tile from frontier\n    visited  <- append(visited, current)  # mark current as visited\n\n    neighbours <- get_neighbours(m, current)  # get vector of neighbour indices\n    neighbours <- neighbours[!neighbours %in% visited]\n\n    for (neighbour in neighbours) {\n      if (!neighbour %in% visited) {  # only assign distance to unvisited neighbours\n        d[neighbour] <- d[current] + 1  # assign distance, one more than parent\n      }\n    }\n\n    frontier <- append(frontier, neighbours)  # add neighbour to the frontier\n\n  }\n\n  d\n\n}\n```\n:::\n\n\n#### Move to target\n\nFinally, here's the function that lets the enemy check its neighbours for the lowest distance score and move one tile in that direction:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmove_enemy <- function(m, d) {\n\n  # Find tiles of interest\n  en_loc <- which(m == \"E\")\n  player_loc <- which(m == \"@\")\n  n_rows <- nrow(m)\n\n  # Get neighbour tile indices\n  ind <- c(\n    n = en_loc - 1,\n    s = en_loc + 1,\n    e = en_loc + n_rows,\n    w = en_loc - n_rows\n  )\n\n  # Get tile content for neighbours\n  tiles <- c(\n    n = m[ind[\"n\"]],\n    s = m[ind[\"s\"]],\n    e = m[ind[\"e\"]],\n    w = m[ind[\"w\"]]\n  )\n\n  # Get the distance score for a tile if traversable/target\n  dist <- c(\n    n = if (tiles[\"n\"] %in% c(\".\", \"@\")) d[ind[\"n\"]],\n    s = if (tiles[\"s\"] %in% c(\".\", \"@\")) d[ind[\"s\"]],\n    e = if (tiles[\"e\"] %in% c(\".\", \"@\")) d[ind[\"e\"]],\n    w = if (tiles[\"w\"] %in% c(\".\", \"@\")) d[ind[\"w\"]]\n  )\n\n  # Sample a direction if there's ties, move there\n  direction <- sample(names(dist[dist == min(dist)]), 1)\n  en_loc_new <- ind[names(ind) == direction]\n  m[en_loc] <- \".\"  # replace old location with floor tile\n  m[en_loc_new] <- \"E\"  # place enemy in new location\n\n  m\n\n}\n```\n:::\n\n\n#### Put it all together\n\nNow to apply the functions to our dungeon room, with its minor obstacle. Here's a reminder of the layout:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint_tiles(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# # # # # # # # # # \n# . . . . . . . . # \n# . E . . . . . . # \n# . . . . . . . . # \n# # # # # # # # . # \n# . . . . . . . . # \n# . @ . . . . . . # \n# . . . . . . . . # \n# # # # # # # # # # \n```\n:::\n:::\n\n\nNow we can initiate the distance-score matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- initiate_distance_map(m)\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf   Inf\n [2,]  Inf    0    0    0    0    0    0    0    0   Inf\n [3,]  Inf    0    0    0    0    0    0    0    0   Inf\n [4,]  Inf    0    0    0    0    0    0    0    0   Inf\n [5,]  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf    0   Inf\n [6,]  Inf    0    0    0    0    0    0    0    0   Inf\n [7,]  Inf    0    0    0    0    0    0    0    0   Inf\n [8,]  Inf    0    0    0    0    0    0    0    0   Inf\n [9,]  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf   Inf\n```\n:::\n:::\n\n\nThen populate the distance scores from the target:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- populate_distance_map(m, d)\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf   Inf\n [2,]  Inf   18   17   16   15   14   13   12   11   Inf\n [3,]  Inf   17   16   15   14   13   12   11   10   Inf\n [4,]  Inf   16   15   14   13   12   11   10    9   Inf\n [5,]  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf    8   Inf\n [6,]  Inf    2    1    2    3    4    5    6    7   Inf\n [7,]  Inf    1    0    1    2    3    4    5    6   Inf\n [8,]  Inf    2    1    2    3    4    5    6    7   Inf\n [9,]  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf   Inf\n```\n:::\n:::\n\n\nSuccess. You can see the start tile at [7,3] scores zero and emanates out to the right, around the obstacle, before wrapping back to the top-left and toward the enemy at position [3,3]. \n\nThe enemy needs only to move to the neighbouring tile with the lowest distance score. So from 16 to 15 on either [4,3] or [3,4], then to 14, to 13, etc. \n\nSee how this time the character won't get stuck trying to move south? The distance scores decrease from left to right before curving round the wall in the direction of the player's tile. \n\nFor fun, we can print to the console an animation of the movement, which I've captured in gif form.\n\n<details><summary>Click for R code</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\nrepeat {\n  cat(\"\\014\")  # clear console\n  m <- move_enemy(m, d)  # move enemy\n  print_tiles(m)  # print to console\n  Sys.sleep(0.5)  # wait\n  if (!any(m == \"@\")) break  # stop if player captured\n}\n```\n:::\n\n</details>\n\n![](resources/pathfind.gif){fig-alt=\"Animation of an R console, showing a rectangular grid of tiles that represents a dungeon room. Floor tiles are periods. Surrounding walls are hashmarks. There's an enemy character represented by a letter 'E' in the upper left, and a player character represented by an 'at' symbol in the lower left. There's an obstacle wall separating them. The enemy character moves tile by tile around the obstacle until it reaches the player.\" width=\"50%\"}\n\nYou can see the enemy go round the wall and reach the player using a pretty efficient path.\n\nAnd in a more dungeonlike room:\n\n![](resources/pathfind-dungeon.gif){fig-alt=\"Animation of an R console, showing a rectangular grid of tiles that represents a dungeon room. Floor tiles are periods. Surrounding walls are hashmarks. There's an enemy character represented by a letter 'E' in the lower left, and a player character represented by an 'at' symbol toward the right. There's some obstacle walls separating them. The enemy character moves tile by tile around the obstacle until it reaches the player.\" width=\"100%\"}\n\n## The end of the tunnel?\n\nI've smashed this together quickly with some completely un-optimised code. Once I've ironed out some kinks, it'll go into [the {r.oguelike} package](https://github.com/matt-dray/r.oguelike) proper.\n\nOf course, I'll need to consider:\n\n* a moving player-character, so the distances map will need to be updated every turn\n* limiting the range of the frontier to some specified distance away from the player, so that an enemy will only begin pathfinding when a player is closer and more 'detectable'[^detect]\n* a 'vision-cone' so the enemy only 'sees' the player if there's a clear set of floor tiles between them\n* allowing different enemy classes to move differently, e.g. attack immediately, randomly, or when the player is within a certain distance\n\nAs a basic preview, here's what it looks like when you throw the pathfinding into [a procedurally-generated dungeon from {r.oguelike}](https://www.rostrum.blog/2022/05/01/dungeon/):\n\n![](resources/chase.gif){fig-alt=\"Animation of an R console, showing a rectangular grid of tiles that represents a dungeon room. Floor tiles are periods. Surrounding walls are hashmarks. There's an enemy character represented by a letter 'E' and a player character represented by an 'at' symbol. There's some obstacle walls separating them. The enemy character moves tile by tile around the obstacle until towards the player who is running away.\" width=\"100%\"}\n\nThis gives a nice impression of the panic that might set in if you're down to 1 HP and a monster is chasing you into a dead-end. \n\nPanic: a quintessential roguelike 'feature'!\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-07-02 12:57:10 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2 compiler_4.3.1    fastmap_1.1.1     cli_3.6.1        \n [5] tools_4.3.1       htmltools_0.5.5   rstudioapi_0.14   yaml_2.3.7       \n [9] rmarkdown_2.22    knitr_1.43.1      jsonlite_1.8.5    xfun_0.39        \n[13] digest_0.6.31     rlang_1.1.1       evaluate_0.21    \n```\n:::\n:::\n\n</details>\n\n[^implementation]: Perhaps unsurprisingly, there's not much on the web about implementing these algorithms in R for purposes of tile-based game development, specifically. There are implementations of theses algorithms, however, like [Michael Chow's A-star on GitHub](https://github.com/machow/astar-r), which could be adapted.\n[^complicated]: Yes, there are cleverer ways to do this. More advanced techniques include [Dijkstra](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm), which allows for weighted edges (e.g. a 'cost' for travelling over terrain types), and [A-star](https://en.wikipedia.org/wiki/A*_search_algorithm), which uses a heuristic to improve the efficiency of finding the shortest path between two points. Learn more in sensational [introductions](https://www.redblobgames.com/pathfinding/a-star/introduction.html) and [implementations](https://www.redblobgames.com/pathfinding/a-star/implementation.html) on [Red Blob Games](https://www.redblobgames.com/) by [Amit Patel](https://twitter.com/redblobgames).\n[^detect]: This behaviour probably makes more in-game sense. Unless you imagine the enemy has really great senses of smell or hearing and can detect the player wherever they are. Or your player character has just rolled low dexterity and is clumsy and loud.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
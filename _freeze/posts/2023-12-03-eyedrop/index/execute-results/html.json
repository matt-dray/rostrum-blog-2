{
  "hash": "f0c70cf65c8e659d031676f513b33e58",
  "result": {
    "markdown": "---\ntitle: No tears over missed eyedrops\ndate: 2023-12-03\nslug: eyedrop\ncategories:\n  - eyedropper\n  - r\n---\n\n\n![Lotad: best Pok√©mon. No contest.](resources/eyedrop-lotad.gif){fig-alt=\"Screencast. An 'eyedrop' function in the R programming language is executed, with an image path as its only argument. An image of the Pokemon Lotad is plotted. Three points are clicked: a green, yellow and blue area. After each, the hex colour for that point is printed to the R console and a new plotting window opens that's filled with that colour.\"}\n\n## tl;dr\n\nUse the [{eyedroppeR} package by Dan Oehm](https://gradientdescending.com/select-colours-from-an-image-in-r-with-eyedropper/) if you want to sample a colour from an image using R. You don't need to use my hastily-created function.\n\n## Top of the drops\n\nA colleague on Slack asked about 'eyedropper' tools; where you can click a point on an image and have its colour returned. Very handy.\n\nI couldn't recall seeing an eyedrop tool built with R. How hard could it be to make one?\n\nI thought immediately of the `locator()` function from base R, which lets you click a plot and have its coordinates returned[^locator]. So I went ahead and made a little demo function.\n\nBut I figured someone must have done this before, so I [asked on Mastodon](https://fosstodon.org/@mattdray/111513532691302980). And lol, of course: [the {eyedroppeR} package by Dan Oehm](https://gradientdescending.com/select-colours-from-an-image-in-r-with-eyedropper/) already does this (and more).\n\n<div class=\"tip\"> \n`<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c13.3 0 24 10.7 24 24V264c0 13.3-10.7 24-24 24s-24-10.7-24-24V152c0-13.3 10.7-24 24-24zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z\"/></svg>`{=html} <b>Note</b>\n\nYou may also enjoy [Dan's {traceR} package](https://github.com/doehm/traceR), which lets you interactively click points in the plot window to trace around an image, then use the resulting dot-to-dot in a new plot.\n\n</div>\n\n## Eye, eye\n\nSo this is a good lesson about avoiding duplication and wasted effort. I'm glad I asked about it!\n\nBut I still had fun. For posterity, here's the sketch I came up with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\neyedrop <- function(file, swatch = TRUE) {\n  \n  # Check file exists\n  if (!file.exists(file)) stop(\"File doesn't exist.\")\n  \n  # Check file extension\n  file_ext <- tools::file_ext(file)\n  if (!file_ext %in% c(\"png\", \"jpeg\")) stop(\"File must be .png or .jpeg.\")\n  \n  # Read from path\n  if (file_ext == \"png\") img <- png::readPNG(file)\n  if (file_ext == \"jpeg\") img <- jpeg::readJPEG(file)\n  \n  # Plot the image\n  grDevices::dev.new()\n  grid::grid.raster(img)\n  main_dev <- grDevices::dev.cur()\n  \n  # Get the size of the plot window\n  grid_size <- setNames(dev.size(\"cm\"), c(\"x\", \"y\"))\n  \n  message(\"Select points on the image to identify colours. Press <Esc> to quit.\")\n  \n  # Keep allowing user to click points until they refuse\n  repeat {\n    \n    clicked_point <- grid::grid.locator(\"cm\")  # xy in cm\n    \n    if (is.null(clicked_point)) break  # exit if user is finished\n    \n    # Standardise xy as 0 to 1\n    grid_coords <- unlist(clicked_point)\n    grid_ratios <- grid_coords / grid_size\n    \n    # Find the 'pixel' coords given the image's resolution\n    grid_dim <- setNames(dim(img)[1:2], c(\"y\", \"x\"))[2:1]\n    pixels <- round(grid_dim * grid_ratios)\n    pixels[\"y\"] <- grid_dim[\"y\"] - pixels[\"y\"]\n    \n    # Extract RGB for given pixel, convert to hex\n    rgb_vals <- img[pixels[\"y\"], pixels[\"x\"], ]\n    hex <- rgb(rgb_vals[1], rgb_vals[2], rgb_vals[3])\n    \n    # Open a window filled with the provided hex colour\n    if (swatch) {\n      dev.new(width = 2, height = 2)\n      par(mar = c(rep(0, 4)))  # remove plot margins\n      image(matrix(1), col = hex)\n      grDevices::dev.set(main_dev)  # return focus to original plot window\n    }\n    \n    message(hex)\n    \n  }\n  \n}\n```\n:::\n\n\nYou can see an example of this in action in the gif at the top of this page.\n\nOf course, this is a minimum viable product and has many deficiencies; it is not optimised in any way. I may even have misunderstood some concepts from {grid} graphics. \n\nAlso, importantly, there is some kind of [issue with RStudio](https://github.com/rstudio/rstudio/issues/8559) where grid units are converted incorrectly. Hence why the example shown at the top of this post uses R's vanilla graphical use interface. Given that <large percentage> of people are using RStudio, that isn't ideal.\n\nTo explain the basic steps of the function:\n\n1. We get the plot window dimensions with `dev.size()` and coordinates for our clicked point with `grid.locator()`. We can use that to work out how far along each axis that our point is, as a percentage.\n2. We can then check the `dim()`ensions of the image (i.e. its resolution) and locate the 'pixel' that is x% and y% along each axis.\n3. The image is an array object with red, green and blue 'channels', so we can retrieve each one for our pixel and convert to a hex value.\n\nOf course, I welcome your thoughts on how to improve the function. But yeah, y'know, just use {eyedroppeR}.\n\n## Dry your eyes, mate\n\nI'm a big believer in sharing failure. I'm a big believer in recognising when to stop[^dupe]. Regardless of 'success', I'm also a big believer in sharing your ideas and documenting your thought processes.\n\nI'm also a big believer in having a nice time and coding for fun.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2024-01-13 10:03:39 GMT\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2 compiler_4.3.1    fastmap_1.1.1     cli_3.6.2        \n [5] tools_4.3.1       htmltools_0.5.6.1 rstudioapi_0.15.0 yaml_2.3.8       \n [9] rmarkdown_2.25    knitr_1.45        jsonlite_1.8.7    xfun_0.41        \n[13] digest_0.6.33     rlang_1.1.3       fontawesome_0.5.2 evaluate_0.23    \n```\n:::\n:::\n\n</details>\n\n[^locator]: I used `locator()` for [the {pixeltrix} 'pixel-art editor' package](https://github.com/matt-dray/pixeltrix) and in a previous post about [getting coordinates from fictitious maps](https://www.rostrum.blog/posts/2021-11-04-kanto-locator/).\n[^dupe]: I've definitely created things in the past that I didn't realise already existed, such as [my {badgr} package](https://github.com/matt-dray/badgr/) and the pre-existing [{badger} package](https://github.com/GuangchuangYu/badger).",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
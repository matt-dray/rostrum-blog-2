{
  "hash": "15279f8d7e6f5448a5fe5909661131f1",
  "result": {
    "markdown": "---\ntitle: \"Little pixel fun zone\"\ndate: 2024-09-15\nslug: \"shiny-pixel\"\nimage: resources/SANIC.png\ncategories:\n  - pixeltrix\n  - r\n  - shiny\n---\n\n\n![Fast blue hedgehog man in Little Pixel Fun Zone, Act 1 (original art by the author).](resources/SANIC.png){fig-align=\"left\" fig.alt=\"Screenshot of a web app called 'little pixel fun zone'. in the centre is a child's drawing of the fast blue hedgehog rendered in blocky square pixels. Under the image are some buttons to select a colour, undo, fill and downloade outputs.\" width='50%'}\n\n## tl;dr\n\nI made a [simple toy pixel-editor for the browser](https://matt-dray.github.io/little-pixel-fun-zone/), which helped me learn about reacting to user clicks and implementing undo/redo in {shiny}.\n\n## Just browsing\n\n[The {pixeltrix} package](https://github.com/matt-dray/pixeltrix) is a local pixel editor you can run from the R console[^readmore]. It's intentionally simple. You start a graphics device and click the squares ('pixels'), cycling through your provided colour palette. You're returned a little pixeltrix-class matrix as a memento, which you can re-edit later.\n\nIt might be nice to have a browser-based version, but I've never really had the time and figured it would be too fiddly. Well guess what, I had some time and it wasn't that fiddly.\n\nI've been learning a bit more [{shiny}](https://shiny.posit.co/) of late. This mini project was a good way to learn a few things that might come in handy later. In particular, how to:\n\n1. Read a clicked point on a plot and react to it.\n2. Implement a basic undo/redo feature.\n\nThis is a reminder to myself of how to do these things.\n\n## App\n\nThe app is available [via {shinylive} deployed via GitHub Pages](https://matt-dray.github.io/little-pixel-fun-zone/) and [the source is on GitHub](https://github.com/matt-dray/little-pixel-fun-zone) (v0.3.0 at time of writing).\n\nThere's (intentionally) only a few features. You can:\n\n* click a pixel to toggle it on/off\n* change the colour, thanks to [Dean Attali's {colourpicker}](https://daattali.com/shiny/colourInput/)\n* undo/redo (with a very short 'memory')\n* flood fill\n* have an assistant ✨AI ✨draw a picture for you[^bot]\n* download a matrix representation of your treasured art (pixeltrix-class, for my own needs) as an RDS file\n* download a png copy of your treasured art\n\nWow!\n\nHere's an embedded version of the app:\n\n<iframe width='800' height='550' src='https://matt-dray.github.io/little-pixel-fun-zone/' title='roguelike-sprite-builder'></iframe>\n\n<div class=\"tip\"> \n`<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c13.3 0 24 10.7 24 24V264c0 13.3-10.7 24-24 24s-24-10.7-24-24V152c0-13.3 10.7-24 24-24zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z\"/></svg>`{=html} <b>Note</b>\n\nTo test the limits of {shinylive} deployments, I also managed to [deploy the app to itch.io](https://mattdray.itch.io/little-pixel-fun-zone), the indie-game dispensation platform! You can read [a separate blog post](https://www.rostrum.blog/posts/2024-11-16-itch/) about that.\n\n</div>\n\n## Tricks\n\nI mentioned there were two things I learnt in particular: handling click-reacts and undo/redo.\n\n### Click-react\n\nThanks to the `locator()` function (witchcraft), {pixeltrix} reads the coordinates of a user's click on the plotting device. The returned values can be used to identify the nearest 'pixel' clicked.\n\nWith {shiny} we can generate a plot output and then capture an input from it when clicked[^clicks] using the handy `click` argument to `plotOutput()`.\n\nIn the example but of UI code below, we output a plot with ID `pixel_grid` that was generated in the server. Then, a `click` on that plot in the app would be registered as the ID `clicked_point` for retrieval in the server. In my case, I took the x and y elements of that object and matched them to the nearest pixel (using self-plagiarised {pixeltrix} code). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nshiny::plotOutput(\n  outputId = \"pixel_grid\",  # the plot of the pixel grid\n  click = shiny::clickOpts(\n    id = \"clicked_point\",  # to retrieve as input$clicked_point in server\n    clip = TRUE  # restrict to plot bounds?\n  )\n)\n```\n:::\n\n\nI also made the click trigger `observeEvent()` to refresh the plot given the user's selection. So, the user clicks the plot and the nearest pixel is toggled.\n\n### Undo/redo\n\nIf you misclick a pixel in your picture you could correct it by changing the colour in the colourpicker and re-clicking the errant point. But that takes, ooh, perhaps a couple of seconds. Instead, it seems conceptually more fun to have an undo button. And imagine how exhilarating it would be if that button toggled to redo after it was clicked? I know, calm down.\n\nSo, there's probably lots of ways to do this, but I settled on bookeeping with 'memory slots' in a sort-of cyber-goldfish brain, using `reactiveValues()`. \n\nThe image is stored as a matrix object, with each cell representing the current state of the corresponding pixel when drawn. The current state of the matrix is stored in the first (of two) memory slots, while the second slot is the previous matrix state. Each time you update the drawing, slot 1 overwrites slot 2 and the new matrix takes its place in slot 1.\n\nSo, for example, the app starts up with a 'blank' grid:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npixel_matrices <- shiny::reactiveValues(slot1 = .gen_grid(16, \"#E5E5E5\"))\n```\n:::\n\n\nAnd then `observeEvent()` handles things when a click occurs. The click coordinates and currently-selected colour are used to toggle or adjust a pixel in the underlying matrix. The resulting, new, version of the matrix is added to slot 1 and the prior version slips into slot 2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshiny::observeEvent(input$clicked_point, {  # trigger on click\n  \n  matrix_updated <- .gen_updated_pixel_matrix(  # update current drawing\n    shiny::isolate(pixel_matrices[[\"slot1\"]]),  # the current drawing\n    pixel_coords(),  # location of clicked point to update\n    input$selected_colour  # current user-selected colour\n  )\n  \n  pixel_matrices[[\"slot2\"]] <- pixel_matrices[[\"slot1\"]]  # current is now old\n  pixel_matrices[[\"slot1\"]] <- matrix_updated  # new is now current\n  \n})\n```\n:::\n\n\nCould the so-called cyber-goldfish brain be larger, with more brain slots? No, because then it would be a cyber-elephant and I think that mental image is less funny. But yes, you could probably create slots on the fly and have the ability to undo much further back in history.\n\nSo, to perform a do-over, we just need to access the older slot with a button click. The icon for the button is stored in a `reactiveVal()` that starts as 'undo' arrow. When clicked, we flip the memory slots to put the older version in slot 1 and also update the icon to be a 'redo' arrow. Another click of the button and the situation will revert again[^redo]. Voila: time travel.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbutton_icon <- shiny::reactiveVal(\"rotate-left\")  # starting condition\n\nshiny::observeEvent(input$button_undo, {  # trigger on click\n    \n    # Switch 'memory' slots\n    slot1 <- pixel_matrices[[\"slot1\"]]\n    slot2 <- pixel_matrices[[\"slot2\"]]\n    pixel_matrices[[\"slot2\"]] <- slot1\n    pixel_matrices[[\"slot1\"]] <- slot2\n    \n    # Invert undo/redo icon\n    \n    current_icon <- undo_button_icon()\n    if (current_icon == \"rotate-left\") undo_button_icon(\"rotate-right\")\n    if (current_icon == \"rotate-right\") undo_button_icon(\"rotate-left\")\n    \n    shiny::updateActionButton(\n      inputId = \"button_undo\",\n      icon = shiny::icon(button_icon())\n    )\n    \n  })\n```\n:::\n\n\nInelegant, perhaps, but manageable[^primer].\n\n## Fiddly is money\n\nThere's a number of features I could implement, like arbitrary pixel-grid sizes, uploading a matrix to continue editing it, or maybe even multi-select with click-and-drag (is this even possible?).\n\nIf only I could perceive that I have more time and that the fiddlyometer gauge was lower. Yes, this is current me goading future me. \n\nUntil then, drop bug reports and how to fix them in [the issues](https://github.com/matt-dray/little-pixel-fun-zone/issues). \n\nAlso use the app to draw a classic videogame action scene and send it to me, obviously (see inspiration at top of post).\n\n### Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2025-01-14 23:35:08 GMT\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.4.2 (2024-10-31)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.4 compiler_4.4.2    fastmap_1.2.0     cli_3.6.3.9000   \n [5] tools_4.4.2       htmltools_0.5.8.1 rstudioapi_0.16.0 yaml_2.3.10      \n [9] rmarkdown_2.28    knitr_1.48        jsonlite_1.8.9    xfun_0.48        \n[13] digest_0.6.37     rlang_1.1.4       fontawesome_0.5.2 evaluate_1.0.1   \n```\n:::\n:::\n\n</details>\n\n[^bot]: This most often _looks_ like random noise, but I'm sure that's because of the training set or something. Maybe squint? I've been told that robot self-portraits sometimes appear, but I'm sure that's just a hallucination.\n[^readmore]: You can read about {pixeltrix} in [other posts](https://www.rostrum.blog/index.html#category=pixeltrix).\n[^redo]: If you undo and then make a new click, then the undo/redo button will continue to show the 'redo' icon. Subtle, but to avoid this, you must reset the `reactiveVal()` to show the 'undo' icon if you perform any other actions after undoing.\n[^primer]: If we messed with time travel and things didn't go a bit [_Primer_](https://en.wikipedia.org/wiki/Primer_(film)), then I'd say we've done well.\n[^clicks]: Note also that you can perform actions on `dblclick`, `hover` and `brush`, not just a single click.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
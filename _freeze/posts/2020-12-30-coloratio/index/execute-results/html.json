{
  "hash": "16f47fc211d849ebea6a3347b2198d6f",
  "result": {
    "markdown": "---\ntitle: Accessible colour contrasts with {coloratio}\ndate: 2020-12-30\nslug: coloratio\ntags:\n  - accessibility\n  - coloratio\n  - dataviz\n  - r\n  - savonliquide\n---\n\n\n![This blog's original theme: insufficient contrast!](resources/coloratio.png){fig-alt=\"The word 'coloratio' in green text on a black background and vice versa to its right.\" width=\"100%\"}\n\n## tl;dr\n\nI made [a small R package called {coloratio}](https://github.com/matt-dray/coloratio) to evaluate [colour-contrast ratios for accessibility](https://accessibility.blog.gov.uk/2016/06/17/colour-contrast-why-does-it-matter/). Then I found out that  [{savonliquide}](https://github.com/feddelegrand7/savonliquide) already exists to do this.\n\n## Accessible charts\n\nThe UK government's website, [GOV.UK](https://www.gov.uk/), was developed with user needs and accessibility in mind. I've been using {ggplot2} to recreate [the simple, accessible chart styles](https://www.gov.uk/government/publications/examples-of-visual-content-to-use-on-govuk/examples-of-visual-content-to-use-on-govuk) suggested for use on GOV.UK by [the Government Statistical Service](https://gss.civilservice.gov.uk/).\n\nBut I wondered: is it possible to programmatically select a high-contrast text colour to overlay the fill colours of a {ggplot2} barplot? You would want black text over white and vice versa, for example. \n\nWhat is 'high contrast' anyway? GOV.UK's [Design System](https://design-system.service.gov.uk/styles/colour/) refers to [W3C's contrast guidance from WCAG 2.1](https://www.w3.org/TR/WCAG21/#contrast-minimum), which suggests a ratio of 4.5:1 for regular text on a block-coloured background.\n\nIt isn't a big deal to program this 'manually', but that's not fun.\n\n## Ratio calculation\n\n### Is the contrast accessible?\n\nHow about a small package with some functions to derive colour contrast ratios? Introducing [{coloratio}](https://github.com/matt-dray/coloratio).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"remotes\")  # if not yet installed\nremotes::install_github(\"matt-dray/coloratio\")\n```\n:::\n\n\nPass two colours to `cr_get_ratio()` as hex values or named colours---see `colors()`---and it performs the necessary calculations to derive [relative luminance](https://www.w3.org/TR/WCAG/#dfn-relative-luminance) and return a [colour contrast ratio](https://www.w3.org/TR/WCAG/#dfn-contrast-ratio).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(coloratio)  # attach package\n\ncr_get_ratio(\n  \"papayawhip\", \"#000000\",  # colours to compare\n  view = TRUE  # optional demo of colours \n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/get-ratio-ex-1-1.png){width=480}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18.55942\n```\n:::\n:::\n\n\nThis contrast value is above the 4.5 threshold, so we're good to go. You'll get a warning if the contrast is insufficient.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncr_get_ratio(\"olivedrab\", \"olivedrab2\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in cr_get_ratio(\"olivedrab\", \"olivedrab2\"): Aim for a value of 4.5 or higher.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.755693\n```\n:::\n:::\n\n\nSurprise: as stunning as an all-olivedrab palette might be, these colours aren't distinct enough to be accessible.\n\n### Black or white?\n\n`cr_get_ratio()` in turn powers the function `cr_choose_bw()`, which returns black or white depending on the greatest contrast with a supplied background colour.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncr_choose_bw(\"snow\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"black\"\n```\n:::\n\n```{.r .cell-code}\ncr_choose_bw(\"saddlebrown\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"white\"\n```\n:::\n:::\n\n\nTo demonstrate better, let's create a grouped barplot with lighter (`lemonchiffon3`) and darker (`hotpink4`) fill colours, then use `cr_choose_bw()` to choose black or white for the overlaying text.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)  # for data manipulation\n\n# Example data\nd <- data.frame(\n  x_val = c(\"A\", \"A\", \"B\", \"B\"),\n  y_val = c(3, 6, 4, 10),\n  z_val = c(\"a\", \"b\", \"a\", \"b\")\n) %>% \n  mutate(  # add colour columns\n    fill_col = rep(c(\"hotpink4\", \"lemonchiffon3\"), 2),\n    text_col = map_chr(fill_col, cr_choose_bw)\n  )\n\nd  # preview\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x_val y_val z_val      fill_col text_col\n1     A     3     a      hotpink4    white\n2     A     6     b lemonchiffon3    black\n3     B     4     a      hotpink4    white\n4     B    10     b lemonchiffon3    black\n```\n:::\n:::\n\n\nNo surprise: white was returned for the darker fill and black for the lighter fill.\n\nWe can now refer to this information in the `colour` argument of `geom_text()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(d, aes(x_val, y_val, fill = z_val)) +\n  geom_bar(position = \"dodge\", stat = \"identity\") +\n  scale_fill_manual(values = d$fill_col) +    # fill colour\n  geom_text(aes(y = 0.5, label = y_val), \n            position = position_dodge(0.9), \n            size = 5, colour = d$text_col) +  # text colour \n  coord_flip() + \n  theme_minimal(base_size = 16) +  # clean up the theme\n  theme(axis.text.x = element_blank(), axis.title = element_blank(), \n        legend.title = element_blank(), panel.grid = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-geom-text-1.png){width=672}\n:::\n:::\n\n\nAs desired: black on the lighter fill; white on the darker fill. The default would be black text, which would provide insufficient contrast for darker fills.\n\n### Aside: `cr_choose_bw()` in `geom_text()`?\n\nOriginally I wanted `geom_text()` to choose text colours on the fly, rather than adding them to the input data. This roundabout solution---which outputs a similar plot to the one above---requires you to build the plot object, then interrogate it with `ggplot_build()` to identify the bar-fill colours.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Build simple grouped barplot again\np <- ggplot(d, aes(x_val, y_val, fill = z_val)) +\n  geom_bar(position = \"dodge\", stat = \"identity\") +\n  scale_fill_manual(values = c(\"hotpink4\", \"lemonchiffon3\")) +\n  coord_flip()\n\n# Extract the p-object fills and choose text overlay colour\np + geom_text(\n  aes(y = 0.5, label = y_val), position = position_dodge(0.9), size = 5,\n  colour = map_chr(  # make text colour dependent on bar colour\n    ggplot_build(p)[[1]][[1]]$fill,  # access p-object fills\n    coloratio::cr_choose_bw   # choose black/white text based on fill\n  )\n)\n```\n:::\n\n\nI put this to [the RStudio Community](https://community.rstudio.com/t/can-you-conditionally-choose-geom-text-colours-based-on-underlying-geom-bar-fills/91777) with no answer to date. Let me know if you have any ideas.\n\n## A soapy slip-up\n\nHaving addressed my need, I was suspicious. Surely this has been done in R before?\n\nWhoops. [{savonliquide}](https://github.com/feddelegrand7/savonliquide) by [Ihaddaden M. EL Fodil](https://twitter.com/moh_fodil) can query the [WebAIM contrast checker API](https://webaim.org/resources/contrastchecker/) to get the contrast ratio for two colours. And it's on CRAN. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"savonliquide\")\n```\n:::\n\n\nMaybe I missed it because of the name, which translates to 'liquid soap'?\n\nAnyway, like `coloratio::cr_get_ratio()`, you can pass two hex values or named colours to {savonliquide}'s `check_contrast()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsavonliquide::check_contrast(\"blanchedalmond\", \"bisque2\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n* The Contrast Ratio is 1.04\n\n* The result for the AA check is : FAIL\n\n* The result for the AALarge check is : FAIL\n\n* The result for the AAA check is : FAIL\n\n* The result for the AAALarge check is : FAIL\n```\n:::\n:::\n\n\nThe output is richer than `coloratio::cr_get_ratio()`. You can see here that the supplied colours fail [additional accessibility checks from WCAG 2.1](https://www.w3.org/TR/WCAG21/#contrast-minimum) that involve large text and more stringent contrast thresholds. \n\nHandily, there's also the `savonliquide::check_contrast_raw()` variant that returns a list with each result as an element.\n\n## Acceptance\n\nSo... should you wash your hands of {coloratio}?[^savon] Well, it fills the micro-niche of an R package that doesn't require an internet connection to fetch colour contrast ratios. But it's probably never going to go on CRAN, so you should use {savonliquide}.\n\nI certainly learnt a lesson about due diligence during package development. Especially because I also [discovered recently](https://twitter.com/mattdray/status/1343289157565689856?s=20) that I had also somehow managed to reinvent [the {badger} package](https://github.com/GuangchuangYu/badger) with [my own {badgr} package](https://www.rostrum.blog/2020/05/08/readme-badge/).[^badgr] Whoops again.\n\nAt worst, I got to learn more about accessibility, practice some package building, and solve my initial problem (kinda).\n\nI also got to admire the creativity of [the names in the named-colour set](https://cpb-us-e1.wpmucdn.com/sites.ucsc.edu/dist/d/276/files/2015/10/colorbynames.png). 'Papayawhip' sounds really appealing. Or perhaps painful. _Just like package development._[^deep]\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-07-18 17:58:44 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] lubridate_1.9.2      forcats_1.0.0        stringr_1.5.0       \n [4] dplyr_1.1.2          purrr_1.0.1          readr_2.1.4         \n [7] tidyr_1.3.0          tibble_3.2.1         ggplot2_3.4.2       \n[10] tidyverse_2.0.0      coloratio_0.0.0.9004\n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.3       jsonlite_1.8.7     crayon_1.5.2       compiler_4.3.1    \n [5] tidyselect_1.2.0   scales_1.2.1       yaml_2.3.7         fastmap_1.1.1     \n [9] R6_2.5.1           labeling_0.4.2     generics_0.1.3     curl_5.0.1        \n[13] knitr_1.43.1       htmlwidgets_1.6.2  munsell_0.5.0      pillar_1.9.0      \n[17] tzdb_0.4.0         rlang_1.1.1        utf8_1.2.3         savonliquide_0.2.0\n[21] stringi_1.7.12     xfun_0.39          timechange_0.2.0   cli_3.6.1         \n[25] withr_2.5.0        magrittr_2.0.3     digest_0.6.31      grid_4.3.1        \n[29] rstudioapi_0.15.0  hms_1.1.3          lifecycle_1.0.3    vctrs_0.6.3       \n[33] evaluate_0.21      glue_1.6.2         farver_2.1.1       fansi_1.0.4       \n[37] colorspace_2.1-0   httr_1.4.6         rmarkdown_2.23     tools_4.3.1       \n[41] pkgconfig_2.0.3    htmltools_0.5.5   \n```\n:::\n:::\n\n</details><p>\n\n[^savon]: I assure you this is an excellent _savon liquide_ pun.\n[^badgr]: {badger} has functions to generate a bunch of badges you're likely to want. {badgr} focuses only on custom badges and has some extra options relative to `badger::badge_custom()`, like the ability to add an icon. But wow, how did I miss this?\n[^deep]: #deep\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
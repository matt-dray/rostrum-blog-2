{
  "hash": "cda12b47c84efaeae279609dfc1b25cf",
  "result": {
    "markdown": "---\ntitle: Take a look at my garbage\ndate: 2023-09-09\nslug: offcuts\ncategories:\n  - r\n---\n\n\n## tl;dr\n\nThree little R things I never finished. Or are useless.\n\n## \n\nThis is a little curio shop of bits and bobs that I sketched out at some point, but never finished or never found a use for. Nothing here is going to change your life; I just wanted to set them free for purposes of spiritual atonement.\n\nFor fun toys and R noodlings you can always check out anything by Mike (coolbutuseless), or stuff like Tomaz's 'Little Useless-Useful' series. Far more fruitful.\n\nHaving said this, this may be the first in a series. I've got a lot of zombie code moping about.\n\n## 1. {plunderplot}\n\n`locator()` is [a funny base R function](https://rdrr.io/r/graphics/locator.html) that lets you click a point on a plot to retrieve its coordinates.\n\nI had a little `locator()` phase on this blog: I used it to make [the {pixeltrix} package](https://www.rostrum.blog/index.html#category=pixeltrix) for point-and-click editing of 'pixel art' and wrote a post about [extracting coordinates from fictitious maps](https://www.rostrum.blog/posts/2021-11-04-kanto-locator/).\n\n[The {plunderplot} package](https://github.com/matt-dray/plunderplot) was an extension of the 'data extraction' idea, really. Given a plotted image, you're asked to calibrate by clicking on the axis extents and providing their values, then to click points on the image and optionally name them, before you're finally returned a dataframe of the results.\n\nSo you're plundering coordindates from a plot, right? Hence the name. Consequently, the package README uses some piratespeak to explain how it works. I won't subject you to that here.\n\nYou provide the path to an image, which `plunder()` will plot and then ask you to click on. The image here is a simple treasure map with treasure markers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreasure <- plunderplot::plunder(\"resources/treasure.png\", labels = TRUE)\n```\n:::\n\n\n![](resources/treasure.png){fig-alt=\"Chart titled 'Treasure locations on Rectangle Island'. It's a plot with x limits of 0 to 100 and y limits of 0 to 50. There are concentric rectangles that look like an island in the sea. There are three red crosses on the island.\" width=\"100%\"}\n\nIn the console you'll be instructed to do certain things, one after the other. You calibrate the plot, select the points and optionally label them.\n\n```\nClick x axis min\nClick x axis max\nClick y axis min\nClick y axis max\nType value at x axis min: 0\nType value at x axis max: 100\nType value at y axis min: 0\nType value at y axis max: 50\nClick points on the chart, press ESC when finished\nType a label for point 1: west\nType a label for point 2: centre\nType a label for point 3: east\nDone\n```\n\nAnd so you get your coordinates back:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreasure\n```\n:::\n\n```\n         x        y labels\n1 35.97651 32.19178   west\n2 55.94714 23.15068 centre\n3 61.96769 26.16438   east\n```\n\nExcept, well, this has done before. I was aware of [the {juicr} package](https://github.com/mjlajeunesse/juicr), which contains an interactive GUI for extracting data out of plots in scientific PDFs and that sort of thing, but there's already CRAN packages with {plunderplot}'s functionality: [{digitize}](https://CRAN.R-project.org/package=digitize ) and [{metaDigitise}](https://cran.r-project.org/package=metaDigitise), which have been around for years.\n\nSo it's not more useful than other tools but I had fun coding it and I've used it myself for 'real' applications more than once.\n\n## 2. Perlin dungeon\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint_perlin_dungeon <- function(\n    m,  # matrix of perlin noise via ambient::noise_perlin()\n    invert = FALSE  # flips tile positions (use set.seed before generating noise)\n) {\n  \n  tile_wall = \"#\"\n  tile_floor = \" \"\n  \n  # Standardise noise values from 0 to 1\n  m_bin <- round((m - min(m)) / (max(m) - min(m)))\n  \n  # Lay floor and wall tiles, flip if invert = TRUE\n  if (!invert) {\n    m_tiled <- ifelse(m_bin == 1, tile_wall, tile_floor)\n  } else {\n    m_tiled <- ifelse(m_bin == 0, tile_wall, tile_floor)\n  }\n  \n  # Block off edges with wall tiles\n  m_tiled[, 1] <- tile_wall\n  m_tiled[, ncol(m_tiled)] <- tile_wall\n  m_tiled[1, ] <- tile_wall\n  m_tiled[nrow(m_tiled), ] <- tile_wall\n  \n  # Print to console, line-by-line\n  for (i in seq(nrow(m_tiled))) {\n    cat(m_tiled[i, ], \"\\n\")\n  }\n  \n}\n```\n:::\n\n\nThe `noise_perlin()` function in the ambient {ambient} package has lots of twiddly knobs for arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- ambient::noise_perlin(\n  dim = c(30, 42),\n  frequency = 0.2,\n  interpolator = \"linear\",\n  fractal = \"fbm\",\n  octaves = 2,\n  lacunarity = 3,\n  gain = 0.5,\n  pertubation = \"none\",\n  pertubation_amplitude = 1\n)\n```\n:::\n\n\nYou can pass the matrix output from `noise_perlin()` to the `print_perlin_dungeon()` to print the map to the console.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint_perlin_dungeon(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # \n#         # # # # #                     # # # # #     # # #             # # # #   # \n# # # # # #   #                         # # # # #         # #           # # #     # \n# # # #   #                             # # # # #         # #           # # #     # \n#     #   #               # #             # # # #           # #         # # #     # \n#                     # # # #             # # #               #         # # #     # \n#                     # # # # # #         # # # # #           # # # # # # # #     # \n#                     # # # # # #               #               # # # # # # #     # \n#                     # # # # # #         # # # #                   # # # # #     # \n#                 #     # # # #           # # # #         #         # #           # \n#           #     #                       # # #     #     #                       # \n#               # #                         # # # # #                   #   #   # # \n#           # # # #             #       # # # # # # # # #   # #                 # # \n#           # # # #             # # # # # #     # # # # #   # #                 # # \n#           # # # #                 # #         # # #         # #   #     #   # # # \n#           # # # #               # # #                   #   # # # #             # \n#   # # #   # # # #               # # #                       # # # #       # #   # \n#   # # # # # # # # #           # # #               #         # # # # # # # # #   # \n#   # # # # # # # # #           # # #               #         # # # # # # # # #   # \n# # # # # # # # # # #           # # # #                       # # # # # # # # #   # \n# # # #     # # #                 # # #                       # # # #   #     #   # \n#             # # #                   #                       # #                 # \n#   # # #                       # # # #                     # #                   # \n#   # # #               #         # #                       # #                   # \n# # # #               # # # #     # # #                       # #                 # \n# # # #               # # # #             #                   # # #               # \n# #                   # # # #   # #   #   #                     # #               # \n# # # # #           # # # # #   # # # #         # #           # # # #     # #     # \n# # # # #           # # # # #   # # # #       # # #             # # #     # #     # \n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # \n```\n:::\n:::\n\n\nThe code is [in a gist](https://gist.github.com/matt-dray/fd5bf4b6560638e154353e4ec5c8b98a). It might even have been in a tweet once.\n\n## 3. Droplet 'physics'\n\nI experimented with this in support of a different project that may never finish.\n\nIt's a cross between the physics of water flowing under gravity and a pathfinding system. Except that description is way too grandiose. You provide a 'map' as a matrix and a little droplet (`o`) passes from top to bottom 'under gravity', depending on hazards (`X`). This manifests as a little animation in your console.\n\n<!-- TODO: improve map -->\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblock <- \"#\"\nempty <- \" \"\ndrop  <- \"o\"\n\nm <- matrix(rep(empty, 30), 5, 6)\nm[4, c(2:4, 6)] <- block\nm[3, 2]         <- block\nm[5, 4:6]       <- block\nm[1, 4]         <- drop\n\nprint(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,] \" \"  \" \"  \" \"  \"o\"  \" \"  \" \" \n[2,] \" \"  \" \"  \" \"  \" \"  \" \"  \" \" \n[3,] \" \"  \"#\"  \" \"  \" \"  \" \"  \" \" \n[4,] \" \"  \"#\"  \"#\"  \"#\"  \" \"  \"#\" \n[5,] \" \"  \" \"  \" \"  \"#\"  \"#\"  \"#\" \n```\n:::\n:::\n\n\nYou can make this more or less complicated. You can even use {pixeltrix} to make a map by interactively clicking squares in a plot window to receive back a matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrepeat {\n  \n  cat(\"\\014\")\n  \n  for (row in seq(nrow(m))) {\n    cat(m[row, ], \"\\n\", sep = \"\")\n  }\n  \n  Sys.sleep(1)\n  \n  droplet_i      <- which(m == drop)\n  droplet_i_save <- droplet_i\n  below_i        <- droplet_i + 1\n  \n  if (m[below_i] == empty) {\n    m[droplet_i] <- empty\n    m[below_i]   <- drop\n  }\n  \n  if (m[below_i] == block) {\n    \n    left_i  <- droplet_i - nrow(m)\n    right_i <- droplet_i + nrow(m)\n    \n    is_left_open  <- FALSE\n    is_right_open <- FALSE\n    \n    if (m[left_i] == empty)  is_left_open  <- TRUE\n    if (m[right_i] == empty) is_right_open <- TRUE\n    \n    if (is_left_open & is_right_open) {\n      sampled_direction_i <- sample(c(left_i, right_i), 1)\n      m[droplet_i] <- empty\n      m[sampled_direction_i]   <- drop\n    }\n    \n    if (is_left_open & !is_right_open) {\n      m[droplet_i] <- empty\n      m[left_i]    <- drop\n    }\n    \n    if (!is_left_open & is_right_open) {\n      m[droplet_i] <- empty\n      m[right_i]   <- drop\n    }\n    \n  }\n\n  droplet_i <- which(m == drop)\n  if (droplet_i == droplet_i_save) break\n  \n}\n```\n:::\n\n\n<!-- TODO: insert gif -->\n\nSo it's a bit weird. The droplet will scooch left and right forever on a flat surface until there's a lower point for it to drop into. The animation stops once the droplet is trapped at the lowest point.\n\nI think I wanted to try introducing tiles with different properties (e.g. angled, like `\\` and `/`) and the ability to add more than one droplet at a time.\n\nThe code is [in a gist](https://gist.github.com/matt-dray/0f4fba9a7e57bdb093d0b9433a983c61).\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-09-07 22:18:43 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2 compiler_4.3.1    fastmap_1.1.1     ambient_1.0.2    \n [5] cli_3.6.1         tools_4.3.1       htmltools_0.5.5   rstudioapi_0.15.0\n [9] yaml_2.3.7        rmarkdown_2.23    knitr_1.43.1      jsonlite_1.8.7   \n[13] xfun_0.39         digest_0.6.33     rlang_1.1.1       evaluate_0.21    \n```\n:::\n:::\n\n</details>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
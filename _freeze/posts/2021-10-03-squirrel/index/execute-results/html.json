{
  "hash": "a8ac01a987dc6c8134c16296efd51331",
  "result": {
    "markdown": "---\ntitle: \"{ActionSquirrel}: a game in the R console\"\ndate: 2021-10-03\nslug: squirrel\ncategories:\n  - emoji\n  - gamedev\n  - r\n  - R6\n  - sonify\n  - videogames\nresources: \n  - resources/sfx.wav\n---\n\n\n\n\n![](resources/squirrel.gif){fig-alt=\"The ActionSquirrel package is loaded to the R console, which prints some information about commands that can be run. A new game is initiated with the 'new' method, revealing a 5 by 5 grid of emoji of a squirrel, owl and nut, else deciduous trees. The 'move' method is applied to move the squirrel to collect a nut and then get eaten by the owl.\" width=\"100%\"}\n\n## tl;dr\n\nI created [the {ActionSquirrel} package](https://github.com/matt-dray/ActionSquirrel). It contains an [{R6}-powered](https://r6.r-lib.org/index.html) playable game for the R console, which includes images (well, emoji) and sounds (thanks to the [{sonify}](https://CRAN.R-project.org/package=sonify) package).\n\n## GameRs\n\nI've written before about the idea of games that you can play in R. For example, I replicated a text-based version of [_Pokemon Blue_'s Safari Zone](https://www.rostrum.blog/2021/01/04/safar6/). This was made possible by using [the {R6} package by Winston Chang](https://r6.r-lib.org/index.html), which provides an implementation of [object-oriented programming](https://www.freecodecamp.org/news/object-oriented-programming-concepts-21bb035f7260/) (OOP) in R.\n\nAn R6 class has 'fields' (variables) and 'methods' (functions) that can adjust the field values. This means you can manipulate the state of the object over time. You can read more in [the {R6} documentation](https://r6.r-lib.org/index.html) or in [Hadley Wickham's _Advanced R_ book](https://adv-r.hadley.nz/r6.html#r6-classes).\n\nSo you could create a class with a field that provides the location of a character, then let the user apply a method to overwrite that location. If you print the 'before' and 'after' states, you'll get the impression of movement for the character.\n\n## Winter is coming\n\nWith this in mind, I made a game and put it in the {ActionSquirrel} package. It's pretty simple; consider it a concept. \n\nYou play as a squirrel in a woodland, hoarding nuts before winter sets in. You have to collect 8 nuts in 30 moves or you won't survive. To make matters worse, there's an owl on patrol that wants to eat you.\n\nThe package contains a single 'ActionSquirrel' class. It has fields for the location of game objects---emojis for a tree, a squirrel, an owl and a nut---on a grid.[^grid] It has a method to move the squirrel around the grid, which also executes code to assesses and change other field states. For example, it can check how many moves have happened, can adjust the owl's position and spawn a new nut after the last one was collected.\n\n## Demo\n\nYou can install from GitHub.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"remotes\")  # if not installed already\nremotes::install_github(\"matt-dray/ActionSquirrel\")\n```\n:::\n\n\nNote that I've developed and tested this only in RStudio v1.4.1717 with R v4.1.1 running on macOS Big Sur. I think emoji rendering, console-clearing and the sound effects may not work on all platforms and setups.\n\nBasic instructions are printed when the package is attached.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ActionSquirrel)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWelcome to {ActionSquirrel}!\n* New game: x <- ActionSquirrel$new()\n* Move:     e.g. x$move('up')\n* Info:     x$pause()\n```\n:::\n:::\n\n\n### Start\n\nInitiate an object with the ActionSquirrel class by assigning `ActionSquirrel$new()` to a name (I'll use `x` for demo purposes). This clears the console and generates a forest grid that contains the squirrel, a nut and an owl, along with tallies for moves and nuts collected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ActionSquirrel$new()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\f🌳 🌳 🌳 🌳 🌳 \n🌳 🌳 🌰 🌳 🌳 \n🌳 🌳 🌳 🐿 🌳 \n🌳 🦉 🌳 🌳 🌳 \n🌳 🌳 🌳 🌳 🌳 \nMoves: 0 \nNuts: 0\n```\n:::\n:::\n\n\nMethods are applied to your object with the dollar symbol accessor[^dollar] in the form `object$method()`. We can use the `pause()` method to get game instructions, for example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx$pause()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nP A U S E\n * Aim:       get eight nuts before winter (30 moves)\n * Move:      e.g. x$move('up')\n * Chain:     e.g. x$move('u')$move('r')\n * New game:  x <- ActionSquirrel$new()\n * Info:      x$pause()\n * Source:    github.com/matt-dray/ActionSquirrel\n```\n:::\n:::\n\n\n### State\n\nTo understand a little more the mechanics of R6-classes, you could take a peek at the current state of the fields and methods by printing your ActionSquirrel-class object.\n\nIt isn't necessary for gameplay purposes to see this information, but for learning purposes it provides a sort-of 'meta' view of the current game state. (It will also help you 'hack' the game, more on that later!)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<ActionSquirrel>\n  Public:\n    active: TRUE\n    clone: function (deep = FALSE) \n    initialize: function () \n    move: function (where = c(\"up\", \"down\", \"left\", \"right\")) \n    moves: 0\n    n_loc: 8\n    nuts: 0\n    o_loc: 17\n    overworld: 🌳 🌳 🌳 🌳 🌳 🌳 🌳 🌰 🌳 🌳 🌳 🌳 🌳 🐿 🌳 🌳 🦉 🌳 🌳 🌳 🌳 🌳 🌳 🌳 🌳\n    pause: function () \n    s_loc: 14\n```\n:::\n:::\n\n\nThe most relevant of these are the `moves` and `nuts` counts; the `*_loc` values that specify the location of the `s`quirrel, `o`wl and `n`ut in the `overworld` vector;  and the `move()` method for controlling the player.\n\n### Move\n\nYou move the squirrel through the forest with the `move()` method. It has one argument, `where`, that takes the directions `\"up\"`, `\"down\"`, `\"left\"` and `\"right\"` (you can also just supply the first letter of the direction). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx$move(\"up\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\f🌳 🌳 🌳 🌳 🌳 \n🌳 🌳 🌰 🐿️ 🌳 \n🌳 🦉 🌳 🌳 🌳 \n🌳 🌳 🌳 🌳 🌳 \n🌳 🌳 🌳 🌳 🌳 \nMoves: 1 \nNuts: 0\n```\n:::\n:::\n\n\nCongratulations: your move tally has increased by one. You may also have noticed that the owl moved up one space as well; it moves one space vertically or horizontally, or stays still, with equal probability.\n\nI built in collision detection, so you can't exceed the limits of the grid by trying to go left if you're already on the leftmost edge, for example.\n\nNote that you can also take more than one move at a time (elite gamer tech) by 'chaining' methods, like `x$move(\"up\")$move(\"left\")`, but this is risky because you might collide with the owl.\n\nImportantly, the whole R console is cleared before the updated grid is printed. This gives an impression of animated graphics, since the console overwrites the previous state with the current state.\n\nNow to collect the nut.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx$move(\"left\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\f🌳 🌳 🌳 🌳 🌳 \n🌳 🌳 🐿️ 🌳 🌳 \n🌳 🦉 🌳 🌳 🌳 \n🌰 🌳 🌳 🌳 🌳 \n🌳 🌳 🌳 🌳 🌳 \nMoves: 2 \nNuts: 1\n```\n:::\n:::\n\n\nCongratulations, your nut tally has increased by one and a new nut has spawned in a random location. Collect at least eight nuts, or you won't survive winter.\n\n### Owl\n\nYou'll get a game over if the owl eats you (i.e. you occupy the same spot). So if you move left and the owl happens to move up...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx$move(\"left\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\f🌳 🌳 🌳 🌳 🌳 \n🌳 💀 🌳 🌳 🌳 \n🌳 🌳 🌳 🌳 🌳 \n🌰 🌳 🌳 🌳 🌳 \n🌳 🌳 🌳 🌳 🌳 \nMoves: 3 \nNuts: 1\nY O U   D I E D ! \nThe owl ate you.\nG A M E   O V E R \n* New game: x <- ActionSquirrel$new() \n* Source:   github.com/matt-dray/ActionSquirrel\n```\n:::\n:::\n\n\nThe location of your death is marked with a skull and you'll get a game over with information about what happened. At this point, the `active` field of the class is set to `FALSE`, which prevents you from moving again.\n\n![Definitely it's harder than Dark Souls.](resources/youdied.png){fig-alt=\"A screenshot of the 'you died' game over screen from the Souls series of games, but with an owl emoji to the right of the text.\" width=\"100%\"}\n\n### Winter\n\nAfter 30 turns the game will end because you've reached winter. You'll get a victory screen if you collected 8 nuts, otherwise a failure screen.\n\nAside: {R6} allows for 'public' and 'private' fields and methods. I've used public methods for the ActionSquirrel class, so that users can see the contents and state of the class and manipulate them. I think this is good for learning purposes.\n\nIt also means that we can 'hack' the game to the end state by overwriting the number of nuts and moves remaining! First, a victory after having collected eight nuts or more:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ActionSquirrel$new()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\f🌳 🌳 🌳 🌳 🌳 \n🌳 🌳 🌰 🌳 🌳 \n🌳 🌳 🌳 🐿 🌳 \n🌳 🦉 🌳 🌳 🌳 \n🌳 🌳 🌳 🌳 🌳 \nMoves: 0 \nNuts: 0\n```\n:::\n\n```{.r .cell-code}\nx$moves <- 29\nx$nuts <- 10\nx$move()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\f🐿️ 💤 🌰 🌰 🌰 \n🌰 🌰 🌰 🌰 🌰 \n🌰 🌰 🎄 ⛄ 🎄 \n🌨 ⛄ 🎄 ⛄ 🎄 \n⛄ ⛄ 🌨 🎄 🌨 \nMoves: 30 \nNuts: 10\nY O U   S U R V I V E D ! \nSufficient winter nut cache!\nG A M E   O V E R \n* New game: x <- ActionSquirrel$new() \n* Source:   github.com/matt-dray/ActionSquirrel\n```\n:::\n:::\n\n\nOur little squirrel friend is hibernating with the nut cache nearby. Meanwhile, the signs of winter fill the rest of the grid. Your success is confirmed in a printed statement.\n\nAnd what if we end the game with an insufficient nut cache?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ActionSquirrel$new()  # start new game\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\f🌳 🌳 🌳 🌳 🌳 \n🌳 🌳 🌰 🌳 🌳 \n🌳 🌳 🌳 🐿 🌳 \n🌳 🦉 🌳 🌳 🌳 \n🌳 🌳 🌳 🌳 🌳 \nMoves: 0 \nNuts: 0\n```\n:::\n\n```{.r .cell-code}\nx$moves <- 29\nx$nuts <- 4\nx$move()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\f🐿️ 💀 🌰 🌰 🌰 \n🌰 ❌ ❌ ❌ ❌ \n🎄 🎄 🌨 🎄 ⛄ \n🎄 ⛄ 🎄 ⛄ 🎄 \n⛄ 🎄 🌨 ⛄ ⛄ \nMoves: 30 \nNuts: 4\nY O U   D I E D ! \nInsufficient winter nut cache!\nG A M E   O V E R \n* New game: x <- ActionSquirrel$new() \n* Source:   github.com/matt-dray/ActionSquirrel\n```\n:::\n:::\n\n\nOh dear.\n\n### SFX\n\nSo we've got a player character, an enemy, collectibles, a goal and 'animated' visuals. The only thing missing is audio.\n\nLuckily, you can force your computer to make noise with [the {sonify} package](https://CRAN.R-project.org/package=sonify). I've used it before in this blog [to represent COVID-19 data in audio form](https://www.rostrum.blog/2021/02/02/sonify-covid/). For {ActionSquirrel}, I used it to make short, simple beeps to indicate a move, nut capture, collision with the edge of the grid, a win and a death. Here's what those sound like, respectively:\n\n<html><audio controls><source src=\"resources/sfx.wav\" type=\"audio/wav\"></audio></html>\n\nThe death sound is a flatline, because of course it is.\n\n## R6, 7, 8\n\nSo, give it a go. What's your high score? How guilty did you feel when the squirrel died?\n\nThere's lots of ways this could be improved. Maybe the owl could have 'AI' that encourages it to move towards the player or nut. Maybe there could be another enemy with different movement patterns. I welcome any bug reports or suggestions in [the GitHub repo for {ActionSquirrel}](https://github.com/matt-dray/ActionSquirrel/issues), or maybe you can fork it and make it better.\n\nThis post completes my R6 OOP hattrick alongside posts on [Animal Crossing](https://www.rostrum.blog/2020/04/04/repaying-tom-nook-with-r6/) and [Pokémon](https://www.rostrum.blog/2021/01/04/safar6/). Next time I might move onto {R7}, a new package for OOP in R [that's being coordinated and developed in the open by the R Consortium](https://github.com/RConsortium/OOP-WG/).\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-08-11 23:43:35 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] ActionSquirrel_0.1.0\n\nloaded via a namespace (and not attached):\n [1] digest_0.6.33     R6_2.5.1          signal_0.7-7      fastmap_1.1.1    \n [5] sonify_0.0-1      xfun_0.39         knitr_1.43.1      htmltools_0.5.5  \n [9] rmarkdown_2.23    tuneR_1.4.4       cli_3.6.1         compiler_4.3.1   \n[13] rstudioapi_0.15.0 tools_4.3.1       evaluate_0.21     yaml_2.3.7       \n[17] rlang_1.1.1       jsonlite_1.8.7    htmlwidgets_1.6.2 MASS_7.3-60      \n```\n:::\n:::\n\n</details>\n\n[^grid]: I've [posted previously](https://www.rostrum.blog/2021/06/26/emojiscape/) about [my {emojiscape} package](https://github.com/matt-dray/emojiscape) for printing little emoji grids to the console that represent different scenes. You may recognise the components from `emojiscape::generate(\"woods\")` in {ActionSquirrel}.\n[^dollar]: But beware of the [conspiracy behind the use of this operator](https://www.rostrum.blog/2021/07/15/dollar-dollar/).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
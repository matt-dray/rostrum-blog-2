{
  "hash": "b6aadaae3d50f9db476de31873730cc6",
  "result": {
    "markdown": "---\ntitle: Autodetect Quarto formats with {quartostamp}. Or not.\ndate: 2023-09-01\nslug: quarto-yaml-detect\ncategories:\n  - quarto\n  - quartostamp\n  - r\n  - rstudio-addins\n  - yaml\n---\n\n\n![](resources/uno.png){fig-alt=\"Uno meme. On left, a card says 'think for 2 secs before coding or draw 25'. On the right is a man, labelled 'me' holding a huge number of cards.\" width=\"60%\" fig-align=\"left\"}\n\n## tl;dr\n\nI wrote a cunning solution to fix an issue in [the {quartostamp} R package](https://matt-dray.github.io/quartostamp/). Spoiler: it was completely unnecessary. A lesson!\n\n## Put it on my tab\n\n{quartostamp} is [an R package](https://matt-dray.github.io/quartostamp/) that contains an RStudio Addin to [help insert and modify code](https://www.rostrum.blog/posts/2022-08-11-quartostamp-snorkel/) in Quarto documents. I originally made it to help me write [Quarto presentations](https://quarto.org/docs/presentations/): I kept forgetting the correct syntax for things like inserting speaker notes and column layouts.[^features]\n\nZoë made a great, subtle point [in a GitHub issue](https://github.com/matt-dray/quartostamp/issues/10): the 'Insert Tabset' option uses level-3 Markdown headers (`###`) for its tab titles, but [shouldn't they be level 2](https://quarto.org/docs/interactive/layout.html#tabset-panel) (`##`)? \n\nTo illustrate, here's what {quartostamp} was inserting for a tabset:\n\n```\n::: {.panel-tabset}\n\n### Tab A\n\nContent for Tab A\n\n### Tab B\n\nContent for Tab B\n\n:::\n```\n\nWhich would render like this:\n\n::: {.panel-tabset}\n\n### Tab A\n\nContent for Tab A\n\n### Tab B\n\nContent for Tab B\n\n:::\n\nSo `### Tab A` in the YAML should be `## Tab A`, for example.\n\nI think I'd used level 3 headers because second-level headers demarcate new slides in a Quarto presentation and [the specific guidance for presentations](https://quarto.org/docs/presentations/revealjs/#tabsets) appears to suggest `###`.\n\nSo, obviously, an instance of `##` in a tabset header could break someone's slides and I should come up with some convoluted solution, right? What could go wrong? (This is a literary technique called 'foreshadowing', dear reader.)\n\n## A stab at the tabs\n\nSo, what to do? It seemed as though there were three options:\n\n1. Have two versions of the tabset function that insert `##` or `###`.\n2. Switch to `##` only .\n3. Retain only `###`.\n\nEach is a relatively easy change. But number 1 is a non-starter because it's confusing from a user's perspective. Number 2 would disrupt people making presentations; they'd have to manually add the extra `#` each time. Number 3 is probably the least worst, but might be surprising for general Quarto users.\n\nSo, a bonus idea:\n\n4. Adapt the heading level automatically, based on the document format.\n\nThat sounds complicated. Is it?\n\n## A dash to hash\n\nQuarto docs start with a text-based 'YAML header'. This contains a bunch of key-value metadata like the document title, author, etc, between 'fences' given by triple hyphens (`---`). At simplest:\n\n```\n---\nformat: revealjs\n---\n```\n\nOr more likely, something nested like this:\n\n```\n---\ntitle: Chocolate Hobnobs\nsubtitle: The best biscuits\nauthor: Matt Dray\nformat:\n  revealjs: \n    theme: [default, biscuits.scss]\n    menu: false\ntitle-slide-attributes:\n  data-background-image: hobnob.png\n---\n```\n\nSo we have to somehow read the YAML header of the Quarto file we're working on and then extract the format information to see if it's a presentation or not.\n\nSo I ended up doing this:\n\n1. Detect information about the active Quarto document in the RStudio script pane with `rstudioapi::getActiveDocumentContext()`.\n2. Isolate the text content.\n3. Detect the lower limit of the document's YAML header (i.e. the second, closing instance of the `---` YAML fence).\n4. Use `yaml::yaml.load()` to parse the YAML header.\n5. Detect if a `format` key-value pair is present\n6. Detect if at least one listed format is `revealjs` (the Javascript library Quarto uses to make presentations).\n7. If yes, construct a level 3 header (`###`), otherwise level 2 (`##`).\n8. Insert the tabset code into the Quarto file.\n\n## Hash in the trash\n\nExcept guess what? The presence of `##` inside tabset code actually doesn't create a new slide. I should've tested this before I started writing a solution. I think Quarto checks context: if Markdown is provided within `:::` fences then it's evaluated in that context. That makes sense!\n\n<details><summary>Click for a Quarto reprex</summary>\n\nPop this in a qmd file and hit 'render'.\n\n```\n---\ntitle: \"Testing tabset titles\"\nformat: revealjs\n---\n\n## Using level 3\n\n::: {.panel-tabset}\n\n### Tab A\n\nContent for Tab A\n\n### Tab B\n\nContent for Tab B\n\n:::\n\n## Using level 2\n\n::: {.panel-tabset}\n\n## Tab A\n\nContent for Tab A\n\n## Tab B\n\nContent for Tab B\n\n:::\n\n```\n\n</details>\n\nOn the plus side, I had fun solving the 'problem' and thinking creatively to extract and parse the YAML and write logic to handle each case. I don't claim it's optimised, but I've added it below for posterity.\n\nFirst, a function that uses {rstudioapi} to read the active Quarto doc in the RStudio source pane and outputs `TRUE` if it's a revealjs presentation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.check_revealjs <- function() {\n\n  # Fetch lines from the source\n  active_doc <- rstudioapi::getActiveDocumentContext()\n  contents <- active_doc[[\"contents\"]]\n\n  # Identify the lines that compose the YAML header\n  yaml_end_index <- which(contents == \"---\")[2]\n  yaml_only <- contents[seq(yaml_end_index)]\n\n  # Parse the YAML header, detect 'format' key\n  yaml_parsed <- yaml::yaml.load(yaml_only)\n  has_format <- \"format\" %in% names(yaml_parsed)\n\n  # Detect if the format is revealjs\n  \n  is_revealjs <- FALSE  # default\n\n  if (has_format) {\n\n    formats <- yaml_parsed[[\"format\"]]\n\n    # Format structure could differ, depends on YAML nesting\n    formats_is_vec <- inherits(formats, \"character\")\n    formats_is_list <- inherits(formats, \"list\")\n\n    if (formats_is_vec) {\n      is_revealjs <- \"revealjs\" %in% formats\n    }\n\n    if (formats_is_list) {\n      is_revealjs <- \"revealjs\" %in% names(formats)\n    }\n\n  }\n\n  return(is_revealjs)\n\n}\n```\n:::\n\n\nThe output from `.check_revealjs()` could then be used in a modified `stamp_tabset()` (the function that powers the 'Insert Tabset' option from the Addins menu) where `TRUE` inserts a level 3 header, otherwise a level 2 header.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstamp_tabset <- function() {\n\n  is_revealjs <- .check_revealjs()\n\n  # Set headers to level 2 by default\n  heading_level <- 2\n\n  # Set as level 3 if the active doc is a revealjs presentation\n  if (is_revealjs) {\n    heading_level <- 3\n  }\n\n  # Generate tabset header Markdown depending on doc format\n  tabset_heading_md <- paste(rep(\"#\", heading_level), collapse = \"\")\n\n  # Insert tabset code with appropriate heading level\n  .replace_text(\n    pre = paste0(\n      \"::: {.panel-tabset}\\n\",\n      \"\\n\",\n      paste(tabset_heading_md, \"Tab A\\n\"),\n      \"\\n\"\n    ),\n    body = \"Content for Tab A\\n\",\n    post = paste0(\n      \"\\n\",\n      paste(tabset_heading_md, \"Tab B\\n\"),\n      \"\\n\",\n      \"Content for Tab B\\n\",\n      \"\\n\",\n      \":::\\n\"\n    )\n  )\n}\n```\n:::\n\n\nYou can see the actual current state of the code in [the matt-dray/quartostamp GitHub repo](https://github.com/matt-dray/quartostamp), which also has the source for the `.replace_text()` function show in the code block above.\n\n## Hash and burn\n\nWhich leads us to a bonus bonus idea:\n\n5. Merge Zoë's pull request that simply changes `###` to `##`.\n\nAnd so {quartostamp} version 0.1.1 is now available!\n\nI look forward to further developments. But less so for 'antidevelopments' like these, lol.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-09-04 12:03:31 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2 compiler_4.3.1    fastmap_1.1.1     cli_3.6.1        \n [5] tools_4.3.1       htmltools_0.5.5   rstudioapi_0.15.0 yaml_2.3.7       \n [9] rmarkdown_2.23    knitr_1.43.1      jsonlite_1.8.7    xfun_0.39        \n[13] digest_0.6.33     rlang_1.1.1       evaluate_0.21    \n```\n:::\n:::\n\n</details>\n\n[^features]: The package got some great feature requests: [Indrajeet asked](https://github.com/matt-dray/quartostamp/issues/1) for callout boxes and [Zoë suggested](https://github.com/matt-dray/quartostamp/issues/6) that the package could modify existing text as well as insert skeleton code.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
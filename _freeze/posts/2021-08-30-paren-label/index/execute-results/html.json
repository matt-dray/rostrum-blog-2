{
  "hash": "d7ab53bfa4e8c829e879c8557704f0d1",
  "result": {
    "markdown": "---\ntitle: Auto-label closing parentheses in RStudio\ndate: 2021-08-31\nslug: add-biscuits\ncategories:\n  - blogsnip\n  - r\n  - rstudio\n  - rstudio-addin\n  - styler\n---\n\n::: {.cell}\n\n:::\n\n\n![](resources/add-biscuits.gif){fig-alt=\"Six nested functions in an RStudio script pane are highlighted and then an addin from the RStudio Addins menu is used, called 'add closing paren labels'. It breaks open the functions across several lines and adds labels after each closing bracket with the name of the function that it closes.\" width=\"100%\"}\n\n## tl;dr\n\nI wrote a novelty R function that inserts comments after closing parentheses with the names of the functions they belong to. (These are called [biscuits](https://code-biscuits.github.io/), apparently.) It's available as an RStudio Addin from [the {blogsnip} package](https://github.com/matt-dray/blogsnip).\n\n## Matryoshka functions\n\nShiny apps can involve a lot of nested functions in the UI, which can make them difficult to handle. \n\nSometimes I comment after a closing parenthesis ('paren') with the name of the function that it's closing, which makes it easier to match the pairs. \n\n[Duncan told me](https://twitter.com/nacnudus/status/1431739654789902339?s=20) these labels are called ['biscuits'](https://code-biscuits.github.io/), which is charming.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- fluidPage(\n  \"hogwash\",\n  sidebarLayout(\n    \"tripe\",\n    mainPanel(\n      \"piffle\",\n      tabsetPanel(\n        \"bilge\",\n        tabPanel(\n          \"twaddle\"\n        )  # tabPanel\n      )  # tabsetPanel\n    )  # mainPanel\n  )  # sidebarLayout\n)  # fluidPage\n```\n:::\n\n\nIdeally you don't want to write ['hadouken code'](https://twitter.com/mxwlj/status/1433132926418374661?s=20)[^hadouken] like this, though. A well-designed Shiny app would be modular and abstract away the functions, making everything a delight to read and understand.[^peng]\n\n## Paren in a codestack\n\nThere are a few ways that the RStudio IDE can help with the problem of bracket-buddying in long-winded scripts. In particular:\n\n1. Put your cursor next to a parenthesis and its partner will be automatically highlighted\n1. You can auto-indent with <kbd>Command</kbd> + <kbd>I</kbd> and [expose indent guides](https://twitter.com/mattdray/status/1431006821704216577?s=20) with _Options_ > _Code_ > _Show indent guides_ so that paren-pairs are aligned vertically\n1. Colour-match paren-pairs [with rainbow colours](https://twitter.com/mattdray/status/1430563837003055107?s=20), which you can activate with _Options_ > _Code_ > _Display_\n1. Use the keyboard shortcut <kbd>Control</kbd> + <kbd>P</kbd> to [jump from an opening to a closing parenthesis](https://twitter.com/mattdray/status/1432292336969699334)\n\nYou can see these in action in this gif:\n\n![](resources/paren-jump.gif){fig-alt=\"Code for a simplified Shiny app in the RStudio editor. The keyboard shortcut Control-and-P is being used to jump from the opening to closing parenthesis of a given pair.\" width=\"100%\"}\n\nThese go some way to helping, but each is not perfect for me, personally. For example, as someone with colourblindness, I find the rainbow colouring isn't distinct enough.\n\n## A biscuit recipe\n\nSo what if we want to use those closing-paren labels, or 'biscuits', instead? There doesn't seem to be an option in RStudio for that.\n\nNaturally, I wondered about filling that gap in the market. \n\nAs a result, consider this post a thought-experiment manifested with some clunky code that is poorly tested and probably doesn't do exactly what you want it to do. You have been warned.\n\n### Easy as A, B, D\n\nUsing R code, how can you work out the matching parentheses in an expression? Spoiler: it's not that simple.\n\nMaybe you could treat an expression as a string, then label the opening and closing parens in forward and reverse order, respectively. \n\nIn this example, the labels match up the parens for each imaginary function (uppercase for open-parens and lowercase for closing-parens):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"first(second(third()))\"\n#     A      B     Ccba\n```\n:::\n\n\nBut this simple reversing heuristic doesn't work for these expressions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"first(second(third(), fourth()))\"\n#     A      B     Cd        Dcba\n\n\"first(second(third(')')))\"\n#     A      B     C d cba\n```\n:::\n\n\nIn the first example we'd get the parens for `third()` and `fourth()` mixed up. In the second we have a sneaky unopened closing paren inside a string.\n\nNot forgetting that this doesn't solve how to extract each function name to use as the biscuit.\n\n### 'Overengineer' is my middle name\n\nRather than the naive approach of chopping up and counting strings, I decided to parse the actual R expressions from them.\n\nI created a function to do this, `add_biscuits()`, that contains sub-functions for three steps:\n\n1. `.parse()` to interpret the R code from an input\n1. `.label()` to match parenthesis pairs by their parent function, grab the parent function name and insert it as a comment after the closing paren\n1. `.format()` to stick it all back together and style it\n\nThe rest of the post walks through these functions. I'm certain there's easier ways to do things, but the code here demonstrates the point I'm trying to reach.\n\nFor demonstration, we can use one of the trickier examples from above as our input.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring <- \"first(second(third('x'), fourth('y')))\"\n```\n:::\n\n\n#### 1. Parse\n\nThe `.parse()` function takes a string containing R code and returns a dataframe of its 'syntax tree'. In other words, it breaks the string into 'tokens' that are recognised as units of R code: function calls, assignment arrows, etc.\n\nI've used `getParseData(parse())` to do the hard work of parsing the string into a dataframe with one row per token. The downside is that you must provide to it a file rather than a character object, so we first have to write it to a temporary file.\n\nI've then filtered the dataframe to get only the tokens that are R code (i.e. they aren't spaces) and renumbered the rows so they're consecutive. This will be useful when we want to extract the function names for each set of parens.\n\n<details><summary>Expand the `.parse()` function definition</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\n.parse <- function(string) {\n  \n  file <- tempfile(fileext = \".R\")\n  writeLines(string, file)\n  \n  tokens <- getParseData(parse(file))\n  parsed <- parsed[parsed$terminal == TRUE, ]\n  rownames(parsed) <- as.character(seq(nrow(parsed)))\n  \n  return(parsed)\n  \n}\n```\n:::\n\n</details>\n\nHere's what the output looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree <- .parse(string)\ntree[, c(\"line1\", \"col1\", \"parent\", \"token\", \"text\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   line1 col1 parent                token   text\n1      1    1      3 SYMBOL_FUNCTION_CALL  first\n2      1    6     40                  '('      (\n3      1    7      6 SYMBOL_FUNCTION_CALL second\n4      1   13     35                  '('      (\n5      1   14      9 SYMBOL_FUNCTION_CALL  third\n6      1   19     16                  '('      (\n7      1   20     12            STR_CONST    'x'\n8      1   23     16                  ')'      )\n9      1   24     35                  ','      ,\n10     1   26     23 SYMBOL_FUNCTION_CALL fourth\n11     1   32     30                  '('      (\n12     1   33     26            STR_CONST    'y'\n13     1   36     30                  ')'      )\n14     1   37     35                  ')'      )\n15     1   38     40                  ')'      )\n```\n:::\n:::\n\n\nSo each row is a recognised R token, e.g. the function name from the `first()` function is a `SYMBOL_FUNCTION_CALL` and `'x'` is a `STR_CONSTANT`. Parentheses are recognised as separate special tokens too: `'('` and `')'`.\n\nWe also get returned the position of each token in the input (`line*` and `col*`) and a variable called `parent` which tells us something about the association of tokens. In our case, opening- and closing-parens have the same `parent` value.\n\n#### 2. Label\n\nSo we can tie our paren pairs together with the `parent` variable and we know where to place the biscuit with the `line1` and `col1` information. But how to extract the function name and 'biscuitise' it?\n\nI've written the slightly awkward `.label()` function for this. It takes the output from `.parse()` and checks each row to see if it's a closing-paren token; if so, it finds the position of the matching open-paren by `parent`; then it looks at the text of the token in the preceding row to get the function name and sticks that in a new column called `label`.\n\n<details><summary>Expand the `.label()` function definition</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\n.label <- function(tree) {\n  \n  tree$label <- NA_character_\n  \n  for (tkn in seq_len(nrow(tree))) {\n    \n    tree$label[tkn] <- ifelse(\n      tree$token[[tkn]] == \"')'\",\n      tree[as.numeric(rownames(\n        tree[tree$parent == tree$parent[[tkn]] & tree$token == \"'('\", ]\n      )) - 1, \"text\"],\n      NA_character_\n    )\n    \n  }\n  \n  return(tree)\n  \n}\n```\n:::\n\n</details>\n\nSo now we have the required biscuit for each closing paren:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree_lbl <- .label(tree)\ntree_lbl[!is.na(tree_lbl$label), c(\"text\", \"label\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   text  label\n8     )  third\n13    ) fourth\n14    ) second\n15    )  first\n```\n:::\n:::\n\n\n#### 3. Format\n\nThe last step needs involves sticking everything back together again. My quick solution is hacky and needs a refactor for sure.\n\nThe `.format()` function does a couple of awkward things: recognises and pastes commas to their preceding token (otherwise we'll get lines in the output that start with a comma, which is valid, but not my style) and pastes in the biscuits with a suffixed `#` to mark it as a comment. Of course, this blocks downstream code, so we can add a linebreak with `\\n`.\n\nThe output is still going to be a bit uggo though, so I employed {styler} to reformat it in tidyverse style. This is very definitely opinionated.\n\n<details><summary>Expand the `.format()` function definition</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\n.format <- function(tree_lbl) {\n  \n  tree_lbl$comma <- c(\n    ifelse(tree_lbl$text != \",\", NA_character_, \",\")[-1], NA_character_\n  )  # lag commas\n  \n  tree_lbl <- tree_lbl[tree_lbl$token != \"','\", ]  # remove comma tokens\n  \n  tree_lbl$string <- NA_character_\n  \n  for (tkn in seq_len(nrow(tree_lbl))) {\n    \n    if (!is.na(tree_lbl$comma[tkn])) {  # when there's a comma\n      \n      if (!is.na(tree_lbl$label[tkn])) {  # paste with biscuit\n        \n        tree_lbl$string[tkn] <- paste0(\n          \"\\n\", tree_lbl$text[tkn], tree_lbl$comma[tkn],\n          \"#\", tree_lbl$label[tkn], \"\\n\"\n        ) \n        \n      } else if (is.na(tree_lbl$label[tkn])) {  # paste without biscuit\n        \n        tree_lbl$string[tkn] <- paste0(\n          \"\\n\", tree_lbl$text[tkn], tree_lbl$comma[tkn], \"\\n\"\n        ) \n        \n      }\n      \n    } else if (is.na(tree_lbl$comma[tkn]) & !is.na(tree_lbl$label[tkn])) {\n      \n      tree_lbl$string[tkn] <- paste0(\n        \"\\n\", tree_lbl$text[tkn], \"#\", tree_lbl$label[tkn], \"\\n\"\n      ) \n      \n    } else {  # no comma, no biscuit\n      \n      tree_lbl$string[tkn] <- tree_lbl$text[tkn]\n      \n    }\n    \n  }\n  \n  string_out <- paste0(tree_lbl$string, collapse = \"\")\n  string_out <- gsub(\"\\n\\n\", \"\\n\", string_out)\n  \n  styled <- suppressWarnings(\n    utils::capture.output(styler::style_text(string_out))\n  )\n  \n  paste(styled, collapse = \"\\n\")\n  \n}\n```\n:::\n\n</details>\n\nLet's hand over to `.format()` the labelled tree dataframe that was output from `.label()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- .format(tree_lbl)\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"first(\\n  second(\\n    third(\\\"x\\\"), # third\\n    fourth(\\\"y\\\") # fourth\\n  ) # second\\n) # first\"\n```\n:::\n:::\n\n\nSo the output is a character vector, with one element per line of our output R file. You can see in the console how this looks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfirst(\n  second(\n    third(\"x\"), # third\n    fourth(\"y\") # fourth\n  ) # second\n) # first\n```\n:::\n:::\n\n\nReal noice: we've got a comment after each closing bracket that notes which function it's closing. You can argue that some of these biscuits are redundant, but the goal has been achieved!\n\nA reminder of the original input:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"first(second(third('x'), fourth('y')))\"\n```\n:::\n:::\n\n\n#### 4. Combined function\n\nAnd so, we can put these three steps together in one function: `add_biscuits()`, which is a cuter name than `label_parens()` or whatever.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_biscuits <- function(string) { \n  .parse(string) |> .label() |> .format()\n}\n```\n:::\n\n\nThe output from each sub-function passes to the next, so it's a nice chance to use the pipe operator (R >= v4.1).\n\nLet's try it on that awkward example with the sneaky extra bracket.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring2 <- \"first(second(third(')')))\"\ncat(add_biscuits(string2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfirst(\n  second(\n    third(\")\") # third\n  ) # second\n) # first\n```\n:::\n:::\n\n\nSo only the 'real' closing-paren tokens have been recognised and labelled.\n\n## Bonus: RStudio addin\n\nYou're thinking 'cool, but how can I use this thing practically?' The answer is an RStudio addin.\n\nI've [written before](https://www.rostrum.blog/2019/10/22/blogsnip/) about [{blogsnip}](https://github.com/matt-dray/blogsnip), my package of R Markdown-related RStudio addins to help me prepare blog posts. I've put the `add_biscuits()` function in there for now.\n\nInstall from GitHub with {remotes} as follows and then restart RStudio. {blogsnip} doesn't force you to install {styler}, so you'll have to do that too (if you haven't already).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(c(\"remotes\", \"styler\"))\nremotes::install_github(\"matt-dray/blogsnip\")\n```\n:::\n\n\nThere should now be a 'BLOGSNIP' section in the 'Addins' menu (top navigation bar) with an option to 'Add closing paren labels'. Select a full R expression in the script window, then select 'Add closing paren labels'. Your code will be replaced with the same code, but with biscuits inserted.\n\n![](resources/add-biscuits.gif){fig-alt=\"Six nested functions in an RStudio script pane are highlighted and then an addin from the RStudio Addins menu is used, called 'add closing paren labels'. It breaks open the functions across several lines and adds labels after each closing bracket with the name of the function that it closes.\" width=\"100%\"}\n\nBeware: your code will be replaced if you use the addin. Of course, you can edit or undo the output as necessary.\n\nYou can set a keyboard shortcut for this too, if you want. Go to _Tools_ > _Modify Keyboard Shortcuts..._. I set mine to <kbd>Ctrl</kbd> + <kbd>Cmd</kbd> + <kbd>P</kbd>, since <kbd>Ctrl</kbd> + <kbd>P</kbd> is the shortcut that jumps from opening to closing parens.\n\n## Oh, crumbs...\n\nLet me be clear: `add_biscuits()` is half-baked (lol). It works on the simple examples here, but I'm pretty sure it will break horribly on more complex things. I haven't really tested it properly. \n\nIt gets confused if there's already some labelled closing parens. It gets confused if you don't highlight enough code to capture all the opening and closing parens. It gets confused if you run it over more than one expression. It ignores curly and square parentheses. Etc, etc.\n\nSo, use the function at your own risk, or better yet: improve it by [contributing to {blogsnip}](https://github.com/matt-dray/blogsnip).\n\nOr even better yet, just use a good implementation of this functionality that someone else has probably written and I've been too lazy to search for.\n\nOr, y'know, don't write heavily-nested code that requires you to write comments after closing parens.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-07-08 13:16:37 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.3        crayon_1.5.2       cli_3.6.1          knitr_1.43.1      \n [5] rlang_1.1.1        xfun_0.39          rex_1.2.1          processx_3.8.1    \n [9] purrr_1.0.1        styler_1.10.1      xmlparsedata_1.0.5 jsonlite_1.8.7    \n[13] rprojroot_2.0.3    htmltools_0.5.5    ps_1.7.5           rmarkdown_2.23    \n[17] R.cache_0.16.0     evaluate_0.21      fastmap_1.1.1      lifecycle_1.0.3   \n[21] yaml_2.3.7         cyclocomp_1.1.0    compiler_4.3.1     lintr_3.0.2       \n[25] htmlwidgets_1.6.2  rstudioapi_0.14    R.oo_1.25.0        R.utils_2.12.2    \n[29] digest_0.6.31      R6_2.5.1           magrittr_2.0.3     callr_3.7.3       \n[33] R.methodsS3_1.8.2  tools_4.3.1        withr_2.5.0        lazyeval_0.2.2    \n[37] xml2_1.3.4         remotes_2.4.2      desc_1.4.2        \n```\n:::\n:::\n\n</details>\n\n[^hadouken]: The code looks like the shockwave emanating from [a 'hadouken' energy-ball](https://en.wikipedia.org/wiki/Hadouken) from the Street Fighter video games.\n[^peng]: And if you're nesting too much, maybe consider [Roger Peng's eight-space indentation](https://simplystatistics.org/2018/07/27/why-i-indent-my-code-8-spaces/) to punish yourself.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
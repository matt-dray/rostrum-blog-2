{
  "hash": "6d72da22275521a71733756a84f1c905",
  "result": {
    "markdown": "---\ntitle: Extract run data from Apple Health (redux)\ndate: 2023-06-11\nslug: apple-health-redux\ncategories:\n  - apple\n  - r\n  - sport\n  - xml\n  - xml2\n---\n\n::: {.cell}\n\n:::\n\n\n![](resources/apple-run.png){fig-alt=\"A badly drawn cartoon apple running along and thinking about some XML data.\" width=\"100%\"}\n\n## tl;dr\n\nYou can use R to extract running details from a downloaded of your Apple Health data. The format of the data has changed since I last tried this, so I re-wrote my code.\n\n## On your marks\n\nIn 2021 [I extracted my running activities from my Apple Health data](https://www.rostrum.blog/2021/03/23/xml-health/) using [the {xml2} package](https://xml2.r-lib.org/). You can read there for some theory and background.\n\nAt that point I'd been running for one year. I'm nearly at 500 runs, so I thought I would re-execute my code with the latest data. Alas, the original code no longer works because Apple seems to have updated the format of the XML file they provide.\n\n<div class=\"tip\"> `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c13.3 0 24 10.7 24 24V264c0 13.3-10.7 24-24 24s-24-10.7-24-24V152c0-13.3 10.7-24 24-24zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z\"/></svg>`{=html} <b>Note</b>\n\nI have since re-rendered this post after passing 500 runs.\n\n<div>\n\nSo I've written a new function that takes a path to the zipped download of my Apple Health data and outputs a dataframe of time and distance data, with one row per run.\n\n## Get set\n\nI followed [the same steps as before](https://www.rostrum.blog/2021/03/23/xml-health/#warm-up) to get my Apple Health data off my phone.\n\nI smashed together a quick function to unzip the file to a temporary location and then extract workout data using the [the {xml2} package](https://xml2.r-lib.org/). There's a bit of base R wrangling to output a dataframe with a row per run workout, focusing on total time and distance.\n\n<details><summary>Click to expand the function definition</summary>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_run_distances <- function(zip_path) {\n  \n  # Unzip Apple Health export to temporary location\n  message(\"Unzipping and reading XML\")\n  temp <- tempdir()\n  unzip(zipfile = zip_path, exdir = temp)\n  xml_in <- xml2::read_xml(file.path(temp, \"apple_health_export\", \"export.xml\"))\n  unlink(temp)\n  \n  # Isolate workouts only and convert to an R list object\n  message(\"Isolating workouts from XML\")\n  wo_in <- xml2::xml_find_all(xml_in, \"//Workout\") |> xml2::as_list()\n  \n  # Pre-allocate a list to be filled with output data\n  wo_total <- length(wo_in)\n  wo_out <- vector(\"list\", wo_total)\n  \n  # For each viable workout, extract the details\n  message(\"Iterating over workouts to extract run data\")\n  for (wo_n in seq(wo_total)) {\n    \n    # Extract details for current workout\n    wo <- wo_in[[wo_n]]\n    wo_attrs <- attributes(wo)  # the data is stored as attributes\n    is_run <- \n      wo_attrs[[\"workoutActivityType\"]] == \"HKWorkoutActivityTypeRunning\"\n    \n    # If the workout wasn't a run, then skip to the next workout\n    if (!is_run) next\n    \n    # if it is a run, then extract the data to a single-row dataframe\n    if (is_run) {\n      \n      # There can be more than one element named 'WorkoutStatistics'. We want to \n      # get the one with distance information and extract the details.\n      wo_stats <- wo[grep(\"WorkoutStatistics\", names(wo))]\n      wo_stats_types <- lapply(wo_stats, \\(x) attr(x, c(\"type\")))\n      dist_type <- \"HKQuantityTypeIdentifierDistanceWalkingRunning\"\n      dist_index <- which(wo_stats_types == dist_type)\n      wo_dist <- wo_stats[[dist_index]]\n      \n      # Prepare single-row dataframe and add to the pre-allocated list\n      wo_details <- data.frame(\n        source = wo_attrs[[\"sourceName\"]],\n        start = as.POSIXct(wo_attrs[[\"startDate\"]]),\n        end = as.POSIXct(wo_attrs[[\"endDate\"]]),\n        distance_km = attr(wo_dist, \"sum\") |> as.numeric() |> round(2)\n      )\n      wo_details[[\"duration_s\"]] <- \n        as.numeric(wo_details[[\"end\"]] - wo_details[[\"start\"]], units = \"secs\")\n      wo_out[[wo_n]] <- wo_details\n      \n    }\n    \n  }\n  \n  # Convert to dataframe, select columns\n  message(\"Combining data\")\n  wo_out_df <- do.call(rbind, wo_out)\n  wo_out_df[, c(\"source\", \"start\", \"end\", \"duration_s\", \"distance_km\")]\n  \n}\n```\n:::\n\n\n</details>\n\nI won't go through it line by line, but there's some commentary to explain what's happening at each step. It does what I need it to do for now, but no doubt there's some refactoring to be done. \n\nThere's a few things to note:\n\n* I'm more comfortable handling R objects, so I converted early to a list with `xml2::as_list()`. Awkwardly, the data in the list object was stored as [attributes](https://xml2.r-lib.org/) to each element.\n* The distance data is stored in an element called 'WorkoutStatistics', but more than one element will have this name. We first have to isolate the element that is of the correct type, which has the name 'HKQuantityTypeIdentifierDistanceWalkingRunning'.\n* I converted the start and end variables to datetime class (POSIXct) and subtracted one from the other to get the duration of the run. This yields the 'difftime' class that can be converted to seconds with `as.numeric()` and the argument `units = \"secs\"`.\n* There's no input handling, because this was quick and for 'fun', lol.\n\n## Go\n\nSo, to use the function you pass a path to where your zipped Apple Health export lives. Mine is in my 'Documents' folder.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nruns <- get_run_distances(\"~/Documents/data/export.zip\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nUnzipping and reading XML\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nIsolating workouts from XML\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nIterating over workouts to extract run data\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCombining data\n```\n:::\n:::\n\n\nI recorded all my runs with the Nike Run Club app, so I'll filter out duplicates where I dual-recorded with Apple's Workout app. I think I accidentally started the app by mistake a couple of times, so we'll only grab runs of over 1 km. I'll also convert the seconds to a friendlier-looking 'period' class using [{lubridate}](https://lubridate.tidyverse.org/)[^lubridate].\n\nHere's the most recent few:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nruns <- runs[runs$source == \"Nike Run Club\" & runs$distance_km > 1, ]\nruns$duration <- lubridate::seconds_to_period(runs$duration_s)\nruns <- runs[, c(\"start\", \"distance_km\", \"duration\")]\nrow.names(runs) <- NULL\ntail(runs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  start distance_km duration\n497 2023-06-15 08:45:46        6.39  30M 36S\n498 2023-06-17 11:07:03       10.52  50M 58S\n499 2023-06-18 10:36:58       10.42  51M 29S\n500 2023-06-22 08:14:51        6.34  30M 43S\n501 2023-06-24 08:47:05       10.13  48M 43S\n502 2023-06-25 09:20:20       12.12  59M 48S\n```\n:::\n:::\n\n\nFor my own tracking purposes, I've run:\n\n* 502 times\n* for a total distance of 4119 km\n* for a total duration of about 14 days\n\nAnd I can recreate a couple of the plots from the old post while we're here. Here's the 'run barcode', with one vertical line per run (the darker it is the greater the distance):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr, warn.conflicts = FALSE)\nlibrary(tidyr)\n\nrun_days <- left_join(\n  data.frame(date = as_date(ymd(\"2020-03-23\"):ymd(\"2023-06-25\"))),\n  runs |>\n    transmute(date = ymd(as_date(start)), km = distance_km, duration) |>\n    filter(date >= \"2020-03-23\" & date <= \"2023-06-25\") |>\n    group_by(date) |> \n    summarise(km = sum(km), .groups = \"drop\"),\n  by = \"date\"\n) |>\n  replace_na(list(run = 0))\n\npar(mar = rep(0, 4))\nimage(matrix(run_days$km), col = grey.colors(11, 0.8, 0))\nbox(col = \"white\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/barcode-1.png){fig-alt='A one-dimensional plot of days represented by vertical lines, with run distance coloured on a scale of white to black.' width=960}\n:::\n:::\n\n\nAnd of course, a simple distance over time plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(\n  x = runs$start, \n  y = runs$distance_km, \n  las = 1,  # rotate y-axis labels\n  main = \"Runs captured with Nike Run Club in Apple Health\",\n  xlab = \"Date\",\n  ylab = \"Distance (km)\"\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-1.png){fig-alt='Run distance over time scatterplot, which shows a high frequency of 5 and 10 km runs.' width=672}\n:::\n:::\n\n\nSome patterns are obvious. For example, there's lots of 5 km runs until about mid-2021, when it hops to more like 7 km. That's when I started running for 30 mins at a time, rather than for 5 km specifically.\n\nI'm pretty happy at 5 and 10 km, obviously, but maybe I should do more 21.1 km half-marathons. Or a full marathon? No no, that's foolish: it would expand my y-axis too much and make it harder to observe patterns at shorter distances, amirite.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-07-17 21:04:06 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] tidyr_1.3.0     dplyr_1.1.2     lubridate_1.9.2\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.3       cli_3.6.1         knitr_1.43.1      rlang_1.1.1      \n [5] xfun_0.39         purrr_1.0.1       generics_0.1.3    jsonlite_1.8.7   \n [9] glue_1.6.2        htmltools_0.5.5   fansi_1.0.4       rmarkdown_2.23   \n[13] evaluate_0.21     tibble_3.2.1      fontawesome_0.5.1 fastmap_1.1.1    \n[17] yaml_2.3.7        lifecycle_1.0.3   compiler_4.3.1    htmlwidgets_1.6.2\n[21] timechange_0.2.0  pkgconfig_2.0.3   rstudioapi_0.15.0 digest_0.6.31    \n[25] R6_2.5.1          tidyselect_1.2.0  utf8_1.2.3        pillar_1.9.0     \n[29] magrittr_2.0.3    tools_4.3.1       xml2_1.3.5       \n```\n:::\n:::\n\n</details>\n\n[^lubridate]: {lubridate} is handy for time handling for many reasons. Here it's helpful because it can resolve minutes and seconds (e.g. `21M 30S`) instead of the decimal minutes (e.g. `21.5`) in a difftime object.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
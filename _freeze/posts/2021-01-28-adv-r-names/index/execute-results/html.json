{
  "hash": "25c8c683ac2ad313d25ec6322e9c408e",
  "result": {
    "markdown": "---\ntitle: R's names and values as anchovy pizza\ndate: 2021-01-28\nslug: adv-r-names\ncategories:\n  - book\n  - pizza\n  - r\n---\n\n\n![Queued two hours for this. R's names and values system is faster to learn, but not as delicious.](resources/pizza.gif){fig-alt=\"Bird's-eye view of five large margherita pizzas on a table before and after consumption\" width=\"100%\"}\n\n## tl;dr\n\nI bought [Hadley Wickham](http://hadley.nz/)'s [_Advanced R_](https://adv-r.hadley.nz/) book[^buy] to help me better understand R's quirks. Can names and values (chapter 2) be explained with a contrived pizzeria analogy?[^royale]\n\n## A pizza by any other name\n\nWelcome to the pizzeria. It's called 'La PizzRia' because our owner likes to code and is really lazy at puns.\n\n### Toppings as vectors\n\nOur specialty (and only!) pizza is _pizza alla napoletana_, which is topped with mozzarella, tomatoes and anchovies.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a character-vector object\nnapoletana <- c(\"mozzarella\", \"tomato\", \"anchovy\")\n```\n:::\n\n\nThe English version of the menu calls it 'Neapolitan' pizza, but it's the same thing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneapolitan <- napoletana       # copy the object\nall(neapolitan == napoletana)  # they're equal\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nWe store our unique sets of pizza toppings in a special recipe book. If you look up 'napoletana' and 'Neapolitan' in the book's index, you'll see they point to the same recipe. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The {lobstr} package helps understand object structure\nlibrary(lobstr)  # after install.packages(\"lobstr\")\n\n# Get the specific object 'address' in your computer's memory\n# Both names point to the same object\nobj_addr(napoletana)  # original object\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x129af4728\"\n```\n:::\n\n```{.r .cell-code}\nobj_addr(neapolitan)  # the copy\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x129af4728\"\n```\n:::\n:::\n\n\nBasically, the pizzaiolos don't care: different names, same pizza. The recipe codes are the same.\n\n<div class=\"tip\"> \n`<i class=\"fas fa-book-open\" role=\"presentation\" aria-label=\"book-open icon\" fill=\"#1e8016\"></i>`{=html} _Advanced R_, p19\n\n\"The object, or value, doesn't have a name; it's actually the name that has a value.\"\n</div><p>\n\n### Copying a recipe, modifying it\n\nWe recently added _pizza pugliese_ to the menu. We copied our napoletana in the recipe book and then modified it to have onions instead of anchovies.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npugliese <- napoletana       # copy the object\nall(pugliese == napoletana)  # the objects are the same\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\npugliese[[3]] <- \"onion\"  # modify the third element\npugliese == napoletana    # they're no longer the same\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE\n```\n:::\n:::\n\n\nWhen we look up these names in the index of our recipe book, we see that they point to different places, despite having copied the napoletana to get the pugliese.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Now the names point to different objects\n# We modified the copy, so it becomes a new object in memory\nobj_addr(napoletana)  # original object\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x129af4728\"\n```\n:::\n\n```{.r .cell-code}\nobj_addr(pugliese)    # the modified copy\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x12b32ec68\"\n```\n:::\n:::\n\n\n<div class=\"tip\">\n`<i class=\"fas fa-book-open\" role=\"presentation\" aria-label=\"book-open icon\" fill=\"#1e8016\"></i>`{=html} _Advanced R_, p22\n\n\"This behaviour is called copy-on-modify.\"\n</div><p>\n\nSo, here's our full pizza lineup in Italian and English.\n\n\n::: {.cell}\n\n```{.r .cell-code}\napulian <- pugliese  # specify English name for the pugliese\n\n# A comparison of the pizza object structures\nknitr::kable(\n  tibble::tribble(\n    ~Language, ~Name, ~`Toppings`, ~`Recipe code`, \n    \"ITA\", \"Pizza alla napoletana\", napoletana, obj_addr(napoletana),\n    \"ENG\", \"Neapolitan pizza\", neapolitan, obj_addr(neapolitan),\n    \"ITA\", \"Pizza pugliese\", pugliese, obj_addr(pugliese),\n    \"ENG\", \"Apulian pizza\", apulian, obj_addr(apulian)\n  )\n)\n```\n\n::: {.cell-output-display}\n|Language |Name                  |Toppings                        |Recipe code |\n|:--------|:---------------------|:-------------------------------|:-----------|\n|ITA      |Pizza alla napoletana |mozzarella, tomato    , anchovy |0x129af4728 |\n|ENG      |Neapolitan pizza      |mozzarella, tomato    , anchovy |0x129af4728 |\n|ITA      |Pizza pugliese        |mozzarella, tomato    , onion   |0x12b32ec68 |\n|ENG      |Apulian pizza         |mozzarella, tomato    , onion   |0x12b32ec68 |\n:::\n:::\n\n\nPizza alla napoletana and its copy, Neapolitan pizza, point to the same recipe code. \n\nPizza pugliese was a copy of pizza alla napoletana, but it now points to a different recipe code. Why? An element was changed, anchovies to onions, so a new recipe code was required.\n\nFinally, Apulian pizza is a copy of the pizza pugliese recipe, so they both point to the same unique topping set.\n\n### Toppings as lists\n\nOur knowledge management system was, however, a bit inefficient: the mozzarella and tomato toppings existed twice in our recipe book; once for each pizza.\n\nSo we decided to update our recipe system to store each topping separately, each with its own special reference code too.\n\nAgain, we wrote down the pizza napoletana toppings, copied them, then switched the anchovies for onions. Like in our old system, the two pizzas differ in their third element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Toppings now as list elements\nnapoletana <- list(\"mozzarella\", \"tomato\", \"anchovy\")\npugliese <- napoletana          # make a copy\nidentical(pugliese, napoletana) # they're the same\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\npugliese[[3]] <- \"onion\"        # make a change\nidentical(pugliese, napoletana) # now they're different\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nSo in the new system, each topping  has its own unique ingredient code. This means both pizza recipes point to the same ingredient codes for tomato and mozzarella.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compare addresses in memory for the lists\n# Each 'block' below is a list object (pizza)\n# Each element is a character vector (topping)\nref(napoletana, pugliese)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n█ [1:0x11ab4fb38] <list> \n├─[2:0x12a21e6a8] <chr> \n├─[3:0x12a21e638] <chr> \n└─[4:0x12a21e600] <chr> \n \n█ [5:0x11ab55d68] <list> \n├─[2:0x12a21e6a8] \n├─[3:0x12a21e638] \n└─[6:0x12a21e4b0] <chr> \n```\n:::\n:::\n\n\nBasically, our pizza names point to pizza recipes that themselves point out to toppings.\n\n<div class=\"tip\"> \n`<i class=\"fas fa-book-open\" role=\"presentation\" aria-label=\"book-open icon\" fill=\"#1e8016\"></i>`{=html} _Advanced R_, p25\n\n\"This list is more complex [than a vector] because instead of storing the values itself, it stores references to them.\"\n</div><p>\n\nThis means we can be more efficient in storing our pizza recipes: we write down 'mozzarella' and 'tomatoes' only once. This could become much more efficient when storing more than the two pizzas we have on La PizzRia's menu.[^damichele]\n\n### Customer orders as data frames\n\nHow do we manage orders? Wait-staff write down each order in a column, with a row for each topping.\n\n<div class=\"tip\"> \n`<i class=\"fas fa-book-open\" role=\"presentation\" aria-label=\"book-open icon\" fill=\"#1e8016\"></i>`{=html} _Advanced R_, p26\n\n\"Data frames are lists of vectors.\"\n</div><p>\n\nLet's say a couple orders a pizza napoletana and a pizza pugliese.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a data.frame, which is a list of vectors\n# Column behaviour is vector behaviour\norder <- data.frame(\n  napoletana = c(\"mozzarella\", \"tomato\", \"anchovy\"),\n  pugliese = c(\"mozzarella\", \"tomato\", \"onion\")\n)\n\norder\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  napoletana   pugliese\n1 mozzarella mozzarella\n2     tomato     tomato\n3    anchovy      onion\n```\n:::\n:::\n\n\nAs we know, these pizzas both have mozzarella and tomatoes, but the third topping is different.\n\nBut wait: the customer who ordered the napoletana is hungry for more anchovies!\n\n\n::: {.cell}\n\n```{.r .cell-code}\norder_update <- order  # copy the data.frame object\norder_update[3, 1] <- \"anchovy (extra)\"  # modify the new object\norder_update\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       napoletana   pugliese\n1      mozzarella mozzarella\n2          tomato     tomato\n3 anchovy (extra)      onion\n```\n:::\n:::\n\n\nWe use a code reference system for our orders too and it works just like our old recipe system.\n\nSince one of the pizza orders was changed, our reference code for the entire order was changed too.\n\nThe napoletana was modified after it was copied, so the recipe code for that pizza was updated. The pugliese didn't change, so its code was maintained.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compare the data.frame structures\n# Modified column gets new code, object gets new code\n# Second column unchanged, code stays the same\nref(order, order_update)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n█ [1:0x12abc7548] <df[,2]> \n├─napoletana = [2:0x12c1de9f8] <chr> \n└─pugliese = [3:0x12c1de908] <chr> \n \n█ [4:0x129ba3408] <df[,2]> \n├─napoletana = [5:0x129d1c948] <chr> \n└─pugliese = [3:0x12c1de908] \n```\n:::\n:::\n\n\n<div class=\"tip\">\n`<i class=\"fas fa-book-open\" role=\"presentation\" aria-label=\"book-open icon\" fill=\"#1e8016\"></i>`{=html} _Advanced R_, p26\n\n\"If you modify a column, only that column needs to be modified.\"\n</div><p>\n\nThe mozzarella is especially bountiful this year; the waiter suggests both patrons take advantage.\n\nThey strongly agree. The order is copied once more and the waiter modifies the 'cheese row' for both pizzas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\norder_final <- order_update  # copy the object\norder_final[1, 1:2] <- \"mozzarella (extra)\"  # modify row one of both columns\norder_final\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          napoletana           pugliese\n1 mozzarella (extra) mozzarella (extra)\n2             tomato             tomato\n3    anchovy (extra)              onion\n```\n:::\n:::\n\n\nAltering the cheese row means both pizza columns are copied and given new codes. Of course, the order gets a whole new code of its own because the toppings were changed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compare data.frame structures again\n# All columns modified, so copies made\n# data.frame and column memory locations all differ\nref(order, order_final)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n█ [1:0x12abc7548] <df[,2]> \n├─napoletana = [2:0x12c1de9f8] <chr> \n└─pugliese = [3:0x12c1de908] <chr> \n \n█ [4:0x1188f7b88] <df[,2]> \n├─napoletana = [5:0x11ab42df8] <chr> \n└─pugliese = [6:0x11ab42da8] <chr> \n```\n:::\n:::\n\n\n<div class=\"tip\"> \n`<i class=\"fas fa-book-open\" role=\"presentation\" aria-label=\"book-open icon\" fill=\"#1e8016\"></i>`{=html} _Advanced R_, p27\n\n\"If you modify a row, every column is modified, which means every column must be copied.\"\n</div><p>\n\n_Buon appetito_!\n\n## Il conto\n\nSo can names and values be explained with this analogy? \n\nKinda? The basic premise is there: names and pizzas, names and values, etc. But it's definitely contrived. Why are wait staff writing down pizza orders in a dataframe, etc?\n\nI've also deceived you with some 'polite fiction', in Hadley's words. In a numeric vector, the name points to the values. In a character vector, the name actually points to a vector of pointers, which themselves reference unique character strings.\n\n<div class=\"tip\"> \n`<i class=\"fas fa-book-open\" role=\"presentation\" aria-label=\"book-open icon\" fill=\"#1e8016\"></i>`{=html} _Advanced R_, p27\n\n\"R actually uses a global string pool where each element of a character vector is a pointer to a unique string in the pool.\"\n</div><p>\n\nBut I don't think that's a big deal for getting the point across.\n\nAnyway, your order's here.\n\n_Mangia! Mangia!_\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-07-21 19:28:58 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] lobstr_1.1.2\n\nloaded via a namespace (and not attached):\n [1] digest_0.6.33     utf8_1.2.3        fastmap_1.1.1     xfun_0.39        \n [5] fontawesome_0.5.1 magrittr_2.0.3    glue_1.6.2        tibble_3.2.1     \n [9] knitr_1.43.1      pkgconfig_2.0.3   htmltools_0.5.5   rmarkdown_2.23   \n[13] lifecycle_1.0.3   cli_3.6.1         fansi_1.0.4       vctrs_0.6.3      \n[17] compiler_4.3.1    rstudioapi_0.15.0 tools_4.3.1       pillar_1.9.0     \n[21] evaluate_0.21     yaml_2.3.7        crayon_1.5.2      rlang_1.1.1      \n[25] jsonlite_1.8.7    htmlwidgets_1.6.2\n```\n:::\n:::\n\n</details>\n\n[^buy]: Second edition. You can [buy the book](https://www.amazon.com/gp/product/0815384572/ref=as_li_tl?ie=UTF8&tag=hadlwick-20&camp=1789&creative=9325&linkCode=as2&creativeASIN=0815384572&linkId=9f8b9df5da858c12a5e9905aea66bf08), or [view it for free online](https://adv-r.hadley.nz/).\n[^royale]: Initially I went with the pop-culture reference about how a Quarter Pounder with Cheese is called a Royale with Cheese in Paris (or indeed, a Krusty Burger with Cheese is called a Quarter Pounder with Cheese at McDonald's), but the reference was better than the actual utility of the metaphor.\n[^damichele]: Of course, if you're really serious about pizza, you only offer two options. [_L'antica Pizzeria Da Michele_](http://www.damichele.net/le-nostre-pizze/), which is where I took the photos at the top of this post, offers only marinara and margherita. Do the simple things well.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/font-awesome-6.4.0/css/all.min.css\" rel=\"stylesheet\" />\n<link href=\"../../site_libs/font-awesome-6.4.0/css/v4-shims.min.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
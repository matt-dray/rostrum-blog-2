{
  "hash": "948de0788f3bbbb501be889267212860",
  "result": {
    "markdown": "---\ntitle: Engifification in R with {gifski}\ndate: 2018-07-26\nslug: engifification-in-r-with-gifski\ncategories:\n  - gif\n  - gifski\n  - r\n---\n\n\n![I personally don't evolve Lotad, because it's already perfect.](resources/lotad.gif){fig-alt=\"Gif of the evolution chain of the Pokemon Lotad. It shows a picture of Lotad, Lombre and Ludicolo with their name and Pokedex. The final frame is zoomed into Ludicolo's face.\" width=\"40%\" fig-align=\"left\"}\n\n## tl;dr\n\nUse [{gifski}](https://cran.r-project.org/web/packages/gifski/index.html) to make gifs—real quickly!—using R.\n\n## Intergalactic pizza sloths\n\nYou and I both know that the world needs more gifs of sloths riding through space on a slice of pizza, for example.\n\nGreat news: 'the fastest gif encoder in the universe' has come to R via the [{gifski} package](https://cran.r-project.org/web/packages/gifski/index.html) built by Jeroen Ooms for rOpenSci. It's built on [Gifski package for Rust](https://gif.ski/), hence the speed.\n\nThe obvious analytical application is for creating gifs from plots, as in the following example from [the rOpenSci announcement](https://ropensci.org/technotes/2018/07/23/gifski-release/), which shows life expectancy by GDP per capita with a different year for each frame of the gif.\n\n![](resources/life.gif){fig-alt=\"An animated plot of gapminder data which shows life expectancy on the y axis and GDP per capita on the x axis. Each frame shows data for the next year in the sequence.\"}\n\nBut no-one can stop us having fun with it too.\n\n## Engifification proclamation\n\nSo I've made a quick function that takes a folder of PNGs and stitches them into a gif using the `gifski::gifski()` function. I've called it `make_gif()` because it... makes gifs. It's not optimised because it's just for fun, okay?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_gif <- function(png_dir, gif_path, ...) {\n  \n  png_dir_is_char  <- inherits(png_dir, \"character\")\n  gif_path_is_char <- inherits(gif_path, \"character\")\n  \n  if (!png_dir_is_char | !gif_dir_exists) {\n    stop(\"png_dir and gif_path must be character class.\", call. = FALSE)\n  }\n  \n  png_dir_exists <- dir.exists(png_dir)\n  gif_dir_exists <- dir.exists(dirname(gif_path))\n  \n  \n  if (!png_dir_exists | !gif_path_is_char) {\n    stop(\"png_dir and gif_path directories must exist.\", call. = FALSE)\n  }\n  \n  path_is_gif <- tools::file_ext(gif_path) == \"gif\"\n  \n  if (!path_is_gif) {\n    stop(\"gif_path must be a file path ending with .gif.\", call. = FALSE)\n  }\n  \n  files <- list.files(\n    path = png_folder,\n    pattern = \".png$|.PNG$\",\n    full.names = TRUE\n  )\n  \n  if (length(files) < 2) {\n    stop(\"You need two or more PNGs to make a gif.\", call. = FALSE)\n  }\n  \n  png(\"frame%03d.png\")\n  \n  par(ask = FALSE)\n  \n  dev.off()\n  \n  gifski::gifski(png_files = files, gif_file = gif_path)\n  \n}\n```\n:::\n\n\nBasically, you must supply two things:\n\n1. A path to a folder containing the images (.png or .PNG only).\n2. A path for where the gif should be written (including the '.gif' extension).\n\nOptionally you can provide a third: use the dots (`...`) to pass further arguments to `gifski::gifski()` (see `?gifski` for details).\n\nNote that you should make sure your PNGs are ordered alphabetically or numerically in the named directory so that they're engiffed[^engif] in the desired sequence. Don't worry if your folder has other filetypes; `make_gif()` only extracts PNGs.\n\n## Hexapod lilypad-frog evolution\n\nI used the `make_gif()` function to create the important gif at the top of this post, featuring the evolution chain of Lotad, the best and most special Pokémon.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_gif(\n  png_folder = \"~/Documents/pokemon/lotad/images\",  # folder of images\n  gif_path   = \"~/Desktop/lotad.gif\"                # path to save gif\n)\n```\n:::\n\n\nMaybe you'll find the function useful too. So get out there and get engiffing![^engif2]\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-08-08 22:14:03 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2 compiler_4.3.1    fastmap_1.1.1     cli_3.6.1        \n [5] tools_4.3.1       htmltools_0.5.5   rstudioapi_0.15.0 yaml_2.3.7       \n [9] rmarkdown_2.23    knitr_1.43.1      jsonlite_1.8.7    xfun_0.39        \n[13] digest_0.6.33     rlang_1.1.1       evaluate_0.21    \n```\n:::\n:::\n\n</details>\n\n[^engif]: I am endorsing the phrase 'to engif', as in 'I am engiffing a bunch of PNGs'. There's no way this doesn't take off.\n[^engif2]: Actually, it doesn't sound right does it?",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "9438458aa35f504ccde8ffd5fc981c7c",
  "result": {
    "markdown": "---\ntitle: \"EXPOSED: a Kiwi conspiracy built into R!\"\ndate: 2021-07-15\nslug: dollar-dollar\ncategories:\n  - r\n---\n\n\n\n\n![Kiwi by [Georgiana Ionescu](https://thenounproject.com/term/kiwi-bird/1761273/). Laser embellishment in honour of [Lucy Gray's flag](https://en.wikipedia.org/wiki/File:Fire_the_Lazer.png).](resources/laser-kiwi-dollar.png){fig-alt=\"A simple silhouette of a kiwi bird. A bright green laser shines from its eye. It is inscribing a bright green dollar symbol with the laser.\" width=\"60%\" fig-align=\"left\"}\n\n## tl;dr \n\nR's `$` data accessor symbol is part of an international ruse. I wrote a function so you can use your local currency symbol instead.\n\n## Pull the wool from your eyes\n\nYou're an R user, so you'll know how to access the contents of a quoted column name from a dataframe with square-bracket notation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars[[\"cyl\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n```\n:::\n:::\n\n\nThe dollar symbol (`$`) does the same thing, of course, in the form `dataframe$column`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$cyl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n```\n:::\n:::\n\n\nBut, like basically everything in R, it's just a function. \n\nSo you can also use it in the 'traditional way' by passing the dataframe and column name to it as arguments inside brackets. You'll need to use backticks (```) though, because function names can't start with symbols or numbers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`$`(mtcars, cyl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n```\n:::\n:::\n\n\n## Wake up sheeple\n\nBut why the dollar symbol? Something something 'compatability with S'. \n\nOr perhaps a more sinister ploy by [R's original developers, Ihaka and Gentleman](https://en.wikipedia.org/wiki/R_(programming_language)#History)? \n\nLike a KIWI CONSPIRACY to raise awareness of the NEW ZEALAND DOLLAR (NZD) and INFLUENCE currency markets? I'm just asking the question.[^sorry]\n\nSo, I'm giving you the FREEDOM to assign the functionality of the dollar symbol to another currency symbol, like, oh, I don't know, the pound sterling symbol (`£`), as a completely random example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`£` <- `$`\n`£`(mtcars, cyl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n```\n:::\n:::\n\n\nYou can't use it in the `dataframe$column` form, however. That kind of behaviour is reserved for special symbols in R.[^recompile]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars£cyl\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: <text>:1:7: unexpected input\n1: mtcars£\n          ^\n```\n:::\n:::\n\n\nShame. R has a little quirk that will make this work though. Sort of. \n\nYou can make a function do this by putting it between percentage symbols (`%`). This is called [an 'infix operator'](https://colinfay.me/playing-r-infix-functions/) and you may have seen [the {magrittr} pipe (`%>%`)](https://magrittr.tidyverse.org/) as one example. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n`%£%` <- `$`\nmtcars %£% cyl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n```\n:::\n:::\n\n\nAs a complete coincidence, I live in Great Britain (GB) where we use pound sterling (`£`, or 'GBP'). \n\nR also knows where I live (another conspiracy?).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.getlocale()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_US.UTF-8\"\n```\n:::\n:::\n\n\nThis string is R's way of keeping track of the location-specific information that influences stuff like the language of error messages.\n\nYou can specify different locales for different things. Here's my locale for 'monetary' parameters, for example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.getlocale(category = \"LC_MONETARY\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"en_GB.UTF-8\"\n```\n:::\n:::\n\n\nThat particular value impacts parameters like the punctuation mark used for decimals and, wouldn't you know it, the symbol used for currency.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.localeconv()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    decimal_point     thousands_sep          grouping   int_curr_symbol \n              \".\"                \"\"                \"\"            \"GBP \" \n  currency_symbol mon_decimal_point mon_thousands_sep      mon_grouping \n              \"£\"               \".\"               \",\"        \"\\003\\003\" \n    positive_sign     negative_sign   int_frac_digits       frac_digits \n               \"\"               \"-\"               \"2\"               \"2\" \n    p_cs_precedes    p_sep_by_space     n_cs_precedes    n_sep_by_space \n              \"1\"               \"0\"               \"1\"               \"0\" \n      p_sign_posn       n_sign_posn \n              \"1\"               \"1\" \n```\n:::\n:::\n\n\n## Mutton dressed as lamb\n\nSo, that means I can write you a function that gets the currency symbol for your locale and assigns to it the functionality of the dollar symbol, naturally.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncopy_dollar <- function() {\n  \n  # Get currency symbol for locale\n  currency <- Sys.localeconv()[[\"currency_symbol\"]]\n  \n  # Report the locale\n  if (currency == \"$\") stop(\"KIWI CONSPIRATOR!\")\n  locale <- Sys.getlocale(category = \"LC_MONETARY\")\n  cat(paste0(\"Your monetary locale is '\", locale, \"'\\n\"))\n  \n  # Generate and evaluate strings\n  expr_fn <- paste0(\"`\", currency, \"` <<- `$`\")\n  expr_in <- paste0(\"`%\", currency, \"%` <<- `$`\")\n  eval(rlang::parse_expr(expr_fn))  # function form\n  eval(rlang::parse_expr(expr_in))  # infix form\n  \n  # Report to user\n  cat(\n    paste0(\"Try `\", currency, \"`(df, col) and df%\", currency, \"%col\\n\")\n  )\n  \n}\n```\n:::\n\n\nI used a bit of a trick[^trick] there. You can't use a string on the left-hand side of the assignment operator, but you can build an R expression as a string and `eval()`uate a parsed version of it (with some help from {rlang} in my example).\n\nI also used a special double-headed assignment arrow, `<<-`, that makes the objects available in the global environment.[^assign] That means we can use the new functions outside the scope of the `copy_dollar()` function.\n\nAnd now: freeeedooooom.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncopy_dollar()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nYour monetary locale is 'en_GB.UTF-8'\nTry `£`(df, col) and df%£%col\n```\n:::\n:::\n\n\nWe got a couple of messages[^eng] to confirm our location and let us know how we can use the new currency-symbol functions.\n\nAnd we can see these in the global environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"%£%\"             \"£\"               \"copy_dollar\"     \"has_annotations\"\n```\n:::\n:::\n\n\nAnd we can prove that GBP equals NZD, at least as a function for accessing columns of a dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(\n  mtcars %£% cyl == mtcars$cyl,\n  `£`(mtcars, cyl) == `$`(mtcars, cyl)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nOkay, works for my location. What about when I'm competing in Japan at the Olympics?[^golf] Well, I can change the monetary locale.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setlocale(\"LC_MONETARY\", \"ja_JP.UTF-8\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ja_JP.UTF-8\"\n```\n:::\n\n```{.r .cell-code}\nSys.localeconv()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    decimal_point     thousands_sep          grouping   int_curr_symbol \n              \".\"                \"\"                \"\"            \"JPY \" \n  currency_symbol mon_decimal_point mon_thousands_sep      mon_grouping \n              \"¥\"               \".\"               \",\"        \"\\003\\003\" \n    positive_sign     negative_sign   int_frac_digits       frac_digits \n               \"\"               \"-\"               \"0\"               \"0\" \n    p_cs_precedes    p_sep_by_space     n_cs_precedes    n_sep_by_space \n              \"1\"               \"0\"               \"1\"               \"0\" \n      p_sign_posn       n_sign_posn \n              \"1\"               \"4\" \n```\n:::\n:::\n\n\nSo now you can see the yen symbol (`¥`) as the named currency value for this locale. And you can use the function to activate it for use as a data accessor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncopy_dollar()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nYour monetary locale is 'ja_JP.UTF-8'\nTry `¥`(df, col) and df%¥%col\n```\n:::\n\n```{.r .cell-code}\n`¥`(mtcars, cyl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n```\n:::\n:::\n\n\nOh, and there's no point trying to do this if your locale already uses the dollar for currency. I know you want as many dollars as possible, but don't be greedy.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setlocale(\"LC_MONETARY\", locale = \"en_NZ.UTF-8\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"en_NZ.UTF-8\"\n```\n:::\n\n```{.r .cell-code}\ncopy_dollar()\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in copy_dollar(): KIWI CONSPIRATOR!\n```\n:::\n:::\n\n\nI'll reset my settings to the motherland to prevent any accidental borking.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setlocale(locale = \"en_GB.UTF-8\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_US.UTF-8\"\n```\n:::\n:::\n\n\nNothing ever goes wrong in Britain, after all.\n\n## Separate your sheep from your goats\n\nWhile you go and adjust your locale in an act of defiance, be on the lookout for the next New Zealander conspiracy. \n\nI heard that they want to replace the ampersand (`&`) symbol in R version 5 with `NEWZEAL&`, so stay on your toes.\n\nHang on...\n\nI think I used sheep-related phrases in all the section titles of this post. And aren't there like [10 sheep per person in New Zealand](https://en.wikipedia.org/wiki/Sheep_farming_in_New_Zealand)? \n\nThey've got to me already!\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-08-20 22:50:04 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2 compiler_4.3.1    fastmap_1.1.1     cli_3.6.1        \n [5] tools_4.3.1       htmltools_0.5.5   rstudioapi_0.15.0 yaml_2.3.7       \n [9] rmarkdown_2.23    knitr_1.43.1      jsonlite_1.8.7    xfun_0.39        \n[13] digest_0.6.33     rlang_1.1.1       evaluate_0.21    \n```\n:::\n:::\n\n</details>\n\n[^sorry]: With apologies to all the lovely people of New Zealand.\n[^trick]: 'Illusions, Michael.'\n[^recompile]: Yep, you could probably change this in the R source code and recompile it, but... effort.\n[^golf]: I heard that [code golf](https://en.wikipedia.org/wiki/Code_golf) is one of the new sports on display this year?\n[^eng]: Yes, I'm aware I've written the messages in English only. I can only break down one international barrier at once, pal.\n[^assign]: In other words, assign like the single-headed 'gets' operator, `<-`, but _more_ so! You may know that [I have strong feelings about assigment operators](https://www.rostrum.blog/2021/03/13/assign/), lol.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
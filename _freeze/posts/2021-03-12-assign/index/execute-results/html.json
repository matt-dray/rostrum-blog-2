{
  "hash": "cb1ecb18ea6e95f5bd5bad21fc629327",
  "result": {
    "markdown": "---\ntitle: Protect yourself from equals assignment!\ndate: 2021-03-13\nslug: assign\ncategories:\n  - flamewar\n  - r\ndraft: no\n---\n\n::: {.cell}\n\n:::\n\n\n![](resources/cmm.png){fig-alt=\"A man sits at a table with a banner that has on it R's left assignment operator (<-) and underneath it says 'change my mind'.\" width=\"75%\"}\n\n## tl;dr\n\nI present you a function that warns if an R script contains _The Assignment Operator That Shall Not Be Named_.\n\n## Assign of the times\n\nSo, it's been confirmed with [extremely robust and objective evidence](https://twitter.com/kevcunningham/status/1370382498795040769?s=20): the left-assignment arrow (`x <- 1`) is better than equals (`x = 1`) for assignment in R.[^actually]\n\nSo, unless you hate democracy, you should protect yourself from aberrant code that uses the cursed symbol.\n\nBut what if a nefarious colleague still sends you their scuffed code? \n\n## Assignment refinement\n\nI've created the `appraise_assignment()` function that will peek at a suspect script and warn you if it contains the foul mark.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nappraise_assignment <- function(file, destroy = FALSE) {\n  \n  tokens <- getParseData(parse(file))[[\"token\"]]\n  \n  if (any(tokens == \"EQ_ASSIGN\")) {            # if '='\n    warning(\"\\nme = 'disgusted'\") \n    if (destroy == TRUE) {\n      answer <- readline(\"Destroy file? y/n: \")\n      if (answer == \"y\") cat(\"Have mercy! This time...\")\n    }\n  } else if (any(tokens == \"RIGHT_ASSIGN\")) {  # if '<-'\n    cat(\"'unorthodox' -> you\\n\")\n  } else if (any(tokens == \"LEFT_ASSIGN\")) {   # if '->'\n    cat(\"you <- 'hero'\\n\")\n  } else {\n    cat(\"anyway(assignment(is(even('what'))))\\n\")\n  }\n  \n}\n```\n:::\n\n\nBasically, we `parse()` an input file and then the function uses `getParseData()` to extract 'tokens' (i.e. maths symbols, special operators, variables, etc) from the R expressions within.\n\nIn particular, it spots the token called `EQ_ASSIGN`, which is when `=` is used in the context of assignment.\n\n## I saw the assign\n\nFor demonstration purposes, I've written four temporary files containing left assign (`<-`), right assign (`->`), equals (`=`), and no assignment at all.[^global] Our function will catch even a single deviation in a given file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp <- tempdir()  # temp location to store files\n\npurrr::walk2(\n  c(\"x <- 1\", \"x <- 1; y -> 1\", \"x <- 1; y = 1\", \"x\"),\n  c(\"left\", \"right\", \"equals\", \"none\"),\n  ~writeLines(.x, file.path(temp, paste0(.y, \".R\")))\n)\n\nlist.files(temp, pattern = \".R$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"equals.R\" \"left.R\"   \"none.R\"   \"right.R\" \n```\n:::\n:::\n\n\nFirst, let's pass the file containing the unquestionably correct assignment operator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nappraise_assignment(file.path(temp, \"left.R\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nyou <- 'hero'\n```\n:::\n:::\n\n\nRight-assignment is left-assignment's less-handsome sibling.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nappraise_assignment(file.path(temp, \"right.R\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'unorthodox' -> you\n```\n:::\n:::\n\n\nHold steady...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nappraise_assignment(file.path(temp, \"equals.R\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in appraise_assignment(file.path(temp, \"equals.R\")): \nme = 'disgusted'\n```\n:::\n:::\n\n\nPhew, we got a warning, so we know the file is dangerous and should never be opened.\n\nIn fact, if you set the argument `destroy = TRUE` in `appraise_assignment()`, you'll be prompted to irrecoverably annihilate the rotten file forever.[^destroy]\n\nFor completeness, is it really an R script if it doesn't contain any assignment at all?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nappraise_assignment(file.path(temp, \"none.R\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nanyway(assignment(is(even('what'))))\n```\n:::\n:::\n\n\n## Assigning off\n\nIn conclusion, some assignment operators were created more equal than others. See [Colin Fay's round-up](https://colinfay.me/r-assignment/) to learn more about the history and plethora of these symbols (and be happy that the underscore is no longer legitimate).\n\nAnyway, welcome to the best timeline, where we all recognise `<-` unequivocally as the champion and `=` can get absolutely rekt.\n\nIf I had one wish though, it would be to make the left-assign arrow even more powerful. [How about making it really long?](https://twitter.com/mattdray/status/1371409640794300418?s=20) 23 hyphens seems sufficiently dominant.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <----------------------- 1\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nIt's a really long arrow, so I call it 'the spear'.[^hyphens] I look forward to its adoption by R Core.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-07-17 20:37:32 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] crayon_1.5.2       vctrs_0.6.3        cli_3.6.1          knitr_1.43.1      \n [5] rlang_1.1.1        xfun_0.39          rex_1.2.1          processx_3.8.1    \n [9] purrr_1.0.1        xmlparsedata_1.0.5 jsonlite_1.8.7     rprojroot_2.0.3   \n[13] htmltools_0.5.5    ps_1.7.5           rmarkdown_2.23     evaluate_0.21     \n[17] fastmap_1.1.1      yaml_2.3.7         lifecycle_1.0.3    cyclocomp_1.1.0   \n[21] compiler_4.3.1     lintr_3.0.2        htmlwidgets_1.6.2  rstudioapi_0.15.0 \n[25] digest_0.6.31      R6_2.5.1           callr_3.7.3        magrittr_2.0.3    \n[29] tools_4.3.1        withr_2.5.0        lazyeval_0.2.2     xml2_1.3.5        \n[33] remotes_2.4.2      desc_1.4.2        \n```\n:::\n:::\n\n</details>\n\n[^actually]: Actually, I don't really care which one you use, but that's less of a funny take. I prefer the left assignment operator because look! It's a little arrow! Quirky! Esoteric! An extra keystroke to exercise your fingers!\n[^destroy]: Well, not really, because I don't want you to delete any of your files. But rest assured I've included `file.remove()` in my local version of the function and I'm not afraid to use it.\n[^global]: We do not talk about `<<-`.\n[^hyphens]: In other words, R evaluates this as an object, `x`, being assigned a numeric value that has an odd number of 'negative' symbols that cancel each other out.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
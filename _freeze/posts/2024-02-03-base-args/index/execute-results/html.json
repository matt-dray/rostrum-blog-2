{
  "hash": "0fcf1b73a9412d6e85fa266f099d0f44",
  "result": {
    "markdown": "---\ntitle: \"Start an argument with R\"\ndate: 2024-02-03\nslug: \"base-args\"\nimage: resources/argument.png\ncategories:\n  - r\n---\n\n\n![](resources/argument.png){fig.alt=\"Two poorly drawn angry faces. One says 'str(x)' above it and the other says str(x, max.level = 1)'.\"}\n\n## tl;dr\n\nSome (lesser-known?) arguments to some common base-R functions.\n\n## Getting argumentative\n\nThere's been a recent glut of posts about useful base-R functions, like the ones by [Maëlle](https://masalmon.eu/2023/10/20/three-neat-functions/), [Isabella](https://ivelasq.rbind.io/blog/not-so-basic-base-r-functions/) and [Yihui](https://yihui.org/en/2023/10/three-functions/).\n\nI bring you a twist on the theme. Four useful _arguments_ from four everyday base functions:\n\n* `max.level` in `str()`\n* `n` in `print()`\n* `include.only` in `library()`\n* `drop` in `` `[` ``\n\nFeel free to move on if you know all of these.\n\n### Structural integrity\n\n`str()` prints an object's structure. It's especially helpful for viewing lists in a compact hierarchical fashion. Consider this nested list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnested_list <- list(\n  x = list(x1 = 1:3, x2 = list(x3 = 4:6, x4 = 7:9)),\n  y = list(y1 = list(y2 = list(y3 = mtcars))),\n  z = list(z1 = CO2, z2 = list(z4 = 100, z5 = chickwts), z3 = list(z5 = 1))\n)\n```\n:::\n\n\nHere's the output we get from a simple `str()` call:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(nested_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ x:List of 2\n  ..$ x1: int [1:3] 1 2 3\n  ..$ x2:List of 2\n  .. ..$ x3: int [1:3] 4 5 6\n  .. ..$ x4: int [1:3] 7 8 9\n $ y:List of 1\n  ..$ y1:List of 1\n  .. ..$ y2:List of 1\n  .. .. ..$ y3:'data.frame':\t32 obs. of  11 variables:\n  .. .. .. ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n  .. .. .. ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...\n  .. .. .. ..$ disp: num [1:32] 160 160 108 258 360 ...\n  .. .. .. ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...\n  .. .. .. ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n  .. .. .. ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...\n  .. .. .. ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...\n  .. .. .. ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...\n  .. .. .. ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...\n  .. .. .. ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...\n  .. .. .. ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...\n $ z:List of 3\n  ..$ z1:Classes 'nfnGroupedData', 'nfGroupedData', 'groupedData' and 'data.frame':\t84 obs. of  5 variables:\n  .. ..$ Plant    : Ord.factor w/ 12 levels \"Qn1\"<\"Qn2\"<\"Qn3\"<..: 1 1 1 1 1 1 1 2 2 2 ...\n  .. ..$ Type     : Factor w/ 2 levels \"Quebec\",\"Mississippi\": 1 1 1 1 1 1 1 1 1 1 ...\n  .. ..$ Treatment: Factor w/ 2 levels \"nonchilled\",\"chilled\": 1 1 1 1 1 1 1 1 1 1 ...\n  .. ..$ conc     : num [1:84] 95 175 250 350 500 675 1000 95 175 250 ...\n  .. ..$ uptake   : num [1:84] 16 30.4 34.8 37.2 35.3 39.2 39.7 13.6 27.3 37.1 ...\n  .. ..- attr(*, \"formula\")=Class 'formula'  language uptake ~ conc | Plant\n  .. .. .. ..- attr(*, \".Environment\")=<environment: R_EmptyEnv> \n  .. ..- attr(*, \"outer\")=Class 'formula'  language ~Treatment * Type\n  .. .. .. ..- attr(*, \".Environment\")=<environment: R_EmptyEnv> \n  .. ..- attr(*, \"labels\")=List of 2\n  .. .. ..$ x: chr \"Ambient carbon dioxide concentration\"\n  .. .. ..$ y: chr \"CO2 uptake rate\"\n  .. ..- attr(*, \"units\")=List of 2\n  .. .. ..$ x: chr \"(uL/L)\"\n  .. .. ..$ y: chr \"(umol/m^2 s)\"\n  ..$ z2:List of 2\n  .. ..$ z4: num 100\n  .. ..$ z5:'data.frame':\t71 obs. of  2 variables:\n  .. .. ..$ weight: num [1:71] 179 160 136 227 217 168 108 124 143 140 ...\n  .. .. ..$ feed  : Factor w/ 6 levels \"casein\",\"horsebean\",..: 2 2 2 2 2 2 2 2 2 2 ...\n  ..$ z3:List of 1\n  .. ..$ z5: num 1\n```\n:::\n:::\n\n\nOof, that's a little bit too much information to flood my console with.\n\nLuckily you can use the `max.level` argument to restrict the depth to which the list is printed. Here's the top layer only, which has a depth of 1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(nested_list, max.level = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ x:List of 2\n $ y:List of 1\n $ z:List of 3\n```\n:::\n:::\n\n\nNow I have a very high-level overview: this is list containing three list objects of certain lengths.\n\nLet's go deeper.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(nested_list, max.level = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ x:List of 2\n  ..$ x1: int [1:3] 1 2 3\n  ..$ x2:List of 2\n $ y:List of 1\n  ..$ y1:List of 1\n $ z:List of 3\n  ..$ z1:Classes 'nfnGroupedData', 'nfGroupedData', 'groupedData' and 'data.frame':\t84 obs. of  5 variables:\n  .. ..- attr(*, \"formula\")=Class 'formula'  language uptake ~ conc | Plant\n  .. .. .. ..- attr(*, \".Environment\")=<environment: R_EmptyEnv> \n  .. ..- attr(*, \"outer\")=Class 'formula'  language ~Treatment * Type\n  .. .. .. ..- attr(*, \".Environment\")=<environment: R_EmptyEnv> \n  .. ..- attr(*, \"labels\")=List of 2\n  .. ..- attr(*, \"units\")=List of 2\n  ..$ z2:List of 2\n  ..$ z3:List of 1\n```\n:::\n:::\n\n\nNow we've unpacked the next layer of the onion and can see that the contained objects are made up of vectors and more yet more lists.\n\nFor me, this is a nice way to get the sense of structure without seeing the entire content. I think it beats the interactive list `View()` in RStudio as well, which can't be opened to an arbitrary depth in one go.\n\n### Carriage feed\n\n`print()` is a ubiquitous function across most programming languages. In R, you might just type an object's name to show it. Here's a tibble with 21 rows to demonstrate.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchick_tbl <- tibble::as_tibble(ChickWeight[1:21, ])\nchick_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 21 × 4\n   weight  Time Chick Diet \n    <dbl> <dbl> <ord> <fct>\n 1     42     0 1     1    \n 2     51     2 1     1    \n 3     59     4 1     1    \n 4     64     6 1     1    \n 5     76     8 1     1    \n 6     93    10 1     1    \n 7    106    12 1     1    \n 8    125    14 1     1    \n 9    149    16 1     1    \n10    171    18 1     1    \n# ℹ 11 more rows\n```\n:::\n:::\n\n\nYou might use `head()` on a data.frame to prevent printing the whole thing, which defaults to showing 6 rows. Tibbles are truncated by default to 10, but a nice feature is that they'll show a few more if there's slightly more than 10 rows total. But what if you want more control?\n\nWell, in both `print()` and `head()` is the `n` argument. No surprise: it lets you select how many rows of your data.frame or tibble get shown in the console.\n\nI particularly like this when I have a tibble I'd like to inspect the entirety of, but it gets truncated by default. I'll often find myself doing this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(chick_tbl, n = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 21 × 4\n   weight  Time Chick Diet \n    <dbl> <dbl> <ord> <fct>\n 1     42     0 1     1    \n 2     51     2 1     1    \n 3     59     4 1     1    \n 4     64     6 1     1    \n 5     76     8 1     1    \n 6     93    10 1     1    \n 7    106    12 1     1    \n 8    125    14 1     1    \n 9    149    16 1     1    \n10    171    18 1     1    \n11    199    20 1     1    \n12    205    21 1     1    \n13     40     0 2     1    \n14     49     2 2     1    \n15     58     4 2     1    \n16     72     6 2     1    \n17     84     8 2     1    \n18    103    10 2     1    \n19    122    12 2     1    \n20    138    14 2     1    \n21    162    16 2     1    \n```\n:::\n:::\n\n\nYou can set an `option()` to see more tibble rows by default, but I'm usually okay with its normal truncating behaviour.\n\n### Library check out\n\n`library()` calls are a staple of R scripts. Let's say I'm attaching the {lme4} package because I want to use the famous `cake` data set[^baath].\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lme4, quietly = TRUE)\n```\n:::\n\n\nAha, no, it's not the `quietly` argument I want to talk about[^shh], though it is handy for stopping messages from being printed.\n\nOf course, what `library()` does is let you access objects—like functions and data sets—from a named package. How many objects did we attach from {lme4}?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(ls(\"package:lme4\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 102\n```\n:::\n:::\n\n\nBlimey, all we wanted was `cake`. But actually, we can be more selective with `library()` using the `include.only` argument (note that you can `exclude` as well).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndetach(\"package:lme4\")\nlibrary(lme4, include.only = \"cake\")\nls(\"package:lme4\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"cake\"\n```\n:::\n:::\n\n\nWhy would you want to do this? This can keep your environment tidy—if that's something you care about—but also helps prevent conflicts between objects that might already exist in your environment. \n\nIt also means you've been explicit about the origin of any objects used in your script. If I see `cake` referenced in your script but can't see how it was derived, I can take a look at that library call to see that you imported it from {lme4}.\n\nAt worst, this might be a nice thing for Python users, who love to `from x import y`.\n\n### Score a drop goal\n\nThe square bracket, `` `[` ``, is a function[^fn] for extracting elements out of objects, like rows and columns of a data.frame. Of course, it's typically used as a pair of square brackets.\n\nSo the following will give you the first three rows of the `cake` data.frame for the columns `temp` and `angle`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncake[1:3, c(\"temp\", \"angle\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  temp angle\n1  175    42\n2  185    46\n3  195    47\n```\n:::\n:::\n\n\nWhat happens when you select a single column? You get one column back, right?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncake[1:3, \"temp\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 175 185 195\n```\n:::\n:::\n\n\nHa, lol, no. You get a vector. This might be a problem if you're programmatically passing column names into `` `[` `` and you're always expecting a data.frame as output.\n\nLuckily, you can guard against this by ensuring the returned doesn't `drop` to its simplest dimension.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncake[1:3, \"angle\", drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  angle\n1    42\n2    46\n3    47\n```\n:::\n:::\n\n\nI can see how a third argument inside the square brackets may look spooky if you though you could only pass two when working on a data.frame[^dt].\n\n## Mutual agreement\n\nThese were unlikely to have blown your mind, especially if you're a seasoned user. But I've live-coded recently with some folks who hadn't seen them before.\n\nLet me know if you want to argue your case for some other under-appreciated arguments.\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2024-02-03 17:21:54 GMT\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] lme4_1.1-35.1 Matrix_1.6-0 \n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5       nlme_3.1-162      cli_3.6.2         knitr_1.45       \n [5] rlang_1.1.3       xfun_0.41         minqa_1.2.6       jsonlite_1.8.7   \n [9] glue_1.7.0        htmltools_0.5.6.1 fansi_1.0.6       rmarkdown_2.25   \n[13] grid_4.3.1        evaluate_0.23     tibble_3.2.1      MASS_7.3-60      \n[17] fastmap_1.1.1     yaml_2.3.8        lifecycle_1.0.4   compiler_4.3.1   \n[21] Rcpp_1.0.11       htmlwidgets_1.6.2 pkgconfig_2.0.3   rstudioapi_0.15.0\n[25] lattice_0.21-8    digest_0.6.33     nloptr_2.0.3      utf8_1.2.4       \n[29] pillar_1.9.0      splines_4.3.1     magrittr_2.0.3    tools_4.3.1      \n[33] boot_1.3-28.1    \n```\n:::\n:::\n\n</details>\n\n[^fn]: Recall that `` `[` `` is actually a function so you can write `` `[`(mtcars, 1:3, c(\"cyl\", \"hp\")) `` to achieve the same things as `mtcars[1:3, c(\"cyl\", \"hp\"]`.\n[^shh]: Note that package startup messages can also be controlled en masse by wrapping library calls in `suppressPackageStartupMessages()`, which I've [talked about before](https://www.rostrum.blog/posts/2021-08-27-zzz/). And also written about [the sheer length of this function name](https://www.rostrum.blog/posts/2021-11-27-long-fns/).\n[^dt]: Of course, three arguments to `` [` `` is bread and butter for {data.table} users!\n[^baath]: Rasmus recently [did some sleuthing](https://www.sumsar.net/blog/source-of-the-cake-dataset/) to discover the source of this data set! A great read.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "fe6ffea54a0b9d8da94e4ec3612f816f",
  "result": {
    "markdown": "---\ntitle: Combing through my trash\ndate: 2023-09-09\nslug: trash-combing\ncategories:\n  - plunderplot\n  - r\n  - r.oguelike\n---\n\n\n![_Procyon lotor_. Released graciously by the author under CC0.](resources/raccoon.png){fig-alt=\"A crudely drawn racoon holding some kind of nugget with the litter 'R' on it.\" width=50% fig-align=\"left\"}\n\n## tl;dr\n\nThree little R things I never finished. Or are useless. Or both?\n\n## Refuse\n\nIt'll not surprise you that after all these years of blogging and farting around with R that I have a huge [floating garbage patch](https://en.wikipedia.org/wiki/Great_Pacific_garbage_patch) of odds and sods that I sketched out at some point, but never finished or never found a use for.\n\nJoin me, fellow trash pandas, as we carouse through the accumulated bilge to dig up some certified D-rank content. Today I have three things to share:\n\n1. A method for finding treasure.\n2. Infinite abandoned dungeons.\n3. An underwhelming 'physics' 'simulation' for 'secret' purposes.\n\n## 1. {plunderplot}\n\n`locator()` is [a funny base R function](https://rdrr.io/r/graphics/locator.html) that lets you click a point on a plot to retrieve its coordinates.\n\nI had a little `locator()` phase on this blog: I used it to make [the {pixeltrix} package](https://www.rostrum.blog/index.html#category=pixeltrix) for point-and-click editing of 'pixel art' and wrote a post about [extracting coordinates from fictitious maps](https://www.rostrum.blog/posts/2021-11-04-kanto-locator/).\n\n[The {plunderplot} package](https://github.com/matt-dray/plunderplot) was an extension of the 'data extraction' idea, really. The `plunder()` function plots your image (e.g. a [map of Sodor](https://en.wikipedia.org/wiki/Sodor_(fictional_island)) or a plot of [Thomas the Tank mods](https://www.youtube.com/watch?v=yNaTZV8qS1I) in popular videogames over time) and asks you to click and label the axes for calibration. Then you're invited you to click points on the plot and get in return a dataframe of the coordinates.\n\nSo you're plundering coordindates from a plot, right? Hence the name. Consequently, the package README uses some piratespeak to explain how it works. I won't subject you to that here.\n\nTo keep with the theme, the example image here is a simple treasure map with treasure markers[^windwaker].\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreasure <- plunderplot::plunder(\"resources/treasure.png\", labels = TRUE)\n```\n:::\n\n\n![](resources/treasure.png){fig-alt=\"Chart titled 'Treasure locations on Rectangle Island'. It's a plot with x limits of 0 to 100 and y limits of 0 to 50. There are concentric rectangles that look like an island in the sea. There are three red crosses on the island.\" width=\"100%\"}\n\nThe console will talk to you during the process. You'll be instructed to do things, one after the other. You calibrate the plot, select the points and optionally label them.\n\n```\nClick x axis min\nClick x axis max\nClick y axis min\nClick y axis max\nType value at x axis min: 0\nType value at x axis max: 100\nType value at y axis min: 0\nType value at y axis max: 50\nClick points on the chart, press ESC when finished\nType a label for point 1: west\nType a label for point 2: centre\nType a label for point 3: east\nDone\n```\n\nAnd then you get your coordinates back:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreasure\n```\n:::\n\n```\nx        y labels\n1 35.97651 32.19178   west\n2 55.94714 23.15068 centre\n3 61.96769 26.16438   east\n```\n\nExcept, well, this has done before. More than once. I was aware of [the {juicr} package](https://github.com/mjlajeunesse/juicr), which contains an interactive GUI for extracting data out of plots in scientific PDFs and that sort of thing, but there's already CRAN packages with {plunderplot}'s functionality: [{digitize}](https://CRAN.R-project.org/package=digitize ) and [{metaDigitise}](https://cran.r-project.org/package=metaDigitise), which have been around for years.\n\nSo it's not more useful than other tools but I had fun coding it and I've used it myself for 'real' applications more than once.[^copium]\n\n## 2. Perlin dungeon\n\nI made a toy [roguelike](https://en.wikipedia.org/wiki/Roguelike) 'game' in [the {r.oguelike} package](https://www.rostrum.blog/index.html#category=r.oguelike)[^games]. An important feature of games in this genre is a procedurally-generated tile-based dungeon map for your character to do an adventure in. \n\nI came up with [a basic system](https://www.rostrum.blog/posts/2022-05-01-dungeon/) to create convincing connected caverns, but there are many ways to create this kind of map. One method is to use [Perlin noise](https://en.wikipedia.org/wiki/Perlin_noise), which [the {ambient} package](https://CRAN.R-project.org/package=ambient) can help you generate.\n\nThis `print_perlin_dungeon()` function never made it into the package, but it's a pretty straightforward way of creating 'dungeons' with good balance between randomness and structure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint_perlin_dungeon <- function(\n    m,  # matrix of perlin noise via ambient::noise_perlin()\n    invert = FALSE  # flips tile positions (use set.seed before generating noise)\n) {\n  \n  tile_wall = \"#\"\n  tile_floor = \".\"\n  \n  # Standardise noise values from 0 to 1\n  m_bin <- round((m - min(m)) / (max(m) - min(m)))\n  \n  # Lay floor and wall tiles, flip if invert = TRUE\n  if (!invert) {\n    m_tiled <- ifelse(m_bin == 1, tile_wall, tile_floor)\n  } else {\n    m_tiled <- ifelse(m_bin == 0, tile_wall, tile_floor)\n  }\n  \n  # Block off edges with wall tiles\n  m_tiled[, 1] <- tile_wall\n  m_tiled[, ncol(m_tiled)] <- tile_wall\n  m_tiled[1, ] <- tile_wall\n  m_tiled[nrow(m_tiled), ] <- tile_wall\n  \n  # Print to console, line-by-line\n  for (i in seq(nrow(m_tiled))) {\n    cat(m_tiled[i, ], \"\\n\")\n  }\n  \n}\n```\n:::\n\n\nThe `noise_perlin()` function in the {ambient} package has lots of twiddly knobs for arguments. I can't profess any science behind my choices here:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- ambient::noise_perlin(\n  dim = c(30, 42),\n  frequency = 0.2,\n  interpolator = \"linear\",\n  fractal = \"fbm\",\n  octaves = 2,\n  lacunarity = 3,\n  gain = 0.5,\n  pertubation = \"none\",\n  pertubation_amplitude = 1\n)\n```\n:::\n\n\nYou can pass the matrix output from `noise_perlin()` to the `print_perlin_dungeon()` to print the map to the console.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint_perlin_dungeon(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # \n# . . . . . . . . . # # # . # # # . . . . # # # # # # # # # # # # # # # . . # # # # \n# . . . . . . . # # # # # # # # # # # # # # # # # # # # # # # # # # # . . # # # # # \n# . . . . . . . # # # # # # # # . . # . # # # # # # # # # # # # # # # . # # # . # # \n# . . . . . . . . # # # # # # # . . . . # # # # # # # # # # # # . . # . # # # # # # \n# . . . # . . . . # . # # # # . . . . . . . # # . . . # # . . # . . . . # # # # . # \n# . . . # . # # # # # # # . # . . . . . . . . . . . . . . . . . . . . # # . . . . # \n# . . . . # # # # # . # . . . . . . . . . . . . . . . . . . . . . . . . # # # . . # \n# . . . # # # # # # . # . . . . . . . . . . . . . . . . . . . . . . . . . # # . . # \n# . . . . # # # # # . . . . # . . . . # # . . . . . . . . . . . . . . . . . # . . # \n# . . . . . # # # # . # . . # . . . . # . . . . . . . . . . . # . . # . # # # # . # \n# . . . . # # # # # # . . . . # . . # . . . . . . # # # # . # # # # # # # # # # # # \n# . . . . # . # # # . . . . . . . # # . # # . . . # . . # # # # # # . . # # # # # # \n# . . . . # # # # # . . . . . . # . . # # # . . # # . . . # # # # # # . . # # # # # \n# . . . . . . # # # . . . . . . # # . . # # # # # . . . . # # # # # # . . . . . # # \n# . . . . . # # # # . . . . . . # # # . . # # # # . . . . . . # # # # . . . . . . # \n# . . . # # # # # # . . . . . . . . . . . # # # # . # . . . . # # # # . . . . . . # \n# . . . # # # # # . . . . . . . . . # . . # # # # # # . . . . # . . # # . . . . # # \n# . . . # # # # # . . . . . . . # . # . . # # # # # # . . . . . . . # # . . . # # # \n# # . . # # # . . . . . . # # . # . . . . # # # # # # . . . . . . . . . . # # # . # \n# . . . . . # . . . . # # # # . # . . # . . . . # . . . . . . . . . . . # # # # . # \n# . . . . . . . . . . # # # # # # # # # # . . . . . . . . # # . . . . # # # # . . # \n# . . . . . . . . . # . # # # # # # # # # . . . . . . # # # # . . . . . . . . . . # \n# . . . . . . . . . # . # # # # . # # # # . . . . . . # # # # # . . . . . . . . . # \n# . # # . . . # # # . . # # # . . # . . . . . . . . # # # # # . . . . . . . . . . # \n# # # # # . . # # # . . # # . . . . . . . . . . . . # # # # . . # # . . . . . # . # \n# # # # # # # # # # # # # . . # . . . . . . . . . # # # # . . . . . . # . # . . # # \n# # # # # # # # # # # # . . . . . . . . . . . . . # # # . . . . . . . . . # # . . # \n# # # # # # # # # # # # . . . . . . . . . . . . . # # . . . . . . . . . . # # # . # \n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # \n```\n:::\n:::\n\n\nOf course, this will generate a new map every time you run it. I would say it's major flaw is that it's missing an open path between all the caverns, but otherwise it looks pretty cavelike to me. If I squint.\n\nA version of this code is [in a GitHub Gist](https://gist.github.com/matt-dray/fd5bf4b6560638e154353e4ec5c8b98a). It might even have been in a tweet once.\n\n## 3. Droplet 'physics'\n\nI experimented with this in support of a different (secret!) project that may never finish.\n\nIt's a cross between the physics of water flowing under gravity and a pathfinding system. Except that description is way too grandiose. Basically, a droplet tile (`o`) 'flows' from top to bottom of a matrix defining a 'map' that you create, passing through empty tiles (`.`) and given 'collisions' with block tiles (`#`).\n\nHere's a basic map to start, defined as a matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblock <- \"#\"\nempty <- \".\"\ndrop  <- \"o\"\n\nm <- matrix(\n  c(1, 0, 0, 0, 0,\n    1, 1, 0, 0, 0,\n    1, 1, 1, 0, 0,\n    0, 0, 0, 0, 1,\n    0, 0, 0, 1, 1,\n    1, 0, 1, 1, 1,\n    1, 1, 1, 1, 1),\n  nrow = 7,\n  byrow = TRUE\n)\n\nm[which(m == 1)] <- block\nm[which(m == 0)] <- empty\nm[8] <- drop\n\nprint(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,] \"#\"  \"o\"  \".\"  \".\"  \".\" \n[2,] \"#\"  \"#\"  \".\"  \".\"  \".\" \n[3,] \"#\"  \"#\"  \"#\"  \".\"  \".\" \n[4,] \".\"  \".\"  \".\"  \".\"  \"#\" \n[5,] \".\"  \".\"  \".\"  \"#\"  \"#\" \n[6,] \"#\"  \".\"  \"#\"  \"#\"  \"#\" \n[7,] \"#\"  \"#\"  \"#\"  \"#\"  \"#\" \n```\n:::\n:::\n\n\nYou can make this map more or less complicated. You can even use [{pixeltrix}](https://github.com/matt-dray/pixeltrix) to make a map by interactively clicking squares in a plot window to receive back a matrix.\n\nThe code to run 'the simulation' is just a `repeat` loop that wipes and draws to the console following some basic `if`s. It will `break` when the droplet comes to a stop.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrepeat {\n  \n  cat(\"\\014\")\n  \n  for (row in seq(nrow(m))) {\n    cat(m[row, ], \"\\n\", sep = \" \")\n  }\n  \n  Sys.sleep(1)\n  \n  droplet_i      <- which(m == drop)\n  droplet_i_save <- droplet_i\n  below_i        <- droplet_i + 1\n  \n  if (m[below_i] == empty) {\n    m[droplet_i] <- empty\n    m[below_i]   <- drop\n  }\n  \n  if (m[below_i] == block) {\n    \n    left_i  <- droplet_i - nrow(m)\n    right_i <- droplet_i + nrow(m)\n    \n    is_left_open  <- FALSE\n    is_right_open <- FALSE\n    \n    if (m[left_i] == empty)  is_left_open  <- TRUE\n    if (m[right_i] == empty) is_right_open <- TRUE\n    \n    if (is_left_open & is_right_open) {\n      sampled_direction_i <- sample(c(left_i, right_i), 1)\n      m[droplet_i]           <- empty\n      m[sampled_direction_i] <- drop\n    }\n    \n    if (is_left_open & !is_right_open) {\n      m[droplet_i] <- empty\n      m[left_i]    <- drop\n    }\n    \n    if (!is_left_open & is_right_open) {\n      m[droplet_i] <- empty\n      m[right_i]   <- drop\n    }\n    \n  }\n  \n  droplet_i <- which(m == drop)\n  if (droplet_i == droplet_i_save) break\n}\n```\n:::\n\n\nHere's a little gif showing how this basic example looks in the console:\n\n![](resources/droplet.gif){fig-alt=\"Animation showing a text matrix of tiles representing empty space (a period mark), a block (a hashmark) or a droplet (the letter 'o'), which is falling from the top to the bottom of the matrix, given collisions with the block tiles. It coimes to rest near the bottom in a well made of surrounding blocks.\" width=25% fig-align=\"left\"}\n\nAlas, I am an untrustworthy narrator! The droplet will scooch left and right forever on a flat surface. The animation only stops if the droplet is trapped at the lowest point, like in the gif above. No one really understands physics though, right, so it's basically fine.\n\nI think I wanted to have the droplet travel diagonally instead of across and down; try introducing tiles with different properties (e.g. angled, like `\\` and `/`); and have the ability to add more than one droplet at a time. I'll probably explain eventually about why I made this subpar toy.\n\nYou can find a version of this code [in a GitHub gist](https://gist.github.com/matt-dray/0f4fba9a7e57bdb093d0b9433a983c61) if you really must.\n\n## Now wash your hands\n\nNothing here is going to change your life; I just wanted to set these ideas free for purposes of spiritual atonement.\n\nFor fun toys and proper R noodlings you can always check out anything by Mike ([coolbutuseless](https://coolbutuseless.github.io/)), or stuff like [Tomaz](https://tomaztsql.wordpress.com/)'s 'Little Useless-Useful' series. Far more fruitful.\n\nHaving said this, this may be the first post in a series. I'm not afraid to put my hand back in the waste disposal unit. Are you?\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-09-08 22:58:16 BST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2 compiler_4.3.1    fastmap_1.1.1     ambient_1.0.2    \n [5] cli_3.6.1         tools_4.3.1       htmltools_0.5.5   rstudioapi_0.15.0\n [9] yaml_2.3.7        rmarkdown_2.23    knitr_1.43.1      jsonlite_1.8.7   \n[13] xfun_0.39         digest_0.6.33     rlang_1.1.1       evaluate_0.21    \n```\n:::\n:::\n\n</details>\n\n[^games]: [R is a game engine, fight me](https://www.rostrum.blog/posts/2023-04-02-splendid-r-games/).\n[^copium]: \\*Breathes in deep breath of copium.\\*\n[^windwaker]: This just looks like a screenshot of treasure locations from _The Legend of Zelda: The Windwaker_, which I assume I was replaying at the time.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
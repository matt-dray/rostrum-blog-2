{
  "hash": "3f7ae19c5330ad9ec4ea40f95cb59c45",
  "result": {
    "markdown": "---\ntitle: Matt Dray Teaches (Data) Typing\ndate: 2023-04-23\nslug: type-convert\ncategories:\n  - a11ytables\n  - base\n  - ms-office\n  - r\n---\n\n\n![Confirmed: [Unown](https://bulbapedia.bulbagarden.net/wiki/Unown_(Pok%C3%A9mon)) is character type.[^unown]](resources/unown.png){fig-alt=\"A crudely drawn picture of three PokÃ©mon as elements of a vector being constructed using R's 'c' function. All three are the PokÃ©mon called Unown, which can be found in multiple forms that represent letters of the alphabet.\" width=\"100%\"}\n\n## tl;dr\n\nI forgot that the base R function `type.convert()` exists. Handy for 'simplifying' all the columns of a dataframe to appropriate data types.\n\n## Suppression depression\n\n[{a11ytables}](https://co-analysis.github.io/a11ytables/) is an R package that lets you generate publishable spreadsheets that follow the UK government's [best practice guidance](https://analysisfunction.civilservice.gov.uk/policy-store/releasing-statistics-in-spreadsheets/).\n\nOne requirement is to replace missing values with placeholder symbols. For example, suppressed data can be replaced with the string `\"[c]\"` ('confidential'). \n\nOf course, R's behaviour means it can store only one data type per column, so a numeric-type column will be automatically converted to character when you introduce at least one string value (i.e. something in `\"quotes\"`).[^coerce]\n\nFor example, this vector is type 'double' (i.e. decimals and not 'whole-number' integers) and has the more general 'numeric' class:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnums <- runif(100)\ntypeof(nums); class(nums)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\nThe whole thing is converted to character type if you append just one character value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(c(nums, \"[c]\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nThis is known behaviour, yes, but it causes a minor annoyance in the xlsx files output from an {a11ytables} workflow: Excel puts a warning marker in the corner of any cell in a text column that contains a numeric value.[^align]\n\n<div class=\"figure\">\n<img src=\"resources/number-text.png\" alt=\"Screenshot of an Excel worksheet. A cell containing a number has a warning that reads 'number stored as text'.\" width=\"100%\"/>\n</div>\n\n[Cat left a GitHub issue](https://github.com/co-analysis/a11ytables/issues/93) related to this: columns entirely made of numbers were being marked by Excel with the 'number in a text column' warning. In this case, it was because Cat's suppression process resulted in _all_ columns being converted to character.\n\nIt would be great to convert back to numeric any columns that did not receive a placeholder symbol during the wrangling process. How can you do this?\n\n## Type specimen\n\nLet's consider a demo example. First I'll attach {dplyr}, which is commonly used by stats producers in the UK government.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages(library(dplyr))\n```\n:::\n\n\nHere's a very simple dataframe, `tbl`, to use as a demo. Column `x` contains values that will need to be suppressed because they're lower than 5. There are no such values in column `y`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1337)\n\ntbl <- tibble(\n  id = LETTERS[1:5],\n  x  = round(runif(5, 0, 10), 2),\n  y  = round(runif(5, 6, 10), 2)\n)\n\ntbl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 Ã— 3\n  id        x     y\n  <chr> <dbl> <dbl>\n1 A      5.76  7.33\n2 B      5.65  9.79\n3 C      0.74  7.12\n4 D      4.54  6.98\n5 E      3.73  6.58\n```\n:::\n:::\n\n\nSo, to borrow and simplify Cat's approach: for each numeric column in `tbl` (i.e. `x` and `y`), replace any value of less than 5 with the placeholder string `\"[c]\"`, otherwise retain the original value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl_supp <- tbl |> \n  mutate(\n    across(\n      where(is.numeric),\n      \\(value) if_else(\n        condition = value < 5, \n        true      = \"[c]\",\n        false     = as.character(value)\n      )\n    )\n  )\n\ntbl_supp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 Ã— 3\n  id    x     y    \n  <chr> <chr> <chr>\n1 A     5.76  7.33 \n2 B     5.65  9.79 \n3 C     [c]   7.12 \n4 D     [c]   6.98 \n5 E     [c]   6.58 \n```\n:::\n:::\n\n\nSo column `x` now contains text values and has predictably been converted to character, which you can see as `<chr>` in the tibble header. But notice that `y` is also character type despite all the numeric values being retained.\n\nThis happened because the `if_else()` we used to create `tbl_supp` required the `true` and `false` arguments to resolve to the same type. The `false` argument must use `as.character()` because `true` resolves to the character value `\"[c]\"`.\n\nIdeally we'd perform our suppression step but column `x` would end up as character and `y` as numeric. How can we achieve this?\n\n## Adjust my type\n\nIn this section are some methods to fix the problem by:\n\n1. Causing yourself further brainache\n2. Using a (relatively little known?) base R function\n3. Doing it 'properly' from the outset\n\n### Type 1: nah\n\nOf course, we could run `tbl_supp |> mutate(y = as.numeric(y))` to convert that specific column back to numeric. But imagine if you have a lot more columns and you can't be sure which ones need to be converted.\n\nMaybe you could apply `as.numeric()` across _all_ columns? Columns of numbers stored as text will then be converted entirely to numeric:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(c(\"1\", \"2\", \"3\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\nBut this causes a problem for character columns that contain text, like our placeholder symbol:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(c(\"1\", \"[c]\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 NA\n```\n:::\n:::\n\n\nSo `\"1\"` becomes `1`, but we're warned that `\"[c]\"` has been converted to `NA` (well, `NA_real_`, which is the numeric form of `NA`). \n\nWe could do something convoluted, like see which columns didn't gain `NA` values and should be retained as numeric. But that's bonkers. This approach ultimately makes things worse because we've actually lost information!\n\nReally we want to check each column to see if it contains numbers only and then convert it to numeric. How?\n\n### Type 2: better\n\nThere's a handy base R function that I had forgotten about: `type.convert()`. \n\nIt takes a vector and, in turn, tries to coerce it to each data type. The process stops when coercion occurs without error. As the help file (`?type.convert`) puts it:\n\n> Given a vector, the function attempts to convert it to logical, integer, numeric or complex, and when additionally as.is = FALSE... converts a character vector to factor. The first type that can accept all the non-missing values is chosen.\n\nAnd handily:\n\n> When the data object x is a data frame or list, the function is called recursively for each column or list element.\n\nSo we can pass our entire dataframe to `type.convert()` and it'll check them all for us:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl_supp_conv <- type.convert(tbl_supp, as.is = TRUE)\n\ntbl_supp_conv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 Ã— 3\n  id    x         y\n  <chr> <chr> <dbl>\n1 A     5.76   7.33\n2 B     5.65   9.79\n3 C     [c]    7.12\n4 D     [c]    6.98\n5 E     [c]    6.58\n```\n:::\n:::\n\n\nAs we wanted, our character column `y` has become numeric type (`<dbl>`) while `x` remains as character. Neato.\n\n### Type 3: betterer\n\nThere are probably better approaches to this problem from the outset, rather than after-the-fact application of `type.convert()`.\n\nAs [Tim](https://www.hiddenelephants.co.uk/) has pointed out, you could actually just use the base R form of `ifelse()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl |> \n  mutate(\n    across(\n      where(is.numeric),\n      \\(value) ifelse(\n        test = value < 5, \n        yes  = \"[c]\",\n        no   = value\n      )\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 Ã— 3\n  id    x         y\n  <chr> <chr> <dbl>\n1 A     5.76   7.33\n2 B     5.65   9.79\n3 C     [c]    7.12\n4 D     [c]    6.98\n5 E     [c]    6.58\n```\n:::\n:::\n\n\nI think people use `dplyr::if_else()` for (a) consistency if they're already using tidyverse in the script and (b) it's 'strictness' compared to `ifelse()`. `if_else()` will force you to declare the `true` and `false` arguments so they resolve to the same type, whereas `ifelse()` will silently force type coercion, which may be undesirable in some cases.\n\nAnother method would be to iterate the suppression over only the columns that need it. For example, you could do that with a simple `for` and `if`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncols_numeric <- names(select(tbl, where(is.numeric)))\n\nfor (col in cols_numeric) {\n  if (any(tbl[col] < 5)) {\n    tbl[col] <- ifelse(\n      tbl[col] < 5,\n      \"[c]\",\n      as.character(tbl[[col]])\n    )\n  }\n}\n\ntbl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 Ã— 3\n  id    x         y\n  <chr> <chr> <dbl>\n1 A     5.76   7.33\n2 B     5.65   9.79\n3 C     [c]    7.12\n4 D     [c]    6.98\n5 E     [c]    6.58\n```\n:::\n:::\n\n\nThis reads as 'for each numeric column that contains at least one value less than 5, replace those values with the placeholder symbol `\"[c]\"`.' \n\n## Preach to the converted types\n\nIt's almost like this post could have just been a tweet saying 'ðŸ˜® yo, `type.convert()` is ðŸª„magicðŸª„ y'all'. But this post is now a handy reference in case anyone has the same problems with Excel's handling of {a11ytables} outputs in future.\n\nAlso I needed to hit my pun quota for the month.[^pun]\n\n## Environment {.appendix}\n\n<details><summary>Session info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nLast rendered: 2023-06-29 12:30:02 CEST\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Zurich\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] dplyr_1.1.2\n\nloaded via a namespace (and not attached):\n [1] digest_0.6.31     utf8_1.2.3        R6_2.5.1          fastmap_1.1.1    \n [5] tidyselect_1.2.0  xfun_0.39         magrittr_2.0.3    glue_1.6.2       \n [9] tibble_3.2.1      knitr_1.43.1      pkgconfig_2.0.3   htmltools_0.5.5  \n[13] generics_0.1.3    rmarkdown_2.22    lifecycle_1.0.3   cli_3.6.1        \n[17] fansi_1.0.4       vctrs_0.6.3       withr_2.5.0       compiler_4.3.1   \n[21] rstudioapi_0.14   tools_4.3.1       pillar_1.9.0      evaluate_0.21    \n[25] yaml_2.3.7        rlang_1.1.1       jsonlite_1.8.5    htmlwidgets_1.6.2\n```\n:::\n:::\n\n</details>\n\n[^unown]: This is a PokÃ©mon joke. I could have gone with [Type: Null](https://bulbapedia.bulbagarden.net/wiki/Type:_Null_(Pok%C3%A9mon)), but it's too hard to draw.\n[^align]: You can dismiss these warning markers in the Excel GUI, but I don't think it's possible to suppress these markers programmatically and proactively in {a11ytables}. Note also that {a11ytables} cheats a bit here for sake of presentation. The `generate_workbook()` function guesses that the column was intended to be numeric and adds style information to right-align the values in the output xlsx, which is how numeric values are normally treated in Excel.\n[^coerce]: There's a sort of 'coercion hierarchy' in R. The order is like logical > integer > numeric > character, where the latter are 'dominant' to those prior (massive oversimplification). As an aside, this results in some oddities to the untrained eye: `sum(2, TRUE)` resolves to `3`, because `TRUE` is coerced to the numeric value `1` (`FALSE` is `0`) and so we get 2 + 1 = 3.\n[^pun]: Turns out there's literally such a thing as [type punning](https://en.wikipedia.org/wiki/Type_punning).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
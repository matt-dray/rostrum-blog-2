---
title: "Little pixel fun zone"
date: 2024-09-15
slug: "shiny-pixel"
image: resources/SANIC.png
categories:
  - pixeltrix
  - r
  - shiny
  - shinylive
---

![Fast blue hedgehog man in Little Pixel Fun Zone, Act 1 (original art by the author).](resources/SANIC.png){fig-align="left" fig.alt="Screenshot of a web app called 'little pixel fun zone'. in the centre is a child's drawing of the fast blue hedgehog rendered in blocky square pixels. Under the image are some buttons to select a colour, undo, fill and downloade outputs." width='50%'}

## tl;dr

A simple toy pixel-editor for the browser, which helped me learn about reacting to user clicks and implementing undo/redo in {shiny}.

## Just browsing

[The {pixeltrix} package](https://github.com/matt-dray/pixeltrix) is a local pixel editor you can run from the R console[^readmore]. It's intentionally simple. You start a graphics device and click the squares ('pixels'), cycling through your provided colour palette. You're returned a little pixeltrix-class matrix as a memento, which you can re-edit later.

It might be nice to have a browser-based version, but I've never really had the time and figured it would be too fiddly. Well guess what, I had some time and it wasn't that fiddly.

I've been learning a bit more [{shiny}](https://shiny.posit.co/) of late. This mini project was a good way to learn a few things that might come in handy later. In particular, how to:

1. Read a clicked point on a plot and react to it.
2. Implement a basic undo/redo feature.

## App

The app is available [on a standalone webpage](https://matt-dray.github.io/little-pixel-fun-zone/) and [the source on GitHub](https://github.com/matt-dray/little-pixel-fun-zone) (v0.3.0 at time of writing). I used [{shinylive}](https://posit-dev.github.io/r-shinylive/) to compile it so it runs serverless on GitHub Pages. I've also embedded it below. Yes, click the squares!

<iframe width='450' height='600' src='https://matt-dray.github.io/little-pixel-fun-zone/' title='little-pixel-fun-zone'></iframe>

There's (intentionally) only a few features. You can:

* click a pixel to toggle it on/off
* change the colour, thanks to [Dean Attali's {colourpicker}](https://daattali.com/shiny/colourInput/)
* undo/redo (with a very short 'memory')
* flood fill
* have an assistant ✨AI ✨draw a picture for you[^bot]
* download a matrix representation of your treasured art (pixeltrix-class, for my own needs)
* download a png copy of your treasured art

Wow!

## Tricks

I mentioned there were two things I learnt in particular: handling click-reacts and undo/redo.

### Click-react

{pixeltrix} reads the coordinates of a user's click on the plotting device, thanks to the `locator()` function (witchcraft). The returned values can be used to identify the nearest 'pixel' clicked.

With {shiny} we can capture an input that is itself generated from an output object. In the example below, we output the plot `pixel_plot` generated in the server and then a `click` on that plot by the user would be registered as `clicked_point` for retrieval in the server. In my case, I took the x and y elements of that object and matched them to the nearest pixel (using self-plagiarised {pixeltrix} code). I also made the click trigger `observeEvent()` to refresh the plot given the user's selection.

```{r, eval=FALSE}
shiny::plotOutput(
  outputId = "pixel_grid",  # the plot of the pixel grid
  click = shiny::clickOpts(
    id = "clicked_point",  # to retrieve as input$clicked_point in server
    clip = TRUE  # restrict to plot bounds?
  )
)
```

Note also that there's arguments for `dblclick`, `hover` and `brush` that may also come in handy.

### Undo/redo

Yes, if you do a misclick in your precious picture, you could just change the colour and re-click the errant point. But that takes, ooh, perhaps a couple of seconds. Instead, it seems more conceptually fun to have an undo button. And imagine how exhilarating it would be if that button toggled to redo after it was clicked?

So, there's probably lots of ways to do this, but I settled on keeping a sort of cyber-goldfish brain using `reactiveValues()`. The first (of two) 'memory slots' is the current matrix representation of the drawing and the second slot is the previous matrix state. Each time you update the drawing, slot 1 overwrites slot 2 and the new matrix takes its place in slot 1.

I set up a 'blank' grid at startup:

```{r, eval=FALSE}
pixel_matrices <- shiny::reactiveValues(slot1 = .gen_grid(16, "#E5E5E5"))
```

And then `observeEvent()` handles post-click activity. After the user clicks on the plot surface, the coordinates and selected colour are used to toggle or adjust a pixel. The new version of the representational matrix is added to slot 1 and the prior one slips to slot 2.

```{r, eval=FALSE}
shiny::observeEvent(input$clicked_point, {  # trigger on click
  
  matrix_updated <- .gen_updated_pixel_matrix(  # update current drawing
    shiny::isolate(pixel_matrices[["slot1"]]),  # the current drawing
    pixel_coords(),  # location of clicked point to update
    input$selected_colour  # current user-selected colour
  )
  
  pixel_matrices[["slot2"]] <- pixel_matrices[["slot1"]]  # current is now old
  pixel_matrices[["slot1"]] <- matrix_updated  # new is now current
  
})
```

Could the so-called cyber-goldfish brain be larger, with more brain slots? No, because then it would be a cyber-elephant and I think that mental image is less funny. But yes, you could probably create slots on the fly and have the ability to undo much further back in history.

I mentioned do-overs. The icon for the undo/redo button is stored in a `reactiveVal()` that starts as 'undo' arrow. When clicked, we flip the memory slots and also update the icon to be a 'redo' arrow. Another click of the button and the situation will revert again[^redo]. Voila: time travel.

```{r, eval=FALSE}
button_icon <- shiny::reactiveVal("rotate-left")  # starting condition

shiny::observeEvent(input$button_undo, {  # trigger on click
    
    # Switch 'memory' slots
    slot1 <- pixel_matrices[["slot1"]]
    slot2 <- pixel_matrices[["slot2"]]
    pixel_matrices[["slot2"]] <- slot1
    pixel_matrices[["slot1"]] <- slot2
    
    # Invert undo/redo icon
    
    current_icon <- undo_button_icon()
    if (current_icon == "rotate-left") undo_button_icon("rotate-right")
    if (current_icon == "rotate-right") undo_button_icon("rotate-left")
    
    shiny::updateActionButton(
      inputId = "button_undo",
      icon = shiny::icon(button_icon())
    )
    
  })
```

Inelegant, perhaps, but manageable[^primer].

## Fiddly is money

There's a number of features I could implement, if only I could perceive that I have more time and that the fiddlyometer gauge is lower. Yes, this is current me goading future me. Until then, drop bug reports and how to fix them in [the issues](https://github.com/matt-dray/little-pixel-fun-zone/issues). 

Also use the app to draw and send me a classic videogame action scene, obviously (see inspiration at top of post).

### Environment {.appendix}

<details><summary>Session info</summary>
```{r sessioninfo, eval=TRUE, echo=FALSE}
cat("Last rendered:", format(Sys.time(), usetz = TRUE)); sessionInfo()
```
</details>

[^bot]: This most often _looks_ like random noise, but I'm sure that's because of the training set or something. Maybe squint? I've been told that robot self-portraits sometimes appear, but I'm sure that's just a hallucination.
[^readmore]: You can read about {pixeltrix} in [other posts](https://www.rostrum.blog/index.html#category=pixeltrix).
[^redo]: If you undo and then make a new click, then the undo/redo button will continue to show the 'redo' icon. Subtle, but to avoid this, you must reset the `reactiveVal()` to show the 'undo' icon if you perform any other actions after undoing.
[^primer]: If we messed with time travel and things didn't go a bit [_Primer_](https://en.wikipedia.org/wiki/Primer_(film)), then I'd say we've done well.
---
title: "The {grid} underlying {hexbase}"
date: 2025-02-09
slug: "hexbase-grid"
image: resources/
categories:
  - grid
  - hexbase
  - r
---

![](resources/){fig-align="left" fig-alt="" width='50%'}

## tl;dr

A little detail on my na√Øve attempts to use {grid} graphics to make {hexbase}, a dependency-free R package for making hex stickers.

## 

I [wrote about](https://www.rostrum.blog/posts/2025-01-31-hexbase/) an R package I'd put together for making hex stickers, [{hexbase}](https://github.com/matt-dray/hexbase), which is built without dependencies. Instead it relies on [the {grid} package](https://www.stat.auckland.ac.nz/~paul/grid/grid.html), which is built into the base installation of R.

{grid} lets you build up plots and layouts from basic principles, offering ultimate flexibility. Both {ggplot2} and the legendary {lattice} package, also part of base R, are made using {grid} under the hood.

I chose to use {grid} for {hexbase} for a few reasons:

* when building a hex, you're not really 'plotting' as much as you are 'arranging' elements
* you don't necessarily _need_ any dependencies for this task
* I've never used {grid}, lol

I don't want to write a guide for using {grid} because I know little and I feel like {hexbase} only scratches the surface anyway. Most of the code can be improved, but I thought I'd explain the approach used in {hexbase}.

## A walkthrough

I'll give a simple demo of {hexbase} in action and then step through the functions to give a conceptual overview.

### The front-end

From the user perspective, the steps are to:

1. Open a PNG graphics device with `open_hex()`.
2. Add the hexagon with `add_hex()`.
3. Add and arrange as many text and image elements as you like with `add_text()` and `add_image()`.
4. Close the device and write the file with `close_device()`.

We don't need anything complex for this example. I just took a free image from a website and added it to a basic hex with some text:

```{r}
#| eval: false

# Somewhere to save it
temp_path <- tempfile(fileext = ".png")

# 'Bring your own image', e.g. with {png}
image_path <- system.file("img", "Rlogo.png", package = "png")
image_png <- png::readPNG(image_path)

hexbase::open_device(file_path = temp_path)
hexbase::add_hex(
  border_width = 0.06,
  border_col = "hotpink3",
  bg_col = "bisque"
)
hexbase::add_image(
  image_object = image_png,
  image_y = 0.6,
  image_angle = 20,
  image_width = 0.5
)
hexbase::add_text(
  text_string = "example",
  text_x = 0.495,
  text_y = 0.35,
  text_col = "#000000",
  text_family = "Comic Sans MS",
  text_face = "bold"
)
hexbase::add_text(
  text_string = "example",
  text_x = 0.505,
  text_y = 0.34,
  text_col = "red",
  text_family = "Comic Sans MS",
  text_face = "bold"
)
hexbase::add_text(
  text_string = "visit https://rstats.lol ftw",
  text_x = 0.73, 
  text_y = 0.18,
  text_angle = 30,  # rotate to match lower-right edge
  text_size = 5,  # point size
  text_col = "blue", 
  text_family = "Papyrus"
)
hexbase::close_device() 
```

### The back-end

So let me explain what's going on in the code.

`open_device()` calls a `png()` graphics device pre-filled with the width and height of the stickers standard and a transparent background. The graphics device will be populated with grobs and eventually saved to file in `close_device()`.

The hex is built of two 'points-up-and-down' hexagons: one 'outer', one 'inner'. With `add_hex()`, the inner is placed on top of the outer and the space between them is the border (so controlling the `border_width` argument actually just changes the size of the inner hex). The function begins by fetching the vertex coordinates of the hexes. We also grab the range of the x and y coordinates. The area we're drawing to has a height and width of 1. The width of the outer hex is actually a little smaller than 1, which means we have to chop off the slivers outside of the horizontal extent. We push a viewport with this scale. We create a polygonGrob of the outer hex points, which we first use in another viewport that will be used later to clip out any element that falls outside the hexagon. Then we `grid.draw()` the outer-hex grob, followed by the interior one. The outer hex is filled with the `border_col` and the inner hex is coloured with the `bg_col`. The inner hex's size is controlled by the `border_width`. So at the end of of open_device(), we've opened (but not closed) two viewports (one that serves as the parent to all subsequent grobs and one that will allow clippping at the end) and added the outer and inner hex to the graphics device.

The hex grobs are added with 'native' rather than 'npc' units. This means that the hexes fill the horizontal space.

The `add_text()` and `add_image()` functions work in simmilar fashion: a viewport is opened to house the element, and grid.text() or grid.raster() are used to add the text or image grob. Crucially, we put that grob in another viewport in which we can control rotation. We nest the viewports this way so that the user controls the x and y positions or a rotated text or image relative to the hex. If we didn't do this, the x and y positions would be relative to the element's rotation.

Finally, when we `close_device()` we're popping the two open viewports, including the one that clips out any content that falls outside the extent of the hexagon, and running `dev.off()` to close the device and save it to the path specified by `file_path` in `open_device()`.

Push a viewport that will clip the viewport when popped. This happens at the end, in `close_device()`.

## Going off{grid}

Something I'm quite keen on is to allow for base plot to be added to the hex. This seems fitting; the packahge is made with base R, so wouldn't it be nice to add a nice base R plot to the hex?

This isn't as easy as it seems. The `plot()` funciton, for example, isn't built with {grid}. You have to convert this type of object to a grob so it can be placed on the hex.

There seems to be an inescapable truth to this process: you need to depend on a package to do it easily. Prof Murrell has also created [{gridBase}](https://cran.r-project.org/package=gridBase)[^rotate] to put a plot in a viewport and [{gridGraphics}](https://cran.r-project.org/package=gridGraphics) to convert a plot to grobs. Using {gridgraphics}, `ggplotify::base2grob()` does what it says on the tin:

```{r}
#| eval: false

# Start with hexbase
temp_path <- tempfile(fileext = ".png")
hexbase::open_device(file_path = temp_path)
hexbase::add_hex(0)

# Add a base plot without {hexbase}
grid::pushViewport(grid::viewport())
base_plot <- ggplotify::base2grob(
  \() {
    par(mar = rep(0, 4))  # no plot margin
    plot(
      runif(n), runif(n),  # 'random' points
      xaxs = "i", yaxs = "i",  # 'edge-to-edge' plot
      axes = FALSE, ann = FALSE,  # no chart stuff
      pch = 16, col = palette.colors(n, , , TRUE)  # style points
    )
  }
)
grid::grid.draw(base_plot)  # it's a grob now, we can draw it
grid::popViewport()

# Finish up with {hexbase}
hexbase::add_text("hexbase")
hexbase::close_device()

# Open file to view it
system(paste("open", temp_path))
```


The question is whether I can engineer a function myself to convert base plots to grobs, or whether I'll need to lean on e.g. {gridGraphics}. In the latter case, {hexbase} would no longer be 'dependency free'. Instead it would be 'dependency light'. I think this could be acceptable, given that {gridGraphics} is small in size and is part of the 'gridverse' (I think we can make this a thing).

However, the name '{hexbase}' would then be stretching the truth slightly. Pretty sure that {hexNearlyButNotQuiteBaseOnly} is available on CRAN... might need to workshop that one. Ah well, at least I'll be able to make a hex sticker for it, lol.

### Environment {.appendix}

<details><summary>Session info</summary>
```{r sessioninfo, eval=TRUE, echo=FALSE}
cat("Last rendered:", format(Sys.time(), usetz = TRUE)); sessionInfo()
```
</details>

[^rotate]: Although [with {gridBase}](https://cran.r-project.org/web/packages/gridBase/vignettes/gridBase.pdf) 'it is not possible to embed base graphics output within a grid viewport that is rotated'. This might be inconsistent for {hexbase}, which allows you to rotate text and image grobs.